[{"contents":" Build instructions  Install Visual Studio Community 2015 with C++ development tools. Install CMake. Install NASM Choose the 64 of 32 bit version, depending on your system (both should work fine). Open a command prompt at the PixTudio source code folder and ensure that CMake \u0026amp; NASM are available in your path.  ##Compile zlib: cd 3rdparty/zlib-1.2.8 md build cd build cmake -G\u0026rdquo;Visual Studio 14 2015\u0026rdquo; -DCMAKE_INSTALL_PREFIX=%cd%/../dist .. cmake \u0026ndash;build . \u0026ndash;config Release cmake \u0026ndash;build . \u0026ndash;config Release \u0026ndash;target INSTALL cd ......\n##Compile libpng cd 3rdparty\\libpng-1.6.23 md build cd build cmake -G\u0026rdquo;Visual Studio 14 2015\u0026rdquo; -DCMAKE_INSTALL_PREFIX=%cd%/../dist -DZLIB_ROOT=%cd%/../../zlib-1.2.8/dist .. cmake \u0026ndash;build . \u0026ndash;config Release cmake \u0026ndash;build . \u0026ndash;config Release \u0026ndash;target INSTALL cd ......\n##Compile libjpeg-turbo cd 3rdparty\\libjpeg-turbo-1.5.1 md build cd build cmake -G\u0026rdquo;Visual Studio 14 2015\u0026rdquo; -DCMAKE_INSTALL_PREFIX=%cd%/../dist .. cmake \u0026ndash;build . \u0026ndash;config Release cmake \u0026ndash;build . \u0026ndash;config Release \u0026ndash;target INSTALL cd ......\n##Compile FreeType cd 3rdparty\\freetype-2.7 md build cd build cmake -G\u0026rdquo;Visual Studio 14 2015\u0026rdquo; -DCMAKE_INSTALL_PREFIX=%cd%/../dist .. cmake \u0026ndash;build . \u0026ndash;config Release cmake \u0026ndash;build . \u0026ndash;config Release \u0026ndash;target INSTALL cd ......\n##Compile libcurl cd 3rdparty\\curl-7.51.0 md build cd build cmake -G\u0026rdquo;Visual Studio 14 2015\u0026rdquo; -DCMAKE_INSTALL_PREFIX=%cd%/../dist -DBUILD_TESTING=OFF -DBUILD_CURL_EXE=OFF -DCMAKE_STATICLIB=ON -DZLIB_ROOT=%cd%/../../zlib-1.2.8/dist .. cmake \u0026ndash;build . \u0026ndash;config Release cmake \u0026ndash;build . \u0026ndash;config Release \u0026ndash;target INSTALL cd ......\n##Compile libogg cd 3rdparty\\SDL2_mixer\\external\\libogg-1.3.1\nmd build cd build cmake -G\u0026rdquo;Visual Studio 14 2015\u0026rdquo; -DCMAKE_INSTALL_PREFIX=%cd%/../dist .. cmake \u0026ndash;build . \u0026ndash;config Release cmake \u0026ndash;build . \u0026ndash;config Release \u0026ndash;target INSTALL cd ..........\n##Compile libvorbis cd 3rdparty\\SDL2_mixer\\external\\libvorbis-1.3.3 md build cd build cmake -G\u0026rdquo;Visual Studio 14 2015\u0026rdquo; -DCMAKE_INSTALL_PREFIX=%cd%/../dist -DLIBOGG_PATH=%cd%/../../libogg-1.3.1 .. cmake \u0026ndash;build . \u0026ndash;config Release cmake \u0026ndash;build . \u0026ndash;config Release \u0026ndash;target INSTALL cd ..........\n##Compile libtheora cd 3rdparty\\libtheora-1.1.1 md build cd build cmake -G\u0026rdquo;Visual Studio 14 2015\u0026rdquo; -DCMAKE_INSTALL_PREFIX=%cd%/../dist -DLIBOGG_PATH=%cd%/../../SDL2_mixer/external/libogg-1.3.1 .. cmake \u0026ndash;build . \u0026ndash;config Release cmake \u0026ndash;build . \u0026ndash;config Release \u0026ndash;target INSTALL cd ......\n##Compile libtre cd 3rdparty\\tre md build cd build cmake -G\u0026rdquo;Visual Studio 14 2015\u0026rdquo; -DCMAKE_INSTALL_PREFIX=%cd%/../dist .. cmake \u0026ndash;build . \u0026ndash;config Release cmake \u0026ndash;build . \u0026ndash;config Release \u0026ndash;target INSTALL cd ......\n##Compile SDL2 cd 3rdparty\\SDL2 md build cd build cmake -G\u0026rdquo;Visual Studio 14 2015\u0026rdquo; -DCMAKE_INSTALL_PREFIX=%cd%/../dist .. cmake \u0026ndash;build . \u0026ndash;config Release cmake \u0026ndash;build . \u0026ndash;config Release \u0026ndash;target INSTALL cd ......\n##Compile PXTB cd projects\\cmake\\pxtb md build cd build cmake -G\u0026rdquo;Visual Studio 14 2015\u0026rdquo; -DCMAKE_INSTALL_PREFIX=%cd%/../../ -DSDL2_PATH=%cd%/../../../../3rdparty/SDL2/dist -DZLIB_ROOT=%cd%/../../../../3rdparty/zlib-1.2.8/dist -DSTEAMWORKS_PATH=%cd%/../../../../3rdparty/steamworks .. cmake \u0026ndash;build . \u0026ndash;config Release cmake \u0026ndash;build . \u0026ndash;config Release \u0026ndash;target INSTALL cd ....\\bin\\win32 copy ........\\3rdparty\\zlib-1.2.8\\dist\\bin\\zlib.dll . cd ........\n","permalink":"https://divhub.github.io/pixtudio-website/docs/compiling_visual_studio/","title":""},{"contents":" Definition FLOAT abs ( \u0026lt;FLOAT value\u0026gt; )\nReturns the absolute value of value.\nParameters FLOAT value - The value.\nReturns FLOAT : The absolute value of value.\nExample Global float value1; int value2; End Process Main() Begin write_float(0,0, 0,0,\u0026amp;value1); write_int(0,0,10,0,\u0026amp;value2); value1 = abs(3); value2 = abs(-4); Repeat frame; Until(key(_ESC)) End  Used in example: write_float(), write_int(), abs(), key()\nCategory:functions Category:math Category:mod_math\n","permalink":"https://divhub.github.io/pixtudio-website/docs/abs/","title":""},{"contents":" Syntax FLOAT acos ( \u0026lt;FLOAT value\u0026gt; )\nDescription Returns the arccosine of a certain value.\nThis function performs an arccosine calculation on a certain value and returns an angle between and including 0 and 180000 (0-180º).\nParameters FLOAT value - The value to be performed an arccosine calculation on.\nReturns FLOAT : The arccosine result of the specified value, an angle between and including 0 and 180000 (0-180º).\nNotes The angle value returned by this function is in thousandths of degrees, as most angles within Bennu are.\nTo read about all aspects of trigonometry, you can visit Wikipedia\u0026rsquo;s Trigonometric function page.\nCategory:functions Category:math Category:mod_math\n","permalink":"https://divhub.github.io/pixtudio-website/docs/acos/","title":""},{"contents":" Projects\nHow to add To add a project to the list, simply create a page in the Project namespace (create an article with name: Project:\u0026lt;projectname\u0026gt;) and add it to the category Projects. That\u0026rsquo;s all the work to add a project, but if you should want multiple pages, it might be a good idea to add all pages created for this project to the categories Projects and Project\u0026lt;projectname\u0026gt; by putting the following lines in the article:\n[[Category:Projects]] [[Category:Project\u0026lt;projectname\u0026gt;]]  Also it is advised to use this template for quick info about your project.\nWhat to add All sorts of projects are welcome, from a simple space invaders to a full blown MMORPG. Other kinds are also welcome, like DLL\u0026rsquo;s or other secondary system projects.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/add_a_project/","title":""},{"contents":" Definition INT advance ( \u0026lt;INT distance\u0026gt; )\nMoves the calling process forward by distance units in the direction of the process\u0026rsquo; angle.\nThis function is influenced by the local variables angle and resolution.\nParameters INT distance - Distance to advance in units.\nReturns INT : Returns true if successful and false if failed.\nExample import \u0026quot;mod_grproc\u0026quot; import \u0026quot;mod_map\u0026quot; import \u0026quot;mod_wm\u0026quot; // for exit_status import \u0026quot;mod_key\u0026quot; // for key() import \u0026quot;mod_proc\u0026quot; Process Main() Private int my_proc; Begin proc(); //create a new process proc2(); //create a new process Repeat frame; Until(key(_ESC) || exit_status) OnExit signal(my_proc,S_KILL); End Process proc() Begin // Create a cyan square and assign it to 'graph' graph = map_new(100,100,8); map_clear(0,graph,rgb(0,255,255)); // Set starting position x = 50; y = 50; // This loop makes this process advance 3 pixels every frame Loop advance(3); // advance 3 pixels frame; End End Process proc2() Begin // Set resolution to 100 resolution = 100; // Create a cyan square and assign it to 'graph' graph = map_new(100,100,8); map_clear(0,graph,rgb(0,255,255)); // Set starting position x = 50*resolution; y = 150*resolution; // This loop makes this process advance 3/100 pixels every frame Loop advance(3); // advance 3/100 pixels frame; End OnExit map_unload(0,graph); End  Used in example: key(), signal(), map_new(), map_clear(), rgb(), advance(), map_unload(), exit_status, graph, x, y, resolution\nCategory:functions Category:processinteraction Category:mod_grproc\n","permalink":"https://divhub.github.io/pixtudio-website/docs/advance/","title":""},{"contents":" Description Alignment modes are modes which indicate how a graphic or text will be aligned relative to its center.\nList Constant - Value ALIGN_TOP_LEFT - 0 ALIGN_TOP - 1 ALIGN_TOP_RIGHT - 2 ALIGN_CENTER_LEFT - 3 ALIGN_CENTER - 4 ALIGN_CENTER_RIGHT - 5 ALIGN_BOTTOM_LEFT - 6 ALIGN_BOTTOM - 7 ALIGN_BOTTOM_RIGHT - 8\nCategory:constantcategories\n","permalink":"https://divhub.github.io/pixtudio-website/docs/alignment_modes/","title":""},{"contents":" Syntax VOID POINTER alloc ( \u0026lt;INT size\u0026gt; )\nDescription Allocates a block of memory of a certain size. Returns a pointer to the newly allocating memory block, or NULL on failure.\nAlso called mem_alloc().\nParameters INT size - The size of the to be allocated memory in bytes.\nReturns VOID POINTER : Pointer to the first element of the allocated memory block.\nNULL - There was are an error allocating the memory, like insufficient memory available. - Pointer to the first element of the allocated memory block.\nExample import \u0026quot;mod_mem\u0026quot; import \u0026quot;mod_say\u0026quot; Process Main() Private byte* pbyte; word* pword; int* pint; int elements = 10; int i; Begin // Allocate memory pbyte = alloc(elements); pword = alloc(elements*sizeof(*pword)); // note the sizeof() here, this is possible! pint = alloc(elements*sizeof(int)); // Reset memory to 0's memset (pbyte,0,elements); memsetw(pword,0,elements); // same as memset(pword,0,elements*sizeof(word)); // because value-parameter is 0. memseti(pint ,0,elements); // same as memset(pint,0,elements*sizeof(int)); // because value-parameter is 0. // Write numbers to bytes and ints for(i=0; i\u0026lt;elements; i++) pbyte[i] = 133; // pbyte[i] is the same as *(pbyte+i) *(pint+i) = 4555; // pint[i] is the same as *(pint+i) end // Write numbers to words memsetw(pword,345,elements); // Show numbers for(i=0; i\u0026lt;elements; i++) say(\u0026quot;byte[\u0026quot;+i+\u0026quot;] = \u0026quot; + *(pbyte+i)); say(\u0026quot;word[\u0026quot;+i+\u0026quot;] = \u0026quot; + pword[i]); say(\u0026quot;int [\u0026quot;+i+\u0026quot;] = \u0026quot; + pint[i]); end OnExit // Free the used memory free(pbyte); free(pword); free(pint); End  Example 2 The following three examples show the difference in size, when array\u0026rsquo;s are created. Note the use of the sizeof() operator, to calculate the amount of bytes required for the data type. You can also allocate user defined types and even structs. Be carefull with strings though, as they show up as 4 bytes, but in the case of strings, you get a pointer (start adress) of the string, wich is a 4 byte integer.\nExample 1 - array of 10 (4 byte) integers Example 2 - array of 10 (1 byte) byte (could also be char) Example 3 - array of 10 (2 byte) short integers\n// Some general remarks with manual memory managment, ALWAYS free data after use, and test if an // allocation was successfull with IF (p_test_array2==NULL). When one of these memory allocation // functions returns a NULL, the allocation was NOT sucessfull, and any kind of unpredicatable things // can happen. With manual memory managment, you'll have to really know what you're doing, as the slightest // mistake can cause crashes and unpredicatable behaviour, wich is one of the dangers with using pointers. // import modules IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_mem\u0026quot;; /* alloc(int size); returns: void pointer purpose: create a block of memory, of a certain size, the returned pointer indicates the start adress of this block. */ GLOBAL int pointer p_first_array; // 10 elments, created with alloc(), 10 integers (4 byte elements) byte pointer p_second_array; // 10 elments, created with alloc(), 10 bytes (1 byte elements) short pointer p_third_array; // 10 elments, created with alloc(), 10 short integers (2 byte elements) int elements=10; // initial array size int count; // general purpose loop counter PROCESS main(); BEGIN // Allocate memory (10 integers), this way we create an array of integers from (0-9, so 10 elements) // The alloc() function works with bytes. It is always good practice to use the sizeof() operator, because // you'd have to know exactly how many bytes make up a particulair data. An integer is 4 bytes in bennu, // so for an array of 10 elements, you need to allocate 40 bytes. If you do \u0026quot;alloc(elements)\u0026quot;,like in the // wiki, you only get 4 bytes! so that is totally too small for you array! always use this syntax: // // alloc(sizeof(\u0026lt;data_type\u0026gt;)), or for arrays: alloc(elements*sizeof(\u0026lt;data_type\u0026gt;)). Note that \u0026lt;data_type\u0026gt; can // also be a user-defined type. p_first_array=alloc(elements*sizeof(int)); // check if the allocation succeeded IF (p_first_array==NULL) // allocation failed say(\u0026quot;allocation failed!! p_first_array=\u0026quot;+p_first_array); ELSE // allocation succeeded // set the value's to zero memseti(p_first_array ,0,elements); say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); // print the array FOR (count=0; count\u0026lt;elements; count+=1) say(\u0026quot;p_first_array[\u0026quot;+count+\u0026quot;]=\u0026quot;+p_first_array[count]); END say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;the size of the array is \u0026quot;+(elements*sizeof(int))+\u0026quot; bytes\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); END // now let's create an array of 10 bytes, the size of the array will be 10 * 1 byte =10 bytes p_second_array=alloc(elements*sizeof(byte)); // check if the allocation succeeded IF (p_first_array==NULL) // allocation failed say(\u0026quot;allocation failed!! p_second_array=\u0026quot;+p_second_array); ELSE // allocation succeeded // set the value's to zero memseti(p_second_array ,0,elements); say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); // print the array FOR (count=0; count\u0026lt;elements; count+=1) say(\u0026quot;p_second_array[\u0026quot;+count+\u0026quot;]=\u0026quot;+p_second_array[count]); END say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;the size of the array is \u0026quot;+(elements*sizeof(byte))+\u0026quot; bytes\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); END // now let's create an array of 10 short integers, the size of the array will be 10 * 2 bytes =20 bytes p_third_array=alloc(elements*sizeof(short)); // check if the allocation succeeded IF (p_first_array==NULL) // allocation failed say(\u0026quot;allocation failed!! p_second_array=\u0026quot;+p_third_array); ELSE // allocation succeeded // set the value's to zero memseti(p_third_array ,0,elements); say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); // print the array FOR (count=0; count\u0026lt;elements; count+=1) say(\u0026quot;p_third_array[\u0026quot;+count+\u0026quot;]=\u0026quot;+p_third_array[count]); END say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;the size of the array is \u0026quot;+(elements*sizeof(short))+\u0026quot; bytes\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); END ONEXIT // Free the used memory say(\u0026quot;freeing old memory........\u0026quot;); say(\u0026quot;p_first_array...\u0026quot;); free(p_first_array); say(\u0026quot;ok\u0026quot;); say(\u0026quot;freeing old memory........\u0026quot;); say(\u0026quot;p_second_array...\u0026quot;); free(p_second_array); say(\u0026quot;ok\u0026quot;); say(\u0026quot;freeing old memory........\u0026quot;); say(\u0026quot;p_third_array...\u0026quot;); free(p_third_array); say(\u0026quot;ok\u0026quot;); END  Used in example: alloc(), memset(), memsetw(), memseti(), sizeof(), say(), free(), OnExit, pointer, sizeof\nCategory:functions Category:memory Category:mod_mem\n","permalink":"https://divhub.github.io/pixtudio-website/docs/alloc/","title":""},{"contents":" OLD: From namespaces other than the general one, including redirects: \u0026lt;dpl\u0026gt; notnamespace= titlematch=% redirects = include format = ,,, resultsheader = %PAGES%\\n \u0026lt;/dpl\u0026gt; From the general namespace, without redirects: \u0026lt;dpl\u0026gt; namespace= titlematch=% format = ,,, resultsheader = %PAGES%\\n \u0026lt;/dpl\u0026gt; From the general namespace, the redirects: \u0026lt;dpl\u0026gt; namespace= titlematch=% redirects = only format = ,,, resultsheader = %PAGES%\\n \u0026lt;/dpl\u0026gt; ========== \u0026lt;dpl\u0026gt; notnamespace= titlematch=% redirects = include format = ,,\\n\\n[[%PAGE%]], \u0026lt;/dpl\u0026gt; \u0026lt;dpl\u0026gt; namespace= titlematch=% format = ,,\\n\\n[[%PAGE%]], \u0026lt;/dpl\u0026gt; \u0026lt;dpl\u0026gt; namespace= titlematch=% redirects = only format = ,,\\n\\n[[%PAGE%]], \u0026lt;/dpl\u0026gt;  All, A-C:  titleregexp=\\^[A-C].*\\$ redirects = include format = ,,, resultsheader = %PAGES%\\n  All, D-F:  titleregexp=\\^[D-F].*\\$ redirects = include format = ,,, resultsheader = %PAGES%\\n  All, G-I:  titleregexp=\\^[G-I].*\\$ redirects = include format = ,,, resultsheader = %PAGES%\\n  All, J-L:  titleregexp=\\^[J-L].*\\$ redirects = include format = ,,, resultsheader = %PAGES%\\n  All, M-O:  titleregexp=\\^[M-O].*\\$ redirects = include format = ,,, resultsheader = %PAGES%\\n  All, P-R:  titleregexp=\\^[P-R].*\\$ redirects = include format = ,,, resultsheader = %PAGES%\\n  All, S-U:  titleregexp=\\^[S-U].*\\$ redirects = include format = ,,, resultsheader = %PAGES%\\n  All, V-X:  titleregexp=\\^[V-X].*\\$ redirects = include format = ,,, resultsheader = %PAGES%\\n  All, Y-Z:  titleregexp=\\^[Y-Z].*\\$ redirects = include format = ,,, resultsheader = %PAGES%\\n  All, rest:  titleregexp=\\^[\\^A-Z].*\\$ redirects = include format = ,,, resultsheader = %PAGES%\\n  ==========  titleregexp=\\^[A-C].*\\$ redirects = include format = ,,\\n\\n%PAGE%,   titleregexp=\\^[D-F].*\\$ redirects = include format = ,,\\n\\n%PAGE%,   titleregexp=\\^[G-I].*\\$ redirects = include format = ,,\\n\\n%PAGE%,   titleregexp=\\^[J-L].*\\$ redirects = include format = ,,\\n\\n%PAGE%,   titleregexp=\\^[M-O].*\\$ redirects = include format = ,,\\n\\n%PAGE%,   titleregexp=\\^[P-R].*\\$ redirects = include format = ,,\\n\\n%PAGE%,   titleregexp=\\^[S-U].*\\$ redirects = include format = ,,\\n\\n%PAGE%,   titleregexp=\\^[V-X].*\\$ redirects = include format = ,,\\n\\n%PAGE%,   titleregexp=\\^[Y-Z].*\\$ redirects = include format = ,,\\n\\n%PAGE%,   titleregexp=\\^[\\^A-Z].*\\$ redirects = include format = ,,\\n\\n%PAGE%, \n","permalink":"https://divhub.github.io/pixtudio-website/docs/allpages/","title":""},{"contents":" category:variables category:predefined category:local variables category:librender\nUp to Local Variables\nDefinition INT angle = 0\nAngle is a predefined local variable which holds the angle (measured in 1\u0026frasl;1000 of a degree) at which the graphic of that process (assigned by the local variable graph) will be drawn. It also influences the result of the function advance().\nAn angle of 0 means to the right, 90000 means up, 180000 means left and 270000 and -90000 mean down.\nExample To make the graphic of a process spin:\nimport \u0026quot;mod_grproc\u0026quot; import \u0026quot;mod_map\u0026quot; import \u0026quot;mod_wm\u0026quot; // for exit_status import \u0026quot;mod_key\u0026quot; // for key() Process Main() Begin graph = map_new(100,100,8); //Create a cyan square and assign it to 'graph' map_clear(0,graph,rgb(0,255,255)); x = 160; //Position the graphic's center y = 100; //in the center of the screen Repeat angle += 1000; //increase the angle of graphic by 1000 each frame. 1000 = 1 degree. frame; Until(key(_ESC) || exit_status) OnExit map_unload(0,graph); End  Used in example: map_new(), map_clear(), rgb(), map_unload(), key(), exit_status, graph, x, y, angle\nThis process will spin the cyan square by 1 degree each frame.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/angle/","title":""},{"contents":" category:variables category:predefined category:global variables category:internal\nUp to Global Variables Up to Internal\nDefinition INT argc\nArgc is a global variable, holding the number of arguments passed when calling BGDI, including the bytecode file. The arguments can be found in the global variable argv.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/argc/","title":""},{"contents":" Definition An argument is the value passed on when calling a function or process. The variable and its value inside the definition of a function or process is called a parameter.\nExample Function int my_proc( int parameter ) Begin //statements return 0; End  Process Main() Private int argument = 3; Begin my_proc( argument ); my_proc( 4); End  See also  Parameter  ","permalink":"https://divhub.github.io/pixtudio-website/docs/argument/","title":""},{"contents":" category:variables category:predefined category:global variables category:internal\nUp to Global Variables Up to Internal\nDefinition STRING[32] argv\nArgv is a global variable, holding the arguments with which BGDI was called, including the bytecode file.\nargv[0] - The bytecode file (possibly without extension). argv[1] - First argument. argv[2] - Second argument. argv[n] - *n*th argument.\nIf an argument was not given, the corresponding string will be \u0026quot;\u0026quot; (empty string). The number of arguments passed can be found with argc. This means that argv[argc-1] is the last argument.\nExample import \u0026quot;mod_say\u0026quot; Process Main() Private int i; Begin say(\u0026quot;Bytecode file: \u0026quot; + argv[0]); i = 1; while(i\u0026lt;argc) say(\u0026quot;Argument \u0026quot; + i + \u0026quot;: \u0026quot; + argv[i]); i++; end End  Running this on Windows XP:\n\u0026gt; bgdi argv mies noot \u0026quot;mies noot\u0026quot; \u0026quot;'mies noot'\u0026quot; \u0026quot;\\\u0026quot;mies noot\\\u0026quot;\u0026quot; 'mies noot' Bytecode file: argv Number of arguments: 8 Argument 1: mies Argument 2: noot Argument 3: mies noot Argument 4: 'mies noot' Argument 5: \u0026quot;mies noot\u0026quot; Argument 6: 'mies Argument 7: noot'  Running this on Linux:\n$ bgdi argv mies noot \u0026quot;mies noot\u0026quot; \u0026quot;'mies noot'\u0026quot; \u0026quot;\\\u0026quot;mies noot\\\u0026quot;\u0026quot; 'mies noot' Bytecode file: argv Number of arguments: 7 Argument 1: mies Argument 2: noot Argument 3: mies noot Argument 4: 'mies noot' Argument 5: \u0026quot;mies noot\u0026quot; Argument 6: mies noot  Here you can see some interesting things:\ntext produces an argument word for each word (words are separated by spaces) \u0026ldquo;text\u0026rdquo; produces the argument text \u0026ldquo;\u0026rsquo;text\u0026rsquo;\u0026rdquo; produces the argument \u0026lsquo;text\u0026rsquo;. \u0026ldquo;\\\u0026ldquo;text\\\u0026rdquo;\u0026rdquo; produces the argument \u0026ldquo;text\u0026rdquo; \u0026lsquo;text\u0026rsquo; doesn\u0026rsquo;t combine multiple words into one argument on Windows, but it does on Linux.\nThe passing of arguments is totally unrelated to Bennu and is OS dependent. Usually the doubleqoutes (\u0026rdquo; \u0026ldquo;) work, but as you can see, the single quotes (\u0026rsquo; \u0026lsquo;) don\u0026rsquo;t always work to combine multiple words into one argument.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/argv/","title":""},{"contents":" Definition \u0026lt;datatype\u0026gt; \u0026lt;array name\u0026gt;[\u0026lt;upperlimit\u0026gt;] [= \u0026lt;values\u0026gt;]\nArrays are datatypes, consisting of a range of variables of the same type. The range is 0..upperlimit, meaning there are upperlimit+1 elements in the array.\nThe initializing values start at the first (0th) element and go up from there.\nExample Mutliple ints int lottery[9]; // an array of 10 ints  Use them like:\nlottery[0] = 1; lottery[5] = 35; lottery[1] = lottery[5];  Multiple types Consider, using Type:\nType _point; float x; float y; End _point point[2] = 1,2,// an array of 3 points at positions (1,2), (3,4) and (5,6) 3,4, 5,6;  Use them like:\npoint[0].x = 0; point[1].y = 54.2; point[2].x = point[0].x; point[1].x = point[2].y = 23.2;  Multiple structs See Struct.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/array/","title":""},{"contents":" Definition BYTE asc ( \u0026lt;STRING character\u0026gt; )\nReturns the ASCII value of the first character of the string character.\nParameters STRING character - The string of which the ASCII value of the first character will be returned.\nReturns BYTE : The ASCII value of the first character of the string character.\nExample Program asciis; Begin write(0,0, 0,0,asc(\u0026quot;A\u0026quot;)); write(0,0,10,0,asc(\u0026quot;CAT\u0026quot;)); Repeat frame; Until(key(_esc)) End  Used in example: write(), key()\nCategory:functions Category:strings Category:mod_string\n","permalink":"https://divhub.github.io/pixtudio-website/docs/asc/","title":""},{"contents":" category:variables category:predefined category:global variables category:mod_key\nUp to Global Variables\nDefinition INT ascii\nAscii is defined in the module mod_key and, in contrast to scan_code, it contains the last character typed on the keyboard instead of the last key. That means “A” and “a” will have the same scan_code, but different ascii value.\nExample import \u0026quot;mod_text\u0026quot; import \u0026quot;mod_key\u0026quot; import \u0026quot;mod_video\u0026quot; process main() begin set_mode(640,320); write( 0, 60, 10, 0, \u0026quot;Use lower and upper case characters to see the difference\u0026quot;); write( 0, 60, 20, 0, \u0026quot;between ascii and scan_code. (ESC to exit) \u0026quot;); write( 0, 60, 40, 0, \u0026quot;ascii: \u0026quot;); write_var( 0, 110, 40, 0, ascii); write( 0, 26, 50, 0, \u0026quot;scan_code: \u0026quot;); write_var( 0, 110, 50, 0, scan_code); while ( !key(_esc)) frame; end end  ","permalink":"https://divhub.github.io/pixtudio-website/docs/ascii/","title":""},{"contents":" Syntax FLOAT asin ( \u0026lt;FLOAT value\u0026gt; )\nDescription Returns the arcsine of a certain value.\nThis function performs an arcsine calculation on a certain value and returns an angle between and including -90000 and 90000 (-90-90º).\nParameters FLOAT value - The value to be performed an arcsine calculation on.\nReturns FLOAT : The arcsine result of the specified value, an angle between and including -90000 and 90000 (-90-90º).\nNotes The angle value returned by this function is in thousandths of degrees, as most angles within Bennu are.\nTo read about all aspects of trigonometry, you can visit Wikipedia\u0026rsquo;s Trigonometric function page.\nCategory:functions Category:math Category:mod_math\n","permalink":"https://divhub.github.io/pixtudio-website/docs/asin/","title":""},{"contents":" Syntax FLOAT atan ( \u0026lt;FLOAT value\u0026gt; )\nDescription Returns the arctangent of a certain value.\nThis function performs an arctangent calculation on a certain value and returns an angle between but not including -90000 and 90000 (-90-90º).\nParameters FLOAT value - The value to be performed an arctangent calculation on.\nReturns FLOAT : The arctangent result of the specified value, an angle between but not including -90000 and 90000 (-90-90º).\nNotes The angle value returned by this function is in thousandths of degrees, as most angles within Bennu are.\nTo read about all aspects of trigonometry, you can visit Wikipedia\u0026rsquo;s Trigonometric function page.\nCategory:functions Category:math Category:mod_math\n","permalink":"https://divhub.github.io/pixtudio-website/docs/atan/","title":""},{"contents":" Syntax FLOAT atan2 ( \u0026lt;FLOAT y\u0026gt; , \u0026lt;FLOAT x\u0026gt;)\nDescription Returns the arctangent of a certain value. It is computed as the arc tangent of y/x. The signs of the arguments are used to perform the calculation.\nThis function performs an arctangent calculation on a certain value and returns an angle between but not including -180000 and 180000 (-180-180º).\nParameters FLOAT y - The Y value to be performed an arctangent calculation on. FLOAT x - The X value to be performed an arctangent calculation on.\nReturns FLOAT : The arctangent result of the specified value, an angle between but not including -180000 and 180000 (-180-180º).\nNotes The angle value returned by this function is in thousandths of degrees, as most angles within Bennu are.\nSee also atan()\nTo read about all aspects of trigonometry, you can visit Wikipedia\u0026rsquo;s Trigonometric function page.\nWikipedia\u0026rsquo;s Atan2 page.\nCategory:functions Category:math Category:mod_math\n","permalink":"https://divhub.github.io/pixtudio-website/docs/atan2/","title":""},{"contents":" Definition FLOAT atof ( \u0026lt;STRING str\u0026gt; )\nReturns the float value of the number specified in a certain string.\nParameters STRING str - The string specifying a number of which the float value will be returned.\nReturns FLOAT : The float value of the number specified by the specified string.\nCategory:functions Category:strings Category:mod_string\n","permalink":"https://divhub.github.io/pixtudio-website/docs/atof/","title":""},{"contents":" Definition INT atoi ( \u0026lt;STRING str\u0026gt; )\nReturns the int value of the number specified in a certain string.\nParameters STRING str - The string specifying a number of which the int value will be returned.\nReturns INT : The int value of the number specified by the specified string.\nCategory:functions Category:strings Category:mod_string\n","permalink":"https://divhub.github.io/pixtudio-website/docs/atoi/","title":""},{"contents":" Description The background is a graphic, in the system file (fileID of 0) with a graphID equal to BACKGROUND.\nExamples in use:\n [[map_clear]](0,[[BACKGROUND]]);, to clear the background to black (same as screen_clear). [[drawing_map]](0,[[BACKGROUND]]);, to set drawing to the background.  ","permalink":"https://divhub.github.io/pixtudio-website/docs/background/","title":""},{"contents":" category:general\nBelow are explained the basic statements of Program and Process and where to declare all the types of variables. For prototyping see Declare.\nA list of basic statements:\n Program Process Function Declare Begin OnExit End Private Public Local Global Const  Basic statements Program example; Global // Start a global variables part of the program End Const // Start a constants part of the program End Local // Start a global variables part of the program End Private // Start a private variables part of the main process End Begin // Start the main code part of the main process proc1(); // create new instance of proc1 Loop frame; End OnExit // Start the exit code part of the main process End Global // Start a global variables part of the program End Const // Start a constants part of the program End Local // Start a global variables part of the program End Process proc1() Public // Start the public variables part of the process Private // Start the private variables part of the process Begin // Start the main code part of the process Loop frame; End OnExit // Start the exit code part of the process End Function int func1() Public // Start the public variables part of the function Private // Start the private variables part of the function Begin // Start the main code part of the function return 0; OnExit // Start the exit code part of the function End  Used in example: basic statements, loop, return, frame\nGlobal, constant, local and private parts of the program can be scattered through the code, between processes and functions. Sometimes the End can be left out, but it\u0026rsquo;s good practice to keep it in. When a variable or constant is declared, it\u0026rsquo;s only viewable or editable for statements beneath the declaration. For more info on that, see prototyping.\nNote that when Declare is used, the Public variables have to be declared in the Declare block and not in the process block.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/basic_statements/","title":""},{"contents":" Definition INT bdf_load ( \u0026lt;STRING filename\u0026gt;, [ \u0026lt;POINTER id\u0026gt;] )\nLoads a BDF font file into memory as a font.\nThe previous name load_bdf() is deprecated.\nParameters STRING filename - The filename of the bdf file that you wish to load (including extension and possible path). POINTER id - Optional parameter, for loading a font in the background.\nReturns INT : graphID\n-2 - Waiting for the file to be loaded, see notes. -1 - There was an error loading the file. \u0026gt;=0 - The graphID of the newly created font.\nthe following applies for versions prior rc282:\nINT : FontID\n-1 - Error: file does not exist. 0 - Filename could not be obtained from the specified string (doesn\u0026rsquo;t happen usually). \u0026gt;0 - The FontID.\nErrors Format not recognized - The format of the specified file could not be recognized.\nNotes The optional parameter id was introduced in version rc282 and allows you to load resources in the background. It used with the Offset operator. See example below:\n load_bdf(\u0026quot;archivo_gordo.bdf\u0026quot;, \u0026amp;idbdf); while(idbdf==-2) say(\u0026quot;Big File Loading ....\u0026quot;); frame; end if(idbdf==-1) say(\u0026quot;Something went wrong!!\u0026quot;); exit(); // o return end say(\u0026quot;Big file loaded ok!!\u0026quot;);  Category:functions Category:fonts Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/bdf_load/","title":""},{"contents":" category:reserved category:language category:basic statement\nUp to Basic Statements\nSyntax Begin\n:[ ]\n[ OnExit\n:[ ]\n] End\nDescription Begin is a reserved word to indicate the start of the code part of a program, process or function. The end is indicated by End. The OnExit statement can be used in between.\nExample Process Main Begin // Start the main code part of the main process proc1(); // create new instance of proc1 End Process proc1() Begin // Start the main code part of the process End Function int func1() Begin // Start the main code part of the function return 0; End  Used in example: end, process, function\n","permalink":"https://divhub.github.io/pixtudio-website/docs/begin/","title":""},{"contents":" Introduction BennuGD, a Fenix fork from Fenix 0.93, is an interpreted programming language aimed at making games. It is designed in such a way, the graphical, sound and threading systems are easier to use, which makes Bennu a powerful language, not only for beginners, but also for experienced programmers.\nThe BennuGD core is completely portable, it can be compiled for any platform, given there is a C compiler for it. The core contains the compiler, interpreter and runtime library. Bennu Modules use SDL for many of the basic functionality. Because of this, even the BennuGD modules are portable to many operating systems: Windows, Linux, GP2X Wiz, BeOS/Haiku, MacOS X, even consoles and handhelds like Dreamcast, GP2x or Wii. This makes it much fun to code in Bennu: your games can be played on your console, without modification!\nPorts To make a simple port of Bennu and the modules, all is needed is the source, SDL, SDL_mixer, autoconf and make. With those, it can be compiled to virtually any platform.\nCurrent official ports:\n Windows Linux GP2X Wiz Caanoo  Current unofficial ports:\n Nintendo Wii MacOS X (Intel Only) Haiku OS Open Pandora Playstation Portable Apple iOS (iPhone) Motorola Z6/EM30/E8/EM35/VE66  Ports being worked on:\n Android Dingoo Dingux Dreamcast Xbox Playstation 2 HTML 5 Bennu .NET (Windows Platforms)  See Also  Latest Bennu version Official website Download all Bennu versions  ","permalink":"https://divhub.github.io/pixtudio-website/docs/bennu/","title":""},{"contents":" The Bennu console is a handy debugging tool. Many commands can be entered in it, like process manipulation or variable manipulation. The current state of Globals, Constants, Locals, Publics, Privates can also be monitored. One can add text to it in the programcode by using the function say().\nTo use the debugger, you need import the debug module (mod_debug) in your source code, run in debug mode by compiling your program in bgdc.exe with the argument \u0026ldquo;-g\u0026rdquo;, and when you are running your application with the interpreter(bgdi.exe) you can activate it in-program with ALT+C.\nCommands Process Info INSTANCES List all running processes in a tree view. It shows what processes a processes called.\nGLOBALS List all global variables with their current values. Both predefined and user defined variables are listed.\nLOCALS  List all local variables of the specified process. The process can be specified by either its name or its processID. Both predefined and user defined variables are listed.\nPRIVATES  List all local variables of the specified process. The process can be specified by either its name or its processID.\nPUBLICS  List all local variables of the specified process. The process can be specified by either its name or its processID.\nDebugging Commands TRACE Execute the next instruction.\nBREAK List all set breakpoints.\nBREAK  Add a breakpoint on the execution of the specified process. The process can be specified by either its name or its processID.\nDELETE Delete a breakpoint on the execution of the specified process. The process can be specified by either its name or its processID.\nCONTINUE Continue the execution (close the console).\nDOFRAME Execute the next frame.\nMisc SHOW  Evaluate and show the specified expression.\nSTRINGS List all strings in memory and how many times they are used.\nVARS List all internal variables.\nFILES Displays the amount of files currently opened.\nQUIT Kill the program and exit.\nProcess Management See signals for further explanation about the following signaling commands.\nRUN  [] Start a process with optional arguments.\nKILL  Kill the specified process. The process can be specified by either its name or its processID.\nWAKEUP  Wake up the specified process. The process can be specified by either its name or its processID.\nSLEEP  Put the specified process to sleep. The process can be specified by either its name or its processID.\nFREEZE  Freeze the specified process. The process can be specified by either its name or its processID.\nKILLALL  If a processname is specified, kill all processes with that name; if a processID is specified, only kill that process.\nWAKEUPALL  If a processname is specified, wake up all processes with that name; if a processID is specified, only wake up that process.\nSLEEPALL  If a processname is specified, put all processes with that name to sleep; if a processID is specified, only put that process to sleep.\nFREEZEALL  If a processname is specified, freeze all processes with that name; if a processID is specified, only freeze that process.\nExpressions You can evaluate free expressions and see/alter the values of variables. ===== [= ]===== Return or alter a global variable. =====. [= ]===== If a processID is specified, the value of the local, private or public variable of that process is returned or altered. If a processName is specified, the process with that name and the lowest ID is assumed.\nExample Process Main() Begin Repeat frame; Until(key(_ESC)) End  Category:general Category:debugging\n","permalink":"https://divhub.github.io/pixtudio-website/docs/bennu_console/","title":""},{"contents":" (We will keep this page as it is right now, as the profiler does not exist in Bennu yet.)\nThe Bennu profiler is a handy debugging tool. It shows how much power is needed for certain systems of Bennu, most particularly the drawing and the interpreting.\nTo use the profiler,import the debug module (mod_debug) in your sorce code and compile it in bgdc.exe with the argument \u0026ldquo;-g\u0026rdquo;, and then show it in-program with ALT+P.\nShortcuts:\nALT-P - Show/hide the Bennu profiler ALT-R - Resets the profile history of the Bennu Profiler. ALT-S - Activate/Deactivate the Bennu Profiler.\nExample Process Main() Begin // To make sure the profiler is updated every frame restore_type = COMPLETE_RESTORE; A(); Loop frame; End End Process A() Begin Loop frame; End End  Used in example: restore_type, process, frame\nCategory:general Category:debugging\n","permalink":"https://divhub.github.io/pixtudio-website/docs/bennu_profiler/","title":""},{"contents":" This page contains info on the development (SubVersioN or SVN) versions of Bennu.\nSource repository \u0026amp; latest builds  SVN repository (checkout from https://bennugd.svn.sourceforge.net/svnroot/bennugd). Official builds are currently Release Candidates (you probably want these), you can download them here.  Changelog The Bennu developers usually keep track of their changes in the forums, in a developers diary topic. There are two topics, one in English and one in Spanish. As the main core developer SplinterGU and a big part of the community is Spanish this is the more extensively used topic:\n English Worklog Spanish Worklog  ","permalink":"https://divhub.github.io/pixtudio-website/docs/bennu_svn/","title":""},{"contents":" category:variables category:predefined category:local variables category:internal\nUp to Local Variables\nDefinition INT bigbro\nBigbro is a predefined local variable. Bigbro holds the ProcessID of the process/function that was immediately called before by the father of the current process/function. There are several other local variables which refer to the ProcessID of a related process:\n Father Son Smallbro  ","permalink":"https://divhub.github.io/pixtudio-website/docs/bigbro/","title":""},{"contents":"Bilge is an IRC chatroom filled with all sorts of people. Most of them are old and new Fenix/DIV programmers, but others drop by from time to time as well.\nFeel free to pop in at #bilge @ irc.blitzed.org.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/bilge/","title":""},{"contents":" Definition Bit flags are constants which each denotes a single unique case in one situation and can be combined to form different, unique cases. They are called bit flags, because when bits are used to denote a cases, we observe they are indeed single and unique and can be combined to form different unique combinations.\nBit flags are often used as integers:\nBit pattern - Integer value 0001 - 1 0010 - 2 0100 - 4 1000 - 8\nThese can be combined to form, for example:\nBit pattern - Integer value 1001 - 9 0110 - 6 1110 - 14 0101 - 5\nExample When we look at blit flags for example, we see the values:\nConstant - Value - Description B_HMIRROR - 1 - Blit the graph horizontally mirrored. B_VMIRROR - 2 - Blit the graph vertically mirrored. B_TRANSLUCENT - 4 - Blit the graph with half transparency. B_ALPHA - 8 - Blit the graph in some way. (What does this do exactly?) B_ABLEND - 16 - Blit the graph using additive blending (nice effect for fire). B_SBLEND - 32 - Blit the graph using subtractive blending (nice effect for ghosting). B_NOCOLORKEY - 128 - Blit the transparent parts of the graph as black.\nThese are all single unique cases and can be combined to form different unique cases. For example, when we want a translucent, horizontally mirrored blit operation with use of additive blending, we would do:\nB_HMIRROR | B_TRANSLUCENT | B_ABLEND 1 | 4 | 16 = 21  Because the bits are unique, the addition operator can also be used. But when we consider there would be a constant called B_HVMIRROR, which has the value B_HMIRROR|B_VMIRROR (3), the addition operator can\u0026rsquo;t be used all the time:\nB_HMIRROR | B_HVMIRROR == 1 | 3 == 3 B_HMIRROR + B_HVMIRROR == 1 + 3 == 4  In conclusion, use the bor operator when dealing with bit flags to be on the safe side.\nUsage Example Process main() Private unsigned byte options; Begin /* Manipulate bit flags */ // To set options, use = (the bits with 1's will be targeted) options = 01000001b; // To add options, use | (the bits with 1's will be targeted) options |= 00000001b; // To remove options, use \u0026amp; and ~ (the bits with 1's will be targeted) options \u0026amp;= ~00010000b; // same: options \u0026amp;= 11101111h (the bits with 0's will be targeted) // To switch options, use ^ (the bits with 1's will be targeted) options ^= 10000000b; /* Manipulate bit flags using the \u0026lt;\u0026lt; operator (these are equivalent to the last three) */ options|= 1\u0026lt;\u0026lt;0; // position 0 is now ON options\u0026amp;= ~(1\u0026lt;\u0026lt;4); // position 4 is now OFF options^= (1\u0026lt;\u0026lt;7); // position 7 is now SWITCHED /* Checking of bit flags */ // Check if a certain option is set (the bits with 1's will be checked) if((options\u0026amp;10000000b)==10000000b) end // Check if a certain option is not set (the bits with 1's will be checked) if((options\u0026amp;10000000b)==0) end // Check if multiple options are set (the bits with 1's will be checked) if((options\u0026amp;10000001b)==10000001b) end // Check if multiple options are not set (the bits with 1's will be checked) if((options\u0026amp;00000110b)==0) end // Check if at least one of multiple options is set (the bits with 1's will be checked) if((options\u0026amp;00000110b)!=0) end // Check if at least one of multiple options is not set (the bits with 1's will be checked) if((options\u0026amp;00000110b)!=00000110b) end /* Checking of bit flags using the \u0026lt;\u0026lt; operator */ // Check if a certain option is set if((options\u0026amp;(1\u0026lt;\u0026lt;7))==(1\u0026lt;\u0026lt;7)) // position 7 is ON end // Check if a certain option is not set if((options\u0026amp;(1\u0026lt;\u0026lt;7))==0) // position 7 is OFF end End  Used in example: Bitwise Operators\n","permalink":"https://divhub.github.io/pixtudio-website/docs/bit_flags/","title":""},{"contents":" Description A blend operation is the act of executing the blending of a graphic (source) with the pixels the graphic is drawn on (target) using a blend table.\nThis is done in two ways:\n The blendop is performed explicitly using blendop_apply(), modifying the graphic. The blendop is assigned to a graphic and performed implicitly when that graphic is drawn. This method is not available for modes lower than 16bit.  Blendops are not supported in 32bit mode.\nCategory:blendops\n","permalink":"https://divhub.github.io/pixtudio-website/docs/blend_operation/","title":""},{"contents":"Blitting is the operation of drawing one graph onto another, using so-called bit blitting operations (see Wikipedia on bit blitting).\nMap functions like put() and map_xputnp() are examples of functions using blit operations.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/blit/","title":""},{"contents":" Definition Blit flags are bit flags which can be passed to some map functions, to specify a certain effect when blitting a graphic. These functions are:\n xput() map_xput() map_xputnp()  They can also be used to specify a certain effect for the blitting of the graphic of a process, by assigning blit flags to its local variable flags.\nList Constant - Value - Description B_HMIRROR - 1 - Blit the graph horizontally mirrored. B_VMIRROR - 2 - Blit the graph vertically mirrored. B_TRANSLUCENT - 4 - Blit the graph with half transparency. B_ALPHA - 8 - Blit the graph in some way. (What does this do exactly?) B_ABLEND - 16 - Blit the graph using additive blending (nice effect for fire). B_SBLEND - 32 - Blit the graph using subtractive blending (nice effect for ghosting). B_NOCOLORKEY - 128 - Blit the transparent parts of the graph as black (color 0).\nCategory:constantcategories\n","permalink":"https://divhub.github.io/pixtudio-website/docs/blit_flags/","title":""},{"contents":" Definition INT blur ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; , \u0026lt;BYTE mode\u0026gt; )\nThis will make the specified graphic blurry by using a specified mode. It manipulates the graphic directly.\nOnly 16bit graphics are supported on 16bit video mode.\nParameters INT fileID - The fileID of the file that holds the graphics. INT graphID - The graphID of the graphic to convert. BYTE mode - The blur mode that is applied to the graphic (see below).\nReturns INT\n0 - Invalid graphic or non 16bit graphic used. 1 - Success.\nBlur modes Constant - Value - Description BLUR_NORMAL - 0 - single pixel: considers pixels located to the left and above of each pixel. BLUR_3X3 - 1 - 3x3: considers all 8 adjacent pixels. BLUR_5X5 - 2 - 5x5: considers the 24 pixels that surrounds each pixel. BLUR_5X5_MAP - 3 - 5x5 with additional map: Just as the previous one but using a temporary map.\nExamples Category:functions Category:graphical effects Category:mod_effects\n","permalink":"https://divhub.github.io/pixtudio-website/docs/blur/","title":""},{"contents":" Description Blur modes are used to specify the mode of blurring in the blur().\nList Constant - Value - Description BLUR_NORMAL - 0 - single pixel: considers pixels located to the left and above of each pixel. BLUR_3X3 - 1 - 3x3: considers all 8 adjacent pixels. BLUR_5X5 - 2 - 5x5: considers the 24 pixels that surrounds each pixel. BLUR_5X5_MAP - 3 - 5x5 with additional map: Just as the previous one but using a temporary map.\nExamples Category:constantcategories Category:mod_effects\n","permalink":"https://divhub.github.io/pixtudio-website/docs/blur_modes/","title":""},{"contents":" Definition BYTE\nBytes are whole numbers ranging from 0 to 2^8-1 ( 0 to 255 ). This is because a byte uses 8 bits (1 byte) to denote its value. A byte is the smallest datatype directly accessible in nowadays memory.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/byte/","title":""},{"contents":" category:variables category:predefined category:local variables category:libscroll category:librender\nUp to Local Variables\nDefinition The cnumber is variable that is used when there\u0026rsquo;s more then one scroll or Mode7 window active, i.e. in a splitscreen configuration with two or more scroll or mode7 windows.\nThe cnumber indicates in wich window(s) the process is visible. It is only necessary for processes that are intended to visible in a scroll or mode7 window. The default value is 0, wich means that the process is visible in all scroll or mode7 windows. Up to 10 scroll or mode7 windows can be defined, wich are numbered from 0 to 9, wich are enumerated by the predefined constants C_0, C_1, C_2, C_3, C_4, C_5, C_6, C_7, C_8 and C_9.\nThe cnumbers can be added, and the sum of these indicate the visibility. If there, are for instance 4 scroll windows active, (numbered 0, 1, 2, and 3) and a specific process should only be visible in windows 0 and 2, then you should use:\ncnumber = C_0 + C2; // this is 1+4  It is possible to change the value of the cnumber in runtime, wich can be handy in certain situations.\nLook for more information about scrolls and mode7 in the articles of the Start_scroll() and Start_mode7() functions.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/c_number/","title":""},{"contents":" Syntax call \u0026lt;label\u0026gt; ;\nDescription The call command jumps to the given label inside a function or process until it comes across a return statement. When this happens, it jumps back to call statement and resumes after it.\nExample import \u0026quot;mod_say\u0026quot; Process Main() Begin say(my_function(1)); End Function my_function(int value) Private int ret; Begin Jmp real_begin; jumping: ret = 300; return; real_begin: ret = 100; if(value == 1) Call jumping; end ret += 200; return ret; End  Used in example: process, function, jmp, call, return\nThe output of this example is 500, when value is 1. This example show 500 because the input value is a one and it causes that goes to the jumping label inserting a 300 and adding a 200 after.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/call/","title":""},{"contents":" Syntax VOID POINTER calloc (\u0026lt;INT num\u0026gt; ,\u0026lt;INT size\u0026gt;)\nDescription Allocates (creates) a block of memory of a certain size. Calloc is slightly different from alloc, as it is more natively suited for creating arrays. It also automatically initialises the data with zeros, so that the use of memset() or memseti() can be omitted. Returns a pointer to the newly allocating memory block, or NULL on failure.\nAlso called mem_calloc().\nParameters INT num - The amount of elements to be created in ints. INT size - The size of the to be allocated memory in bytes.\nReturns VOID POINTER : Pointer to the first element of the allocated memory block.\nNULL - There was are an error allocating the memory, like insufficient memory available. - Pointer to the first element of the allocated memory block.\nExample // Some general remarks with manual memory managment, ALWAYS free data after use, and test if an // allocation was successfull with IF (p_array==NULL). When one of these memory allocation // functions returns a NULL, the allocation was NOT sucessfull, and any kind of unpredicatable things // can happen. With manual memory managment, you'll have to really know what you're doing, as the slightest // mistake can cause crashes and unpredicatable behaviour, wich is one of the dangers with using pointers. // import modules IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_mem\u0026quot;; /* calloc(int size,type); returns: void pointer purpose: create a block of memory, of a certain size, the returned pointer indicates the start adress of this block. */ GLOBAL int pointer p_array; // 10 elments, created with calloc() int elements=10; // initial array size int count; // general purpose loop counter PROCESS main(); BEGIN // Now let's use calloc to create an array, but calloc is a bit smarter then alloc. It's more suited to array's and // it even initializes all the data to 0 for you, so that you can omit the memset() function. In this case I // kept memseti() in there, but you can omit it when using calloc(). But with alloc() you need to use it! // Note the small difference between alloc() and calloc(). //p_array=alloc(elements*sizeof(int)); p_array=calloc(elements,sizeof(int)); // 10 * 4 bytes (the size of an int) // check if the allocation succeeded IF (p_array==NULL) // allocation failed say(\u0026quot;allocation failed!! p_array=\u0026quot;+p_array); ELSE // allocation succeeded // set the value's to zero /* memseti(p_array ,0,elements); // not need for calloc(); */ say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); // print the array FOR (count=0; count\u0026lt;elements; count+=1) say(\u0026quot;p_array[\u0026quot;+count+\u0026quot;]=\u0026quot;+p_array[count]); END say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;the size of the array is \u0026quot;+(elements*sizeof(int))+\u0026quot; bytes\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); END ONEXIT // Free the used memory say(\u0026quot;freeing old memory........\u0026quot;); say(\u0026quot;p_array...\u0026quot;); free(p_array); say(\u0026quot;ok\u0026quot;); END  Used in example: alloc(), memset(), memsetw(), memseti(), sizeof(), say(), free(), OnExit, pointer, sizeof\nCategory:functions Category:memory Category:mod_mem\n","permalink":"https://divhub.github.io/pixtudio-website/docs/calloc/","title":""},{"contents":" Definition STRING cd ( [\u0026lt;STRING folder\u0026gt;] )\nSets the current path of execution if folder was specified and returns it.\nNote that it is highly recommended to use chdir() for changing the current path of execution, as cd() will make Bennu crash when a folder is specified and the returned path of execution is used in the Bennu program. Just using cd() without a folder is not a problem.\nParameters STRING folder - The folder to be entered from the current path of execution or a new path of execution.\nReturns STRING : The current path of execution.\nExample import \u0026quot;mod_dir\u0026quot; import \u0026quot;mod_say\u0026quot; import \u0026quot;mod_key\u0026quot; Process Main() Begin say(cd()); say(chdir(\u0026quot;..\u0026quot;)); say(cd()); Repeat frame; Until(key(_ESC)) End  Used in example: cd(), chdir(), say(), key()\nCategory:functions Category:files Category:mod_dir\n","permalink":"https://divhub.github.io/pixtudio-website/docs/cd/","title":""},{"contents":" Definition INT center_set ( \u0026lt;INT FileID\u0026gt; , \u0026lt;INT GraphID\u0026gt; , \u0026lt;INT x\u0026gt; , \u0026lt;INT y\u0026gt;)\nAllows you to change the center of a graphic.\nThis function changes a graphic\u0026rsquo;s center pixel, which is the pixel that is located on screen at the graph\u0026rsquo;s x and y coordinates. So changing this will influence the position on the screen.\nThe previous name set_center() is deprecated.\nParameters INT FileID - The FileID of the file containing the graphic INT GraphID - The GraphID of the graphic to change the center of. INT x - The new horizontal center coordinate of the graphic. INT y - The new vertical center coordinate of the graphic.\nReturns INT : Successrate\n-1 - Specified graphic is invalid. 1 - The center was set successfully.\nNotes You set the position of control point 0 in the graphic. This control point acts as the graphic\u0026rsquo;s coordinate on screen. For example, if a graphic\u0026rsquo;s center is set to 0,0 , then the upper left pixel of the graphic will be placed on screen at the graphic\u0026rsquo;s coordinates. If no center is set, by default control point 0 is set to the graphics true geometric center.\nAnother key feature is that the graphic will rotate around its center, as set by this function, and any horizontal or vertical mirrors (set with flags) will flip at this point.\nWhen a graphic is used as a mouse pointer, its center point is used for the mouse tip. Most mouse cursors in Operating Systems have a mouse with the tip in the upper left of the image. Therefore, for a standard mouse pointer in Bennu, you will have to set the center at 0,0 to enable mouse accuracy.\nExample import \u0026quot;mod_map\u0026quot; import \u0026quot;mod_text\u0026quot; import \u0026quot;mod_key\u0026quot; Process Main() Begin graph=png_load(\u0026quot;set_center.png\u0026quot;); //Loads a 128x128 image as the graphic x=160; y=100; //Places the graphic in the centre of the screen write(0,0,0,0,\u0026quot;Press [1] to set center to 0,0\u0026quot;); write(0,0,0,10,\u0026quot;Press [2] to set center to 64,64\u0026quot;); Loop if(key(_1)) center_set(0,graph,0,0); end if(key(_2)) center_set(0,graph,64,64); end angle+=100; //Rotates the graphic constantly frame; End End  Used in example: graph, png_load(), key(), write(), center_set()\nFile(s) used in example: set_center.png\nCategory:functions Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/center_set/","title":""},{"contents":" This page is aimed to contain a gathering of all information about the changes to Bennu in the different releases. Information about what exactly has changed is spread out over several sources making some new features and functions go unnoticed. These features should be in this wiki but as the updates to this wiki are rather sparse it\u0026rsquo;s probably a good idea to have the changes made at least somewhere written down neatly.\nInformation is retrieved from the Spanish and English worklog topics on the Bennu forums, as well as from the commit messages in the SVN system.\nState of this page This page contains the information shared by SplinterGU in the English worklog topic and some information from the Spanish topic. The Spanish topic is huge however, and contains a lot of talk between devs and users. Filtering out the useful info will take some time. The first WIP to get it\u0026rsquo;s own changelog is WIP14, which means in the Spanish topic page 21 is the page to start. I also have yet to create links.\nBennu\u0026rsquo;s early days On the 16th of April 2008, SplinterGU reports work has begun on Bennu: The first big development is creating a separation between the bare interpreter/compiler and the functionality with which they can be extended. The core will no longer contain code that depends on peripherals like a keyboard and mouse.\nThe support for Fenix\u0026rsquo; fgc, fbm and fpl file formats is also quickly dropped in favor of good old DIVs FPG, MAP and PAL files. The never fully finished support for animated graphics is also dropped as its effect is easy to replicate in code.\nThe changelog starts at WIP14, this is the one where the English worklog topic starts. In the first WIPs a lot of issues were straightened out that arose while breaking up the big chunk of code that was Fenix into a more elegant modular structure. Lots of general bugs were squashed and the rendering system was fixed after not being usable in the earlier WIPs.\nWIP 14 Released: October 18th, 2008\nCore\n args fix, now argc (argument count) say count of argv\u0026hellip; and argv[0] is dcbname in not stub version, and executable  name in stub version.\nModules\n Several casts added Add some includes Indent Some pointers size fix Remove unused vars Fix in use of grlib_destroy when error creation. Somes casts in palette module Linux port of libvideo Load map functions return 0 on fail Split MAGIC used in FPG/MAP/PAL to MAGIC of 7 bytes and 1 byte for version  WIP 15a Released: October 26th, 2008\nCore\n Linux Port (need tested) Prohibit unload font 0 Fix controls points + mirrors + angle Check if graph exist on gr_save_png Fix on 32 bits collision Fix on 32 bits blits  Modules\n New set_window_pos, get_window_pos and get_window_size functions get_window_size now makes a difference between window size and client area get_desktop_size added mod_debug added! Some debug fixes  SVN r22 Released: Februari 4th, 2009 (This was the first binary release from SVN)\nCore\n Add core\u0026rsquo;s functions bgdrtm_entry and bgdrtm_exit to bgdrtm\u0026hellip; Now exit code can be return at finish execution of bgdi  Modules\n Now division by zero is allowed in float expressions, new functions are added:  int isinf(float x); int isnan(float x); int finite(float x);  Ternary condition fixed\u0026hellip; improved speed in ternary condition when expression is constant. Lib windowmanager(WM) now doesn\u0026rsquo;t exit when close button is clicked, only sets exit_status to true exit(\u0026hellip;) functions now fixed, and use the params  SVN r28 Released: March 12th, 2009\nCore\nModules\n Fixed Translucent tables in 8 bits Fixed blend operations in 8 bits Fixed Translucent+Blend in 8 bits  SVN r30 Released: March 14th, 2009\nCore\n New string_ptoa more efficient and same result in different SO. Check constants already defined as variable Fix variant arg for pointer vars Fix unsigned comparations  Modules\n 32 bits drawing alpha support (alpha-pixel and drawing_alpha) speed up some drawing functions write_var pointer vars support  RC? (May 11, 2009) Released: May 11th, 2009\nCore\n New instances system, hash on priority, type. Speed up improved on iterate instances. Instances now are limited to 65536 running at same time Instances dirty list by change on priority is removed. Collision, get_id, signal,\u0026hellip; speed up improved by use of new instance system and other. Compiler parse number is fixed Several casts are added in code Several sizeof are added in code libvideo now start in 32 bits as default  Modules\n get_screen now return graphic without control point 0, (centered) speed up improved on show debug info debug console parse number is fixed debug console color tags fixed  RC11, r131 Released: ?\nCore ? Modules ?\nRC18, r181 Released: October 25th, 2010\nCore\nModules\nRC20, r? Released: ?\nCore\n char[] initialization fix Full arrays copy support added Better error messages Multiple sources can be compiled from command line (like #include) Video blitter crash fix Optimize memory used for strings in compilation Fix dcb version detection Several improvements in the core Compilation warnings now are disabled by default New lib system, now can be possible build dcl libraries.  Modules\n glyph_set fix New fonts functions, new_fnt or fnt_new. Added 1bpp png support (save/load) Better debug info messages Fix max sources files in debug information (before 256, now 4093)  To be processed: mod_debug Debugger\u0026rsquo;s new appearance(to be moved to the mod_debug article):\n New characters added to debug\u0026rsquo;s system font New debug\u0026rsquo;s functions: breakall, breakalltypes, deleteall, deletealltypes, go, nextframe, nextproc. Process list in brief mode Process browse window, by id or by type, allowing to set/remove breakpoints, inspect his variables, etc\u0026hellip; Palete fix on 8 bits fpg save Mirror fix on angle = 0 Several module\u0026rsquo;s dependencies added SDL_Initializations on some modules Debug info add at loading modules in runtime\u0026hellip; English messages in compiler  To be processed: FNT_NEW to be added syntax:\nFNT_NEW (CHARSET, DEPTH)\nFNT_NEW (FILE, GRAPH, CHARSET, WITDH, HEIGHT, FIRST, LAST, FLAGS)\nwhere CHARSET can be:\nCHARSET_ISO8859\nCHARSET_CP850\nwhere flags can be:\nNFB_VARIABLEWIDTH\nNFB_FIXEDWIDTH\nThe most sexy function is the last one FNT_NEW (FILE, GRAPH, CHARSET, WITDH, HEIGHT, FIRST, LAST, FLAGS), this function allow us create font from maps loaded in memory.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/changelog/","title":""},{"contents":" Definition INT chdir ( \u0026lt;STRING directoryname\u0026gt; )\nSets the current path of execution.\nParameters STRING directoryname - The name of the directory to be entered from the current path of execution or a new path of execution.\nReturns INT : Success\n0 - Setting of current path of execution succeeded. !0 - Setting of current path of execution failed.\nExample import \u0026quot;mod_dir\u0026quot; import \u0026quot;mod_say\u0026quot; import \u0026quot;mod_key\u0026quot; Process Main() Begin say(CD()); ChDir(\u0026quot;..\u0026quot;); say(CD()); Repeat frame; Until(key(_ESC)) End  Used in example: cd(), chdir(), say(), key()\nCategory:functions Category:files Category:mod_dir\n","permalink":"https://divhub.github.io/pixtudio-website/docs/chdir/","title":""},{"contents":" Definition STRING chr ( \u0026lt;BYTE ASCIIvalue\u0026gt; )\nReturns the character associated with ASCIIvalue.\nParameters BYTE ASCIIvalue - The ASCII value of which the character is wanted.\nReturns STRING : The character associated with ASCIIvalue.\nExample Program chars; Begin write(0,0, 0,0,chr(65)); write(0,0,10,0,chr(67)); Repeat frame; Until(key(_esc)) End  Used in example: write(), key()\nCategory:functions Category:strings Category:mod_string\n","permalink":"https://divhub.github.io/pixtudio-website/docs/chr/","title":""},{"contents":" Syntax  Clone \u0026lt;sentences\u0026gt;\n  End\nDescription The clone command creates a copy of the actual process which is called a \u0026ldquo;child process.\u0026rdquo; The original process is then called the \u0026ldquo;parent process\u0026rdquo;.\nOnly the child process will run the sentences between the keyword CLONE and the keyword END.\nExample import \u0026quot;mod_key\u0026quot;; import \u0026quot;mod_map\u0026quot;; import \u0026quot;mod_video\u0026quot;; import \u0026quot;mod_proc\u0026quot;; Process Main() Begin squares(); repeat frame; until(key(_ESC)); let_me_alone(); End Process squares() Private int advance; Begin graph = map_new(5,5,16); map_clear(0,graph,rgb(255,0,255)); advance = 1; clone graph = map_clone( 0, graph ); map_clear(0,graph,rgb(255,255,255)); advance = 2; end loop x += advance; frame; end map_unload(0,graph); End  Used in example: key(), map_new(), map_clear(), rgb(), map_unload() This example shows two squares. One is the child process, that is the white, and the other is the parent process.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/clone/","title":""},{"contents":" Definition INT collision ( \u0026lt;INT processID|processTypeID\u0026gt; )\nChecks if a process collided with the process calling Collision().\nWhen a processTypeID is specified, there could be multiple fitting collisions. In this case, collision() returns a processID on each subsequent call, until it returns 0. This can be reset by use of the frame; statement, and in such case, frame(0); can be handy.\nParameters INT processID|processTypeID - The ProcessID of the process or the ProcessTypeID of the type of processes to be checked.\nReturns INT : The ID of the collided process.\n0 - No collision \u0026gt;0 - The processID of the process colliding with the current process\nExample Process SpaceShip( int file , int graph , int x , int y , int angle , int maxspeed , int maxturnspeed ) Private int speed; int collisionID; string text; Begin write_string(0,0,0,0,\u0026amp;text); Loop // Handle movement speed+=key(_up)*(speed\u0026lt;maxspeed)-key(_down)*(speed\u0026gt;-maxspeed); angle+=(key(_left)-key(_right))*maxturnspeed; advance(speed); // Handle collision if( (collisionID = collision(type main))) text = \u0026quot;collision with: \u0026quot; + collisionID; else text = \u0026quot;no collision\u0026quot;; end frame; End End Process Main() Private int map; Begin // Create the graph for the ship map = new_map(20,20,8); map_clear(0,map,rgb(0,255,255)); // Create the graph for the Main process graph = new_map(50,50,8); map_clear(0,graph,rgb(255,255,0)); // Position the main process and create the ship x = y = z = 100; SpaceShip(0,map,100,100,0,20,5000); Repeat frame; Until(key(_ESC)) let_me_alone(); End  Used in example: write_string(), key(), collision(), new_map(), map_clear(), advance(), let_me_alone(), graph, type\nCategory:functions Category:processinteraction Category:mod_grproc\n","permalink":"https://divhub.github.io/pixtudio-website/docs/collision/","title":""},{"contents":" Definition INT collision_box ( \u0026lt;INT processID|processTypeID\u0026gt; )\nChecks if a process collided with the process calling Collision_box().\nWhen a processTypeID is specified, there could be multiple fitting collisions. In this case, collision_box() returns a processID on each subsequent call, until it returns 0. This can be reset by use of the frame; statement, and in such case, frame(0); can be handy.\nThe diference between collision_box and collision is that collision_box only checks the distance with the edges of the processes, on the other side collision() check pixel by pixel between these processes. Consequently, collision_box() is faster, but is more accurate collision().\nParameters INT processID|processTypeID - The ProcessID of the process or the ProcessTypeID of the type of processes to be checked.\nReturns INT : The ID of the collided process.\n0 - No collision \u0026gt;0 - The processID of the process colliding with the current process\nExample Process SpaceShip( int file , int graph , int x , int y , int angle , int maxspeed , int maxturnspeed ) Private int speed; int collisionID; string text; Begin write_string(0,0,0,0,\u0026amp;text); Loop // Handle movement speed+=key(_up)*(speed\u0026lt;maxspeed)-key(_down)*(speed\u0026gt;-maxspeed); angle+=(key(_left)-key(_right))*maxturnspeed; advance(speed); // Handle collision_box if( (collisionID = collision_box(type main))) text = \u0026quot;collision with: \u0026quot; + collisionID; else text = \u0026quot;no collision\u0026quot;; end frame; End End Process Main() Private int map; Begin // Create the graph for the ship map = new_map(20,20,8); map_clear(0,map,rgb(0,255,255)); // Create the graph for the Main process graph = new_map(50,50,8); map_clear(0,graph,rgb(255,255,0)); // Position the main process and create the ship x = y = z = 100; SpaceShip(0,map,100,100,0,20,5000); Repeat frame; Until(key(_ESC)) let_me_alone(); End  Used in example: write_string(), key(), collision_box(), new_map(), map_clear(), advance(), let_me_alone(), graph, type\nCategory:functions Category:processinteraction Category:mod_grproc\n","permalink":"https://divhub.github.io/pixtudio-website/docs/collision_box/","title":""},{"contents":" Definition INT collision_circle ( \u0026lt;INT processID|processTypeID\u0026gt; )\nChecks if a process collided with the process calling Collision_circle().\nWhen a processTypeID is specified, there could be multiple fitting collisions. In this case, collision_cirlce() returns a processID on each subsequent call, until it returns 0. This can be reset by use of the frame; statement, and in such case, frame(0); can be handy.\nThe diference between collision_circle and collision is that collision_circle only checks the distance with a circle in the edges of the processes, on the other side collision() check pixel by pixel between these processes. Consequently, collision_circle() is faster, but less accurate than collision().\nParameters INT processID|processTypeID - The ProcessID of the process or the ProcessTypeID of the type of processes to be checked.\nReturns INT : The ID of the collided process.\n0 - No collision \u0026gt;0 - The processID of the process colliding with the current process\nExample Process SpaceShip( int file , int graph , int x , int y , int angle , int maxspeed , int maxturnspeed ) Private int speed; int collisionID; string text; Begin write_string(0,0,0,0,\u0026amp;text); Loop // Handle movement speed+=key(_up)*(speed\u0026lt;maxspeed)-key(_down)*(speed\u0026gt;-maxspeed); angle+=(key(_left)-key(_right))*maxturnspeed; advance(speed); // Handle collision_box if( (collisionID = collision_circle(type main))) text = \u0026quot;collision with: \u0026quot; + collisionID; else text = \u0026quot;no collision\u0026quot;; end frame; End End Process Main() Private int map; Begin // Create the graph for the ship map = new_map(20,20,8); map_clear(0,map,rgb(0,255,255)); // Create the graph for the Main process graph = new_map(50,50,8); map_clear(0,graph,rgb(255,255,0)); // Position the main process and create the ship x = y = z = 100; SpaceShip(0,map,100,100,0,20,5000); Repeat frame; Until(key(_ESC)) let_me_alone(); End  Used in example: write_string(), key(), collision_circle(), new_map(), map_clear(), advance(), let_me_alone(), graph, type\nCategory:functions Category:processinteraction Category:mod_grproc\n","permalink":"https://divhub.github.io/pixtudio-website/docs/collision_circle/","title":""},{"contents":" Description Colors are widely used in Fenix/Bennu. They are used for example in text functions.\nIn 8 bit color mode, the color corresponds with the palette index (0..255); in 16 bit color mode the color corresponds with an RGB value (0..65535): 5 bits for red, 6 bits for green and 5 bits for blue. In 32bit mode the code is 0xRRGGBBAA, two letters meaning one byte: 8 bits for each component.\nThe RGB(A) values of a color can be obtained with get_rgb() and get_rgba().\nTransparency Note that in many cases the color 0 means transparent! Consider the difference between:\n map_clear(file,graph,0); and map_clear(file,graph,rgb(0,0,0)).  In the first case, the graphic (file,graph) will be made fully transparent. In the second case, the graphic will be made the blackest black Bennu can muster, given the current color depth. In 8bit mode, both will be made transparent.\nExample This is a test program to show when a color is black or transparent:\nimport \u0026quot;mod_video\u0026quot; import \u0026quot;mod_map\u0026quot; import \u0026quot;mod_key\u0026quot; import \u0026quot;mod_proc\u0026quot; Const DEPTH = 32; End Process Main() Private int map_trans; int map_black; Begin set_mode(320,200,DEPTH); map_trans = new_map(100,100,DEPTH); map_clear(0,map_trans,0); map_black = new_map(100,100,DEPTH); map_clear(0,map_black,rgb(0,0,0)); map_clear(0,BACKGROUND,rgb(50,50,50)); g(120,100,0,map_trans); g(200,100,0,map_black); Repeat frame; Until(key(_ESC)) let_me_alone(); End Process g(int x, int y, int file, int graph) Begin Loop frame; End End  Used in example: set_mode(), map_clear(), rgb(), new_map(), let_me_alone()\nSee also  rgb() rgba()  ","permalink":"https://divhub.github.io/pixtudio-website/docs/color/","title":""},{"contents":" Definition Color depths are used to specify the color depth of the screen, by passing one of them to the function set_mode() as the depth parameter.\nSee also graph_modes.\nList Constant - Value - Description MODE_8BITS - 8 - Use a color depth of 8bit. Also called MODE_8BPP. MODE_16BITS - 16 - Use a color depth of 16bit. Also called MODE_16BPP. MODE_32BITS - 32 - Use a color depth of 32bit. Also called MODE_32BPP.\nCategory:constantcategories\n","permalink":"https://divhub.github.io/pixtudio-website/docs/color_depths/","title":""},{"contents":" Syntax INT color_find ( \u0026lt;BYTE red\u0026gt; , \u0026lt;BYTE green\u0026gt; , \u0026lt;BYTE blue\u0026gt; )\nDescription Match an RGB value to a particular palette index. This is usefull in 8 bit mode.\nThe previous name find_color() is deprecated.\nParameters BYTE red - Level of red in the desired color from 0 to 255. BYTE green - Level of green in the desired color from 0 to 255. BYTE blue - Level of blue in the desired color from 0 to 255.\nReturns INT : Returns the palette inxed of the color that corresponds with the rgb combination.\nExample IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_key\u0026quot;; IMPORT \u0026quot;mod_map\u0026quot;; IMPORT \u0026quot;mod_video\u0026quot;; IMPORT \u0026quot;mod_wm\u0026quot;; IMPORT \u0026quot;mod_draw\u0026quot;; IMPORT \u0026quot;mod_screen\u0026quot;; IMPORT \u0026quot;mod_text\u0026quot;; GLOBAL int map_id; // id code of the map to load int status; // status for debugging PROCESS main(); BEGIN set_mode(320,200,32); // load the map map_id=load_map(\u0026quot;3COCHE.MAP\u0026quot;); status=color_find(0,0,0); say(\u0026quot;color: \u0026quot;+status); status=color_find(0,252,0); say(\u0026quot;color: \u0026quot;+status); status=color_find(0,67,0); say(\u0026quot;color: \u0026quot;+status); status=color_find(0,243,0); say(\u0026quot;color: \u0026quot;+status); status=color_find(0,10,0); say(\u0026quot;color: \u0026quot;+status); status=color_find(255,252,0); say(\u0026quot;color: \u0026quot;+status); status=color_find(100,252,100); say(\u0026quot;color: \u0026quot;+status); END  Category:functions Category:palettes Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/color_find/","title":""},{"contents":"BennuGD ignores this 576 set of bytes. But Are 576 bytes to save 16 color gamuts (sutsets of colors) useful to quickly paint. Each color gamuts is composed by the next information\nName Size (Bytes) Description\nNumber of colours 1 Number of colours that will compose this color gamut. Only support 8,16 and 32 values.\nMode 1 Sais how will be stored the color gamut.\n `0 - Direct pixel: You select the first color gamut in the palette, and the next colors gamut will be used sequencialy to this.`\\ `1 - Editable each color: You need select each color gamut in the palette.`\\ `2 - Editable each 2 colours: You need select each 2 colours gamut in the palette, the colors of middle will be search automatically in the palete.`\\ `4 - Editable each 4 colours: Similar to each 2 colours but each 4 colors.`\\ `48- Editable each 8 colours: Similar to each 2 colours but each 8 colors.`  Not Editable 1 Sais if this gamut can be editable or dont.\nUnused 1 1 unused byte\nColours Gamut 32 Each palete index that use this gamut.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/color_gamuts/","title":""},{"contents":" Syntax Const constants End  Description Const is a reserved word used to initiate the declaration of constants. Terminating the declaration block with an End is needed when the Const statement is not used in conjunction with the main code of the Program.\nWhen declaring constants inside this construct, it\u0026rsquo;s now allowed to explicitly name the type of the constant, i.e. you only have to assign the constant the value you want.\nFor a list of predefined constants, see this page.\nExample Const // Declare constants here myInt = 4; myString = \u0026quot;hello\u0026quot;; End Process Main() Begin End Const // Declare constants here End  ","permalink":"https://divhub.github.io/pixtudio-website/docs/const/","title":""},{"contents":" A constant is a container containing a value. This value cannot be changed apart from initialization, hence the name constant, as opposed to a variable of which the value can vary. A constant can be of any datatype and can contain a value according to its datatype. For example, an integer has whole numbers between -2\\^31 (-2147483648) and +2\\^31-1 (2147483647) (e.g. 23) , a float has a floating point number (e.g. 2.674) and a string has a series of characters (e.g. \u0026ldquo;Hello World!\u0026rdquo;).\nThere is a number of predefined constants. These variables are predefined, which means they exist without the programmer making them. They can be useful in a some functions or when assigning them to some global variables.\nSee Also  A list of predefined constants Variable  Category:General\n","permalink":"https://divhub.github.io/pixtudio-website/docs/constant/","title":""},{"contents":"Up to Index\nList of Constants\nHere\u0026rsquo;s a list of constant categories used in Bennu. When you\u0026rsquo;re using an older version of Bennu and it doesn\u0026rsquo;t recognize the constant, just use the corresponding value, which is listed with the constant. This is not guarenteed to work, because functionality could have been added in a later version than you are using. It is advised to always use the latest version of Bennu.\n category=constantcategories mode=userformat listseparators = ,\\n* %TITLE%,, redirects = include columns = 2 resultsfooter = \\n%PAGES% constant categories\\n \n","permalink":"https://divhub.github.io/pixtudio-website/docs/constantcategories/","title":""},{"contents":"Up to Index\nConstant Categories\nList of all constants.\n category=constants mode=userformat columns = 4 listseparators = ,\\n* %TITLE%,, redirects = include replaceintitle = /\\\\? /,_ \n","permalink":"https://divhub.github.io/pixtudio-website/docs/constants/","title":""},{"contents":"category:general\nControl flow statements are statements which influence the control flow (the order in which statements are executed) of the program.\n If, ElseIf, Else, End While, End Repeat, Until For, End From, To, Step, End Loop, End Switch, Case, Default, End  ","permalink":"https://divhub.github.io/pixtudio-website/docs/control_flow_statements/","title":""},{"contents":" Definition Native bennu map files have a special propetry, wich is an Array of controlpoints. A controlpoint has an X and Y coordinate, and a number. A map can have up to 1000 controlpoints, ranging from 0 to 999. Controlpoint 0 is always the center of the bitmap by default, but this can be changed with the Center_set() function.\nThe controlpoints 1-999 are optional and can be created with the Point_set() function, and read with the Point_get() function. It is also possible to change the controlpoints of the maps inside and FPG archive. Besides changing the controlpoints in a program, they can also be edited with fpg editors like Smart FPG Editor.\nSee also  MAP Format Specification map_new() map_load() map_save() map_unload() Center_set() Point_set() Point_get()  Category:controlpoints\n","permalink":"https://divhub.github.io/pixtudio-website/docs/controlpoint/","title":""},{"contents":" Definition Coordinatenumber flags are used to set which scroll or mode_7 coordinate system should display a process, by assigning them to the local variable cnumber of that process. This only has influence on scrolls or mode_7 coordinate systems, not on the screen\u0026rsquo;s coordinate system.\nHow to change the used coordinate system, see ctype and its constants.\nList Constant - Value - Description - 0 - Display the process in all scroll/mode_7-views (default) C_0 - 1 - Display the process in the scroll/mode_7-view with ID 0 C_1 - 2 - Display the process in the scroll/mode_7-view with ID 1 C_2 - 4 - Display the process in the scroll/mode_7-view with ID 2 C_3 - 8 - Display the process in the scroll/mode_7-view with ID 3 C_4 - 16 - Display the process in the scroll/mode_7-view with ID 4 C_5 - 32 - Display the process in the scroll/mode_7-view with ID 5 C_6 - 64 - Display the process in the scroll/mode_7-view with ID 6 C_7 - 128 - Display the process in the scroll/mode_7-view with ID 7 C_8 - 256 - Display the process in the scroll/mode_7-view with ID 8 C_9 - 512 - Display the process in the scroll/mode_7-view with ID 9\nCategory:constantcategories\n","permalink":"https://divhub.github.io/pixtudio-website/docs/coordinatenumber_flags/","title":""},{"contents":" Definition Coordinatetype modes are used to set the type of coordinatesytem to be used, by assigning them to the local variable ctype. Different coordinatesystems have different ways of interpreting the coordinates of a process. There\u0026rsquo;s another local variable which influences the interpretation of a process\u0026rsquo; coordinate, which is resolution.\nHow to change in which individual scroll or Mode7-view the process is visible, see cnumber and its constants.\nList Constant - Value - Relative to C_SCREEN - 0 - The screen\u0026rsquo;s top left corner, coordinate (0,0). C_SCROLL - 1 - The foreground graphic of the scroll in which the process is shown. C_M7 - 2 - The main graphic of the Mode7-view.\nCategory:constantcategories\n","permalink":"https://divhub.github.io/pixtudio-website/docs/coordinatetype_modes/","title":""},{"contents":" Syntax FLOAT cos ( \u0026lt;FLOAT angle\u0026gt; )\nDescription Returns the cosine of the specified angle.\nThis function performs a cosine calculation on a certain angle and returns a value between -1 and 1.\nParameters FLOAT angle - Angle, in thousandths of degrees. i.e. 75000 = 75º\nReturns FLOAT : The cosine result of the specified angle.\nNotes The angle value used in this function should be in thousandths of degrees, as most angles within Bennu are.\nTo read about all aspects of trigonometry, you can visit Wikipedia\u0026rsquo;s Trigonometric function page.\nExample Const screen_width = 320; screen_height = 200; screen_border = 15; End Global float value; End Process Main() Begin // Modes set_title(\u0026quot;Cosine Graph\u0026quot;); set_mode(screen_width,screen_height); // X axis for(x=1;x\u0026lt;=8;x++) write( 0, screen_border+x*(screen_width-screen_border)/8+3, screen_height-1, 8, itoa(x*360/8 )+\u0026quot;^\u0026quot; ); end draw_line(1,screen_height-screen_border,screen_width,screen_height-screen_border); // Y axis write(0,screen_border-1,20,5,\u0026quot;1\u0026quot;); write(0,screen_border-1,screen_height/2,5,\u0026quot;0\u0026quot;); write(0,screen_border-1,screen_height-20,5,\u0026quot;-1\u0026quot;); draw_line(screen_border,1,screen_border,screen_height-1); // Draw tangent for(angle=0;angle\u0026lt;360;angle++) value=cos(angle*1000)*(screen_height/2-20); put_pixel( screen_border+angle*(screen_width-screen_border)/360, screen_height/2-value, rgb(255,255,255) ); // screen_height/2-value because the screen's origin (0,0) is topleft instead of downleft. end Repeat frame; Until(key(_ESC)) End  Used in example: set_title(), set_mode(), write(), draw_line(), cos(), put_pixel(), key()\nThis will result in something like:\nCategory:functions Category:math Category:mod_math\n","permalink":"https://divhub.github.io/pixtudio-website/docs/cos/","title":""},{"contents":" category:variables category:predefined category:local variables category:libscroll category:librender\nUp to Local Variables\nDefinition Coordinatetype modes are used to set the type of coordinatesytem to be used, by assigning them to the local variable ctype. Different coordinatesystems have different ways of interpreting the coordinates of a process. There\u0026rsquo;s another local variable which influences the interpretation of a process\u0026rsquo; coordinate, which is Resolution.\nHow to change in which individual scroll or Mode7-view the process is visible, see C_number and its constants.\nList Constant - Value - Relative to C_SCREEN - 0 - The screen\u0026rsquo;s top left corner, coordinate (0,0). C_SCROLL - 1 - The foreground graphic of the scroll in which the process is shown. C_M7 - 2 - The main graphic of the Mode7-view.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/ctype/","title":""},{"contents":" Description Datatypes give meaning to data and dictate how a variable acts and reacts. Examples of datatypes are [[int]]s, [[float]]s and [[string]]s. Special cases are voids, arrays, varspaces and structs. User made types can also be defined, by use of the operator Type.\nList  category = datatypes mode = userformat columns = 1 listseparators = ,\\n* %TITLE%,, redirects = include ordermethod = titlewithoutnamespace resultsfooter = \\n%PAGES% datatypes \nExample import \u0026quot;mod_draw\u0026quot; import \u0026quot;mod_wm\u0026quot; import \u0026quot;mod_key\u0026quot; import \u0026quot;mod_map\u0026quot; Type _point int x; int y; End Process Main() Private _point A,B; Begin // Init the points A.x = 100; A.y = 50; B.x = 250; B.y = 150; // Setup drawing drawing_map(0,0); drawing_color(rgb(0,255,255)); // Draw a box drw_box(A,B); // Wait for key ESC or X button Repeat frame; Until(key(_ESC)||exit_status) End // Draw a box using two points Function int drw_box(_point A, _point B) Begin return draw_box(A.x,A.y,B.x,B.y); End  Used in example: drawing_map(), drawing_color(), rgb(), key(), draw_box(), exit_status\nCategory:general\n","permalink":"https://divhub.github.io/pixtudio-website/docs/datatypes/","title":""},{"contents":" Syntax Debug ;\nDescription Debug is a reserved word used to tell PixTudio to go into debug mode, only if the DCB was compiled with debug information (compiler option -g). If the module mod_debug was imported as well, the console is immediately invoked and one can begin tracing from the debug statement.\nHere\u0026rsquo;s a handy page about debugging a Bennu program.\nExample  Function int debug_warning(string warning) Begin say(\u0026quot;Warning: \u0026quot; + warning); debug; return 0; End  Used in example: say(), debug\n","permalink":"https://divhub.github.io/pixtudio-website/docs/debug/","title":""},{"contents":" Debugging a Bennu program can be tricky. So here are a few tips to get you on your way.\nDebug mode To run a game in debug mode, you have to import the debug module(\u0026ldquo;mod_debug\u0026rdquo;) and to compile the .prg with the -g option (e.g. bgdc.exe -g name.prg). Then when you run the game, it is in debug mode. In this there\u0026rsquo;s a number of shortcuts, with a variety in usefulness.\nShortcuts ALT-C - Show/hide the Bennu console. ALT-F - Go into fullscreen mode. ALT-G - Make a screenshot and save it as shotXXXX where XXXX is the lowest possible number. ALT-P - Show/hide the Bennu profiler ALT-R - Resets the profile history of the Bennu Profiler. ALT-S - Activate/Deactivate the Bennu Profiler. ALT-W - Go into window mode. ALT-X - Exit. ALT-Z - Switch the MODE_16BITS flag of graph_mode on/off.\nBennu Console The Bennu console is a pretty handy debugging tool. You can view all active processes, view values of any variable, perform one instruction, perform one frame, manage breakpoints on processes, manage processes, etc. A sure go for debugging.\nBennu Profiler The Bennu profiler is somewhat handy, mostly for tracing where a program is the most power hungry.\nCategory:general Category:debugging\n","permalink":"https://divhub.github.io/pixtudio-website/docs/debugging/","title":""},{"contents":" Syntax Declare [ Function | Process ] [ {returntype} ] {name} ( [ {parameters} ] )\nPrivate {private variables} End Public {public variables} End  Description Declare is a reserved word used to declare a process or function before its actual code. This can be useful if the function or process needs to be known before it is actually defined, like when the function returns something other than an int or when the publics of the process need to be accessed before the definition. By default, the returntype of a process or function is an int.\nWhen using this statement, a few things can be defined about the process/function:\n If it\u0026rsquo;s a process or function Its returntype The parameters of the process or function The public variables of the process or function The private variables of the process or function  The first three are defined when using the statement Declare, while the last two are defined within the Declare block.\nExample  Declare Process example_process() Public // Declare public variables for the process example_process int public_int; string public_string; End /* The Process definition handles this section Private // Declare private variables for the process example_process int private_int; End */ End Declare Function string example_function( int param_int) Private // Declare private variables for the process example_process int private_int; End End Process example_process(); /* The Declare handles this section. Public int public_int; string public_string; */ Private int private_int; Begin Loop frame; End End Function string example_function( int param_int) Begin return \u0026quot;\u0026quot;; End  ","permalink":"https://divhub.github.io/pixtudio-website/docs/declare/","title":""},{"contents":" Definition INT delete_draw ( \u0026lt;INT DrawID\u0026gt; )\nDeletes a certain drawing from the screen.\nParameters INT DrawID - DrawID of the drawing to be deleted.\nReturns INT : true\nNotes Delete_draw(0) deletes all drawings from the screen.\nCategory:functions Category:drawing Category:mod_draw\n","permalink":"https://divhub.github.io/pixtudio-website/docs/delete_draw/","title":""},{"contents":" Definition INT delete_text ( \u0026lt;INT TextID\u0026gt; )\nDeletes a certain text from the screen.\nParameters INT TextID - TextID of the text to be deleted.\nReturns INT : true\nNotes Delete_text(ALL_TEXT) deletes all text from the screen.\nExample Program test; Global my_text; Begin my_text = write(0,320/2,200/2,4,\u0026quot;Press space to delete this.\u0026quot;); Repeat if (key(_space)) if(my_text\u0026gt;0) delete_text(my_text); my_text = 0; end end Frame; Until(key(_esc)) End  Used in example: write(), key(), textID\nThis will result in something like:\nCategory:functions Category:texts Category:mod_text\n","permalink":"https://divhub.github.io/pixtudio-website/docs/delete_text/","title":""},{"contents":" Definition INT dirclose ( \u0026lt;INT handleId\u0026gt; )\nClose a directory using a given handle id obtained with diropen().\nParameters INT handleId - The handle id of a directory.\nReturns INT : The handle of the opened directory.\n0 - There was an error. 1 - The directory was closed successfully.\nCategory:functions Category:files Category:mod_dir\n","permalink":"https://divhub.github.io/pixtudio-website/docs/dirclose/","title":""},{"contents":" Definition INT diropen ( \u0026lt;STRING folder\u0026gt; )\nOpen a directory for read it, returns handle id.\nParameters STRING folder - The folder to open for read.\nReturns INT : The handle of the opened directory.\n0 - There was an error. \u0026gt;0 - The handle of the opened directory.\nCategory:functions Category:files Category:mod_dir\n","permalink":"https://divhub.github.io/pixtudio-website/docs/diropen/","title":""},{"contents":" Definition STRING dirread ( \u0026lt;INT handle\u0026gt; )\nGiven a path with wildcards (\u0026rsquo;*\u0026rsquo; or \u0026lsquo;?\u0026rsquo; characters), returns the first file that matches and, in every next call, all matching files found until no more files exists. It then returns NIL. Presumebly it\u0026rsquo;s somewhat similair to glob. Also you can read multiple directories with different search criteria. This is usefull for filemanagers and dialogboxes, when you only want to list files of a specific type.\nParameters INT handle - The id of the folder opened with Diropen.\nReturns \u0026rdquo;\u0026lsquo;STRING \u0026ldquo;\u0026rsquo; : The filename that matches with the wildcard search pattern.\nExample IMPORT \u0026quot;mod_dir\u0026quot;; IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_key\u0026quot;; GLOBAL int dir_id[9]; string dir_result[9]; string directory1=\u0026quot;c:\\windows\\*.exe\u0026quot;; string directory2=\u0026quot;c:\\windows\\*.dll\u0026quot;; string directory3=\u0026quot;c:\\windows\\*.txt\u0026quot;; PROCESS main(); BEGIN dir_id[0]=diropen(directory1); dir_id[1]=diropen(directory2); dir_id[2]=diropen(directory3); /* print all exe files */ say(\u0026quot;\u0026quot;); say(\u0026quot;dirread test\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;the directory is: \u0026quot;+directory1); say(\u0026quot;\u0026quot;); say(\u0026quot;reading directory.....\u0026quot;); say(\u0026quot;\u0026quot;); REPEAT IF (key(_esc)) say(\u0026quot;\u0026lt;aborted\u0026gt;\u0026quot;); BREAK; END // read the dir dir_result[0]=dirread(dir_id[0]); say(dir_result[0]); FRAME; UNTIL (dir_result[0]==\u0026quot;\u0026quot;) /* print all dll files */ say(\u0026quot;\u0026quot;); say(\u0026quot;dirread test\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;the directory is: \u0026quot;+directory2); say(\u0026quot;\u0026quot;); say(\u0026quot;reading directory.....\u0026quot;); say(\u0026quot;\u0026quot;); REPEAT IF (key(_esc)) say(\u0026quot;\u0026lt;aborted\u0026gt;\u0026quot;); BREAK; END // read the dir dir_result[1]=dirread(dir_id[1]); say(dir_result[1]); FRAME; UNTIL (dir_result[1]==\u0026quot;\u0026quot;) /* print all txt files */ say(\u0026quot;\u0026quot;); say(\u0026quot;dirread test\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;the directory is: \u0026quot;+directory3); say(\u0026quot;\u0026quot;); say(\u0026quot;reading directory.....\u0026quot;); say(\u0026quot;\u0026quot;); REPEAT IF (key(_esc)) say(\u0026quot;\u0026lt;aborted\u0026gt;\u0026quot;); BREAK; END // read the dir dir_result[2]=dirread(dir_id[2]); say(dir_result[2]); FRAME; UNTIL (dir_result[2]==\u0026quot;\u0026quot;) say(\u0026quot;closing the directory\u0026quot;); dirclose(dir_id[0]); dirclose(dir_id[1]); dirclose(dir_id[2]); END  Used in example: say(), Diropen(), Dirclose().\nCategory:functions Category:files Category:mod_dir\n","permalink":"https://divhub.github.io/pixtudio-website/docs/dirread/","title":""},{"contents":"Up to Index\nRead here on how to code your own DLL\u0026rsquo;s for BennuGD.\nThis is a list of DLLs.\n namespace = DLL mode = userformat listseparators = ,\\n* %TITLE%,, redirects = include noresultsheader = No DLL\u0026rsquo;s here yet. resultsfooter = \\n%PAGES% DLL\u0026rsquo;s replaceintitle = /\\\\? /,_ replaceintitle = / DLL/,.DLL \nAnother modules that can be found in the official spanish forum.\nList modules:\n mod_beep bennu3d bennuvideo en bennupack bedbx en bennupack mod_dctools mod_espeak mod_expand port by GECA Soft expand en BennuPack fgfx en bennupack mod_fire port by GECA Soft fire en BennuPack libfmodex fsock hiper3d en bennupack libimage joylibffb en bennupack lcd Log fenix_mng en bennupack mod_mappy mod_midi mod_notes mpeg en bennupack libnetwork en bennupack net opencv pango mod_svg mod_sqlite3 mod_smpeg sumarlib en bennupack showvarlibs en bennupack mod_tinyxml ttf tscroll en bennupack voxel en BennuPack mod_vse port by DCelso water  Work in progress:\n beogre mod_litha mod_open3d yeti3d en bennupack  ","permalink":"https://divhub.github.io/pixtudio-website/docs/dlls/","title":""},{"contents":" Definition INT draw_box ( \u0026lt;INT x0\u0026gt; , \u0026lt;INT y0\u0026gt; , \u0026lt;INT x1\u0026gt; , \u0026lt;INT y1\u0026gt; )\nDraws a filled rectangle with corners (x0,y0), (x0,y1), (x1,y0) and (x1,y1).\nParameters INT x0 - The x coordinate of one corner of the filled rectangle. INT y0 - The y coordinate of one corner of the filled rectangle. INT x1 - The x coordinate of the diagonally opposite corner of the filled rectangle. INT y1 - The y coordinate of the diagonally opposite corner of the filled rectangle.\nReturns INT : DrawID\n-1 - Error. 1 - If drawn after drawing_map(). !-1\u0026amp;\u0026amp;!1 - The DrawID of the drawing created.\nCategory:functions Category:drawing Category:mod_draw\n","permalink":"https://divhub.github.io/pixtudio-website/docs/draw_box/","title":""},{"contents":" Definition INT draw_circle ( \u0026lt;INT x\u0026gt; , \u0026lt;INT y\u0026gt; , \u0026lt;INT radius\u0026gt; )\nDraws a non-filled circle with center (x0,y0) and radius radius.\nParameters INT x - The x coordinate of one center of the non-filled circle. INT y - The y coordinate of one center of the non-filled circle. INT radius - The radius of the non-filled circle.\nReturns INT : DrawID\n-1 - Error. 1 - If drawn after drawing_map(). !-1\u0026amp;\u0026amp;!1 - The DrawID of the drawing created.\nCategory:functions Category:drawing Category:mod_draw\n","permalink":"https://divhub.github.io/pixtudio-website/docs/draw_circle/","title":""},{"contents":" Definition INT draw_curve ( \u0026lt;INT x0\u0026gt; , \u0026lt;INT y0\u0026gt; , \u0026lt;INT x1\u0026gt; , \u0026lt;INT y1\u0026gt; , \u0026lt;INT x2\u0026gt; , \u0026lt;INT y2\u0026gt; , \u0026lt;INT x3\u0026gt; , \u0026lt;INT y3\u0026gt; , \u0026lt;INT smoothness\u0026gt; )\nDraws a curve starting at the point (x0,y0), ending at the point (x3,y3) and influenced by the points (x1,y1) and (x2,y2) with a certain level of smoothness.\nParameters INT x0 - The x coordinate of the starting point of the curve. INT y0 - The y coordinate of the starting point of the curve. INT x1 - The x coordinate of the first influence point of the curve. INT y1 - The x coordinate of the first influence point of the curve. INT x2 - The x coordinate of the second influence point of the curve. INT y2 - The x coordinate of the second influence point of the curve. INT x3 - The x coordinate of the end point of the curve. INT y3 - The y coordinate of the end point of the curve. INT smoothness - The smoothness with which the line will be drawn from 1 to 15, 15 being the smoothest.\nReturns INT : DrawID\n-1 - Error. 1 - If drawn after drawing_map(). !-1\u0026amp;\u0026amp;!1 - The DrawID of the drawing created.\nExample import \u0026quot;mod_draw\u0026quot; import \u0026quot;mod_video\u0026quot; import \u0026quot;mod_mouse\u0026quot; import \u0026quot;mod_map\u0026quot; GLOBAL scr_width = 640, scr_height=480; End; Process main() Begin /* Check that we can set the video mode before actually setting it */ if(!mode_is_ok(scr_width, scr_height, 16, MODE_WINDOW)) return -1; end; set_mode(scr_width, scr_height, 16, MODE_WINDOW); /* Draw three long bezier lines with different colors and smoothnesses */ drawing_map(0, 0); drawing_color(rgb(255, 0, 0)); draw_curve(0, scr_height/4, scr_width/4, 0, 3*scr_width/4, 2*scr_height/4, scr_width, scr_height/4, 1); drawing_color(rgb(0, 255, 0)); draw_curve(0, 2*scr_height/4, scr_width/4, scr_height/4, 3*scr_width/4, 3*scr_height/4, scr_width, 2*scr_height/4, 3); drawing_color(rgb(0, 0, 255)); draw_curve(0, 3*scr_height/4, scr_width/4, 2*scr_height/4, 3*scr_width/4, 4*scr_height/4, scr_width, 3*scr_height/4, 15); while(! mouse.left) FRAME; end; // Delete all the lines delete_draw(0); End;  Used in example: mode_is_ok(), set_mode(), drawing_map() drawing_color(), rgb(), draw_curve(), delete_draw()\nCategory:functions Category:drawing Category:mod_draw\n","permalink":"https://divhub.github.io/pixtudio-website/docs/draw_curve/","title":""},{"contents":" Definition INT draw_fcircle ( \u0026lt;INT x\u0026gt; , \u0026lt;INT y\u0026gt; , \u0026lt;INT radius\u0026gt; )\nDraws a filled circle with center (x0,y0) and radius radius.\nParameters INT x - The x coordinate of one center of the filled circle. INT y - The y coordinate of one center of the filled circle. INT radius - The radius of the filled circle.\nReturns INT : DrawID\n-1 - Error. 1 - If drawn after drawing_map(). !-1\u0026amp;\u0026amp;!1 - The DrawID of the drawing created.\nCategory:functions Category:drawing Category:mod_draw\n","permalink":"https://divhub.github.io/pixtudio-website/docs/draw_fcircle/","title":""},{"contents":" Definition INT draw_line( \u0026lt;INT x0\u0026gt; , \u0026lt;INT y0\u0026gt; , \u0026lt;INT x1\u0026gt; , \u0026lt;INT y1\u0026gt; )\nDraws a line from point (x0,y0) to point (x1,y1).\nParameters INT x0 - The x coordinate of one point of the line. INT y0 - The y coordinate of one point of the line. INT x1 - The x coordinate of the other point of the line. INT y1 - The y coordinate of the other point of the line.\nReturns INT : DrawID\n-1 - Error. 1 - If drawn after drawing_map(). !-1\u0026amp;\u0026amp;!1 - The DrawID of the drawing created.\nCategory:functions Category:drawing Category:mod_draw\n","permalink":"https://divhub.github.io/pixtudio-website/docs/draw_line/","title":""},{"contents":" Definition INT draw_rect ( \u0026lt;INT x0\u0026gt; , \u0026lt;INT y0\u0026gt; , \u0026lt;INT x1\u0026gt; , \u0026lt;INT y1\u0026gt; )\nDraws a non-filled rectangle with corners (x0,y0), (x0,y1), (x1,y0) and (x1,y1).\nParameters INT x0 - The x coordinate of one corner of the non-filled rectangle. INT y0 - The y coordinate of one corner of the non-filled rectangle. INT x1 - The x coordinate of the diagonally opposite corner of the non-filled rectangle. INT y1 - The y coordinate of the diagonally opposite corner of the non-filled rectangle.\nReturns INT : DrawID\n-1 - Error. 1 - If drawn after drawing_map(). !-1\u0026amp;\u0026amp;!1 - The DrawID of the drawing created.\nCategory:functions Category:drawing Category:mod_draw\n","permalink":"https://divhub.github.io/pixtudio-website/docs/draw_rect/","title":""},{"contents":" Definition DrawID\nA DrawID is an identifier associated with a certain drawing. It is returned by draw_xxx() functions. It can be used in other functions, to alter its state.\nNotes DrawID \u0026ldquo;0\u0026rdquo; means all drawings.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/drawid/","title":""},{"contents":" Definition A drawing is something drawn on the screen using draw_xxx() functions. This can be a circle, square, line or whatever they can draw. A drawing is associated with a certain DrawID, returned by the function which drew the drawing.\nA drawing also has a certain z value, initialized when drawn and at that point equal to the value set using drawing_z(). The drawing will behave like a process with the same z. When drawing_map() is used, that z value is ignored and the drawing is just drawn on the specified graphic.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/drawing/","title":""},{"contents":" Definition INT drawing_alpha ( \u0026lt;INT alpha\u0026gt; )\nTells Bennu to draw the coming drawings with a certain alpha value\nNote: there currently is a \u0026lsquo;bug\u0026rsquo; that makes drawing objects (draw commands with no map as target) have their alpha value altered too. This is to be changed.\nParameters INT alpha - The alpha value to be drawn with.\nReturns INT : true\nCategory:functions Category:drawing Category:mod_draw\n","permalink":"https://divhub.github.io/pixtudio-website/docs/drawing_alpha/","title":""},{"contents":" Definition INT drawing_color ( \u0026lt;INT color\u0026gt; )\nTells Bennu to draw the coming drawings in a certain color.\nParameters INT color - The color to be drawn in (see rgb()).\nReturns INT : true\nCategory:functions Category:drawing Category:mod_draw\n","permalink":"https://divhub.github.io/pixtudio-website/docs/drawing_color/","title":""},{"contents":" Definition INT drawing_map ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; )\nTells Bennu to draw the coming drawings on a certain graphic.\nIn order to draw with a certain z value again, drawing_z() can be used.\nParameters INT fileID - The fileID of the file that holds the graphic. INT graphID - The graphID of the graphic to draw on.\nReturns INT : true\nCategory:functions Category:drawing Category:mod_draw\n","permalink":"https://divhub.github.io/pixtudio-website/docs/drawing_map/","title":""},{"contents":" Definition INT drawing_stipple ( \u0026lt;INT stipples\u0026gt; )\nTells Bennu which pixels to draw of the coming drawings.\nThis is done by passing a 32bit value, each bit representing a pixel. Bit 0 represents the first pixels drawn, bit 1 represents the second, etc. When a 33rd pixel is to be drawn or not, bit 0 is checked and the cycle starts over. This means a value of 0xFFFFFFFF (=2^32-1) means normal operation, meaning all the pixels will be drawn.\nNote that this works only for non-filled drawings. For draw_curve(), the pattern is not always visible for the higher smoothness levels.\nParameters INT stipples - Which pixels to draw, repetitive 32bits.\nReturns INT : true\nExample Program example; Private // int draw_id; Begin // Draw in background drawing_map(0,background); // Set stipplemode to display every other pixel. // binary code 0101 0101 0101 0101 0101 0101 0101 0101 // hex code 55555555h drawing_stipple(55555555h); // Draw two lines draw_line(10,10,190,10); draw_line(11,12,190,12); // Draw this funky pattern // binary code 0011 1100 0111 1100 1010 0001 1101 0011 // hex code 3C7CA1D3h drawing_stipple(3C7CA1D3h); // Draw two lines draw_line(10,20,190,20); draw_line(11,22,190,22); // Draw a circle draw_circle(100,100,50); // Draw a rectangle draw_rect(50,50,150,150); // Draw some lines draw_line( 50, 50,100,150); draw_line(100,150,150, 50); draw_line( 50,150,100, 50); draw_line(100, 50,150,150); // Draw two curves: one with high smoothness (bit pattern not visible) and one with low smoothness draw_curve( 200,200, 100,200, 100,150, 300,100,15); draw_curve( 200,200, 100,200, 100,150, 300,100,1); // Draw a filled circle draw_fcircle(20,180,15); // Draw a filled rectangle draw_box(50,180,80,195); // Wait for key ESC Repeat frame; Until(key(_ESC)) End  Used in example: drawing_map(), draw_line(), draw_circle(), draw_rect(), draw_curve(), draw_fcircle(), draw_box(), key()\nThis will result in something like:\nCategory:functions Category:drawing Category:mod_draw\n","permalink":"https://divhub.github.io/pixtudio-website/docs/drawing_stipple/","title":""},{"contents":" Definition INT drawing_z ( \u0026lt;INT z\u0026gt; )\nTells Bennu to draw the coming drawings on a certain z value.\nIn order to draw on a certain graphic again, drawing_map() can be used.\nParameters INT z - The z value to be drawn on.\nReturns INT : true\nCategory:functions Category:drawing Category:mod_draw\n","permalink":"https://divhub.github.io/pixtudio-website/docs/drawing_z/","title":""},{"contents":" Definition Dump modes are used to define the type of dump, needed to be applied to the screen, by assigning them to the global variable dump_type. This influences when and if graphics of processes are drawn to the screen.\nList Constant - Value - Description PARTIAL_DUMP - 0 - Only graphics of updated (changed) processes will be drawn (default). COMPLETE_DUMP - 1 - Graphics of all processes will be drawn, whether they\u0026rsquo;ve changed or not.\nNotes It is clear that completely drawing all processes every frame is more expensive then updating only some of them. This mode can be useful still, because partially drawing processes can cause probably unwanted effects in some situations, mostly in combination with a certain restore_modes. However, if you experience no such thing, you can use the partial drawing.\nPARTIAL_DUMP is useful if there is relatively not much changing to processes and when there are a lot of processes that don\u0026rsquo;t need updating. COMPLETE_DUMP is useful if most processes need updating.\nBe certain restore_type is compatible with the dump_type set, because some combinations can cause probably unwanted effects.\nSee also  dump_type restore_type restore_modes  Category:constantcategories\n","permalink":"https://divhub.github.io/pixtudio-website/docs/dump_modes/","title":""},{"contents":" category:variables category:predefined category:global variables category:mod_ category:librender\nUp to Global Variables\nDefinition INT dump_type = PARTIAL_DUMP\nDump_type is a global variable, holding the current dump_mode. The mode can be changed by assigning a different mode to the variable. Default is PARTIAL_DUMP.\nSee also restore_type.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/dump_type/","title":""},{"contents":" Syntax Dup [ ( {value} ) ] ;\nDescription The dup(value); return a space data filled with the given value. For example a 10 dup(0) return an array of 10 elements, all with a zero value.\nExample 1  import \u0026quot;mod_say\u0026quot;; global array[] = 10 dup(0); begin say ( sizeof(array)/sizeof(array[0]) ); end  This example prints 10 because the size of array is ten and the size of the first element is one.\nExample 2  import \u0026quot;mod_say\u0026quot;; global int array[5] = 1 , 4 dup(0); int arrayPosition; begin for ( arrayPosition = 0 ; arrayPosition \u0026lt; 5 ; arrayPosition = arrayPosition + 1 ) say ( array[arrayPosition] ); end end  This example prints:\n1 0 0 0 0  As it duplicates \u0026ldquo;0\u0026rdquo; four times in the array data.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/dup/","title":""},{"contents":" category:reserved category:language category:basic statement\nUp to Basic Statements\nSyntax End\nDescription End is a reserved word used to terminate loads of stuff, such as if-statements, loops, begin-statements, etc\u0026hellip;\nExample Process Main() Begin If(something) If(something_else) Loop frame; End //ends the loop End //ends the second if-statement End //ends the first if-statement End //ends the program block (begin keyword)  Used in example: process, if, loop, end\n","permalink":"https://divhub.github.io/pixtudio-website/docs/end/","title":""},{"contents":" Definition A Fenix error is an errorbox with some cryptic Spanish error message. When a function has a section Errors, it list what errors the function can cause. In later Fenix versions however (from which version? Later than 0.84b probably), the error isn\u0026rsquo;t displayed in an error dialog, but is printed to stderr.txt and the Fenix program is terminated.\nExample Here\u0026rsquo;s an example of an error, in Fenix 0.84a, when it is tried to blit a 16bit graph onto an 8bit one:\nCategory:general\n","permalink":"https://divhub.github.io/pixtudio-website/docs/error/","title":""},{"contents":" Definition INT exec ( \u0026lt;INT mode\u0026gt; , \u0026lt;STRING executable\u0026gt;, \u0026lt;INT number_of_arguments\u0026gt; , \u0026lt;STRING POINTER arguments\u0026gt; )\nExecutes the specified executable with the specified arguments in the specified mode.\nParameters INT mode - The mode to call the executable (_P_WAIT/_P_NOWAIT). STRING executable - The executable to start. INT number_of_arguments - The number of arguments given with arguments STRING POINTER arguments - Pointer to an array of strings to be passed; number_of_arguments strings will be passed as arguments.\nReturns INT\n-1 - Error. mode==_P_WAIT: - The exit status of the executable. mode==_P_NOWAIT: - The process ID of the executable. This is not a ProcessID, it is a process ID of the operating system.\nNotes The mode parameter can be two things:\n_P_WAIT - Wait for the executable to exit. _P_NOWAIT - Do not wait for the executable to exit.\nExample Open file.txt in notepad:\nimport \u0026quot;mod_sys\u0026quot; Process Main() Private string arg; Begin arg = \u0026quot;file.txt\u0026quot;; exec(_P_NOWAIT,\u0026quot;notepad.exe\u0026quot;,1,\u0026amp;arg); End  Used in example: exec(), pointer\nCategory:functions Category:programinteraction Category:mod_sys\n","permalink":"https://divhub.github.io/pixtudio-website/docs/exec/","title":""},{"contents":" Definition INT Exists ( \u0026lt;INT processID|processTypeID\u0026gt; )\nChecks if a process is alive, using its processID or checks if there is a process alive of a certain processType, using its processTypeID.\nParameters INT processID|processTypeID - The ProcessID of the process or the ProcessTypeID of the type of processes to be checked.\nReturns INT : The result of the check\n0 (false) - The process with given processID is not alive or there are no processes alive of the given processTypeID. 1 (true) - The process with given processID is alive or there is at least one process alive of the given processTypeID.\nExample import \u0026quot;mod_proc\u0026quot; import \u0026quot;mod_say\u0026quot; Process Main() Begin Proc(); if(exists(id)) say(\u0026quot;I exist! (id)\u0026quot;); end if(exists(0)) say(\u0026quot;0 exists!\u0026quot;); else say(\u0026quot;0 doesn't exist!\u0026quot;); end if(exists(type proc)) say(\u0026quot;1- Proc exists!\u0026quot;); else say(\u0026quot;1- Proc doesn't exist!\u0026quot;); end let_me_alone(); if(exists(type proc)) say(\u0026quot;2- Proc exists!\u0026quot;); else say(\u0026quot;2- Proc doesn't exist!\u0026quot;); end End Process Proc() Begin Loop frame; End End  Used in example: exists(), say(), let_me_alone()\nCategory:functions Category:processinteraction Category:mod_proc\n","permalink":"https://divhub.github.io/pixtudio-website/docs/exists/","title":""},{"contents":" Definition INT exit ( [\u0026lt;STRING message\u0026gt;] , [\u0026lt;INT code\u0026gt;] )\nExits the program. It can optionally pass a message or an error code thing.\nParameters [STRING message] - A message to pass outside the program as it exits. [INT code] - A code to pass outside the program as it exits.\nReturns INT : true\nCategory:functions Category:programinteraction Category:mod_proc\n","permalink":"https://divhub.github.io/pixtudio-website/docs/exit/","title":""},{"contents":" category:variables category:predefined category:global variables category:libwm\nUp to Global Variables\nDefinition INT exit_status\nexit_status is a predefined global variable, holding whether or not Bennu received a QUIT event this frame. A QUIT event is generated for example by pressing the X button of the window.\nValue - Description false - There is no QUIT event. true - There is a QUIT event.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/exit_status/","title":""},{"contents":" Definition INT fade ( \u0026lt;INT red\u0026gt; , \u0026lt;INT green\u0026gt; , \u0026lt;INT blue\u0026gt; , \u0026lt;INT speed\u0026gt; )\nFades the screen from the current setting to the specified setting (red,green,blue) at the specified speed.\nParameters INT red - Amount of red shown from 0 to 200. 100 is normal. INT green - Amount of red shown from 0 to 200. 100 is normal. INT blue - Amount of red shown from 0 to 200. 100 is normal. INT speed - The speed of the fade from 1 to 64.\nReturns INT : true\nNotes Standard RGB combinations:\n(R,G,B) - Description (0,0,0) - Black out. (100,100,100) - Normal. (200,200,200) - White out.\n The number of frames the fading will take can be calculated like this: frames = roundup( 64 / speed )\n speed = roundup( 64 / frames )\n  So:\nSpeed - Description \u0026lt;0 - Takes 1 frame. 0 - Pointless. 1 - Takes 64 frames. 2 - Takes 32 frames. 3 - Takes 22 frames. \u0026gt;=64 - Takes 1 frame.\nSee also fade_on() and fade_off().\nCategory:functions Category:palettes Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fade/","title":""},{"contents":" Definition INT fade_music_in ( \u0026lt;INT songID\u0026gt; , \u0026lt;INT num_loops\u0026gt; , \u0026lt;INT ms\u0026gt; )\nFades the music in, stepping up the volume from silence to the main song volume, i.e. set by the Set_song_volume() function.\nParameters INT songID - The identification code of the song, returned by load_song(). INT num_loops - The number of loops, a value of -1 will be an infinite loop. INT ms - Microseconds of fading (the duration).\nReturns INT : Error.\n-1 - Error: sound inactive.\nSee also Fade_music_off().\nCategory:functions Category:sound Category:mod_sound\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fade_music_in/","title":""},{"contents":" Definition INT fade_music_off ( \u0026lt;INT ms\u0026gt; )\nFades off the song, played by Play_song().\nParameters INT ms - Microseconds of fading (the duration).\nReturns INT : Error.\n-1 - Error: sound inactive.\nSee also Fade_music_in().\nCategory:functions Category:sound Category:mod_sound\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fade_music_off/","title":""},{"contents":" Definition INT fade_off ( )\nFades the screen from the current setting to black out.\nThis call is equivalent to [[fade]](0,0,0,16).\nReturns INT : true\nCategory:functions Category:palettes Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fade_off/","title":""},{"contents":" Definition INT fade_on ( )\nFades the screen from the current setting to normal.\nThis call is equivalent to [[fade]](100,100,100,16).\nReturns INT : true\nCategory:functions Category:palettes Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fade_on/","title":""},{"contents":" category:variables category:predefined category:global variables category:librender\nUp to Global Variables\nDefinition INT fading = false\nFading is a global variable, holding whether the screen is currently fading. This can be caused by the functions fade(), fade_on() or fade_off(). Its value will be true if there is fading going on and false if not.\nExample Program faders; Private int text_id; Begin // Write something text_id = write(0,160,100,4,\u0026quot;Look at this fading text!\u0026quot;); // Fade screen on and off fade_off_and_on(); // Wait for ESC key Repeat frame; Until(key(_ESC)) // Kill all other processes and clear up text let_me_alone(); delete_text(text_id); End Process fade_off_and_on() Begin Loop fade(0,0,0,4); // Fade to black while(fading) frame; end // Wait for the fading to finish fade(100,100,100,4); // Fade to normal while(fading) frame; end // Wait for the fading to finish End End  Used in example: write(), key(), let_me_alone(), delete_text(), fade()\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fading/","title":""},{"contents":" category:variables category:predefined category:local variables category:internal\nUp to Local Variables\nDefinition INT father\nFather is a predefined local variable. Father holds the ProcessID of the process/function that called the current process/function. There are several other local variables which refer to the ProcessID of a related process:\n Son Bigbro Smallbro  Example Program example; Begin first_process(); Loop frame; End End Process first_process() // Declaration of the first process Begin second_process(); // Call the second process Loop frame; // This loop makes \u0026quot;first_process()\u0026quot; a process rather than a function End End Process second_process() //declaration of another process Begin x = father.x; // These two lines use the father variable to move this process y = father.y; // to the position of first_process, as the father variable here // holds the ProcessID of \u0026quot;first_process()\u0026quot; Loop frame; End End  Used in example: process, function, processID\n","permalink":"https://divhub.github.io/pixtudio-website/docs/father/","title":""},{"contents":" Definition INT fclose ( \u0026lt;INT filehandle\u0026gt; )\nUnloads a file previously loaded with fopen().\nParameters INT filehandle - The FileHandle of the file returned by fopen().\nReturns INT: true\nExample Process loadthing(STRING loadpath); Private int handle; // handle for the loaded file int druppels; // here's where the loaded data go Begin handle=fopen(loadpath,O_READ); // opens the file in reading mode fread(handle,druppels); // reads from the file and puts the data in druppels fclose(handle); // zipping up after business is done write(0,0,0,0,druppels); // shows the value of druppels End  Used in example: fopen(), fread(), write()\nCategory:functions Category:files Category:mod_file\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fclose/","title":""},{"contents":" Definition INT feof ( \u0026lt;INT filehandle\u0026gt; )\nChecks if the end of a certain file is reached.\nParameters INT filehandle - The FileHandle of the file returned by fopen().\nReturns INT: true/false: Whether the end of the specified file is reached.\nCategory:functions Category:files Category:mod_file\n","permalink":"https://divhub.github.io/pixtudio-website/docs/feof/","title":""},{"contents":" Syntax INT fexists ( \u0026lt;STRING filename\u0026gt; )\nDescription Checks if a certain file exists.\nAlso called file_exists().\nParameters STRING filename - The file to be checked for existence, including a possible path.\nReturns INT : true/false: the existence of the file.\ntrue - The specified file exists. false - The specified file doesn\u0026rsquo;t exist.\nExample import \u0026quot;mod_file\u0026quot; import \u0026quot;mod_say\u0026quot; Process Main() Begin say(\u0026quot;\u0026gt; C:\\Windows\\notepad.exe \u0026gt; \u0026quot; + fexists(\u0026quot;C:\\Windows\\notepad.exe\u0026quot;)); // A filename with // absolute path say(\u0026quot;\u0026gt; SDL.dll \u0026gt; \u0026quot; + fexists(\u0026quot;SDL.dll\u0026quot;)); // A filename without a path say(\u0026quot;\u0026gt; SomeNonExistingFile \u0026gt; \u0026quot; + fexists(\u0026quot;SomeNonExistingFile\u0026quot;)); // A nonexisting file End  Used in example: say(), fexists()\nCategory:functions Category:files Category:mod_file\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fexists/","title":""},{"contents":" Definition INT fflush ( \u0026lt;INT filehandle\u0026gt; )\nClears internal data buffers for the file associated with the filehandle. The file has to be opened for output with the Readwrite_modes. This function comes from the standard C library, this is a miscellaneous function.\nParameters INT filehandle - The FileHandle of the file returned by fopen().\nReturns INT : - the status result of the action.\nEOF (-1) - an error was detected, or end of file has been reached. 0 - normal condition, everything is fine.\nCategory:functions Category:files Category:mod_file\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fflush/","title":""},{"contents":" Definition Fenix archive file, containing graphics.\nSee also  load_fgc() save_fgc() unload_fgc()  Category:filetypes\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fgc/","title":""},{"contents":" Definition INT fget_angle ( \u0026lt;INT pointA-X\u0026gt; , \u0026lt;INT pointA-Y\u0026gt; , \u0026lt;INT pointB-X\u0026gt; , \u0026lt;INT pointB-Y\u0026gt; )\nReturns the angle between two certain points. The returned angle will be ranging from 0 to 360000 (0-360º).\nParameters INT pointA-X - The X-coordinate of point A. INT pointA-Y - The Y-coordinate of point A. INT pointB-X - The X-coordinate of point B. INT pointB-Y - The Y-coordinate of point B.\nReturns INT : The angle between point A and point B.\nNotes The angle value returned by this function is in thousandths of degrees, as most angles within Bennu are.\nExample Const screen_width = 320; screen_height = 200; screen_depth = 8; screen_fps = 60; screen_frameskip = 0; End Global int distance; int tempID; End Process Main() Begin // Set the screen mode set_mode(screen_width,screen_height,screen_depth); set_fps(screen_fps,screen_frameskip); // Change this to see what happens resolution = 100; // Create mouse graph, assign to mouse.graph mouse.graph = new_map(20,20,screen_depth); map_clear(0,mouse.graph,rgb(255,0,0)); // Create arrow, assign to graph graph = new_map(30,30,screen_depth); drawing_map(0,graph); drawing_color(rgb(0,255,0)); draw_line( 0,29,29,30/2); draw_line( 0, 0,30,30/2); // Set position x = screen_width /2 * resolution; y = screen_height/2 * resolution; // Display distance write(0,0,0,0,\u0026quot;Distance:\u0026quot;); write_int(0,60,0,0,\u0026amp;distance); // Always point to the mouse Repeat // Get the angle and distance between this process' coordinates and those of the mouse. angle = fget_angle(x,y,mouse.x*resolution,mouse.y*resolution); distance = fget_dist (x,y,mouse.x*resolution,mouse.y*resolution); frame; Until(key(_esc)) End  Used in example: set_mode(), new_map(), map_clear(), drawing_map(), drawing_color(), draw_line(), write(), write_int(), fget_angle(), fget_dist(), resolution, mouse, graph, x, y, angle\nThis example could also be done with get_angle(), but that would be more work.\nIt could look something like:\nCategory:functions Category:math Category:mod_math\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fget_angle/","title":""},{"contents":" Definition INT fget_dist ( \u0026lt;INT pointA-X\u0026gt; , \u0026lt;INT pointA-Y\u0026gt; , \u0026lt;INT pointB-X\u0026gt; , \u0026lt;INT pointB-Y\u0026gt; )\nReturns the distance between two certain points.\nParameters INT pointA-X - The X-coordinate of point A. INT pointA-Y - The Y-coordinate of point A. INT pointB-X - The X-coordinate of point B. INT pointB-Y - The Y-coordinate of point B.\nReturns INT : The distance between point A and point B.\nExample Program angling; Const screen_width = 320; screen_height = 200; screen_depth = 8; screen_fps = 60; screen_frameskip = 0; Global int distance; int tempID; Begin // Set the screen mode set_mode(screen_width,screen_height,screen_depth); set_fps(screen_fps,screen_frameskip); // Change this to see what happens resolution = 100; // Create mouse graph, assign to mouse.graph mouse.graph = new_map(20,20,screen_depth); map_clear(0,mouse.graph,rgb(255,0,0)); // Create arrow, assign to graph graph = new_map(30,30,screen_depth); drawing_map(0,graph); drawing_color(rgb(0,255,0)); draw_line( 0,29,29,30/2); draw_line( 0, 0,30,30/2); // Set position x = screen_width /2 * resolution; y = screen_height/2 * resolution; // Display distance write(0,0,0,0,\u0026quot;Distance:\u0026quot;); write_int(0,60,0,0,\u0026amp;distance); // Always point to the mouse Repeat // Get the angle and distance between this process' coordinates and those of the mouse. angle = fget_angle(x,y,mouse.x*resolution,mouse.y*resolution); distance = fget_dist (x,y,mouse.x*resolution,mouse.y*resolution); frame; Until(key(_esc)) End  Used in example: set_mode(), new_map(), map_clear(), drawing_map(), drawing_color(), draw_line(), write(), write_int(), fget_angle(), fget_dist(), resolution, mouse, graph, x, y, angle\nThis example could also be done with get_dist(), but that would be more work. It also gives a much less accurate distance when the resolution is \u0026gt;1.\nResolution is 100:\n{{Image image = get_angle.png caption = get_angle() and get_dist() }} | VS {{Image image = fget_angle.png caption = fget_angle() and fget_dist() }}\nCategory:functions Category:math Category:mod_math\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fget_dist/","title":""},{"contents":" Definition STRING fgets ( \u0026lt;INT filehandle\u0026gt; )\nReads a line from a certain file and returns it. Subsequent calls will return the next line, until the end of the file is reached.\nParameters INT filehandle - The FileHandle of the file returned by fopen().\nReturns STRING: The line read.\nNotes The returned string normally does not contain the \u0026lsquo;\\n\u0026rsquo; or \u0026lsquo;\\r\u0026rsquo;,\u0026rsquo;\\n\u0026rsquo; charactersets.\nWhen a line ends with the character \u0026lsquo;\\\u0026rsquo;, the next line will be joined with the current one, changing the \u0026lsquo;\\\u0026rsquo; character to a \u0026lsquo;\\n\u0026rsquo; character.\nIf you want to read multiple lines from a textfile, put this function in a loop.\nCategory:functions Category:files Category:mod_file\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fgets/","title":""},{"contents":" Definition Fenix header file, containing code.\nSee also  Include  Category:filetypes\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fh/","title":""},{"contents":"  This is about the filetype. Did you mean the local variable file or the function file()?  Up to Filetypes\nDescription A file is a container for graphics, identified by a non-negative integer (0 or higher). It holds all information about the contained graphics (pixels, width, height, depth, name, etc). Each of these graphics have a unique identifier inside the file (positive int).\nA file can be created for example by loading an FPG (Fichero Para Gráficos, meaning \u0026ldquo;file for graphics\u0026rdquo;) into it, by using fpg_load(), which creates a new file with the graphics from the loaded FPG and returns a unique identifier. Another option is to create a new, empty one by using fpg_new(). Don\u0026rsquo;t let the name fpg_new() fool you: fpg_new() has nothing to do with the filetype FPG. This is because the FPG format is only for files and not for internal use. There are more ways to load graphics into a file.\nA file can be used by using the local variable file or by using the identifier in the various functions with a file parameter.\nDon\u0026rsquo;t forget to unload it with fpg_unload() after use.\nExample import \u0026quot;mod_map\u0026quot; import \u0026quot;mod_grproc\u0026quot; import \u0026quot;mod_key\u0026quot; import \u0026quot;mod_wm\u0026quot; Global int file_id; int file_id2; End Process Main() Begin // Load FPG file_id = load_fpg(\u0026quot;example.fpg\u0026quot;); file_id2 = load_fpg(\u0026quot;example2.fpg\u0026quot;); // Set locals for display of graph file = file_id; graph = 1; x = y = 50; // assign Ship to use example2.fpg Ship(300,100,5,file_id2,1); // undefined in this sample Repeat frame; Until(key(_ESC)||exit_status) End  Used in example: load_fpg(), key(), x, y, file, graph. process\nMedia in example: example.fpg\nNote: nothing will be seen unless you have an FPG \u0026ldquo;example.fpg\u0026rdquo; with a graphic with ID 1.\nCategory:general\n","permalink":"https://divhub.github.io/pixtudio-website/docs/file/","title":""},{"contents":" Description A FileHandle is an identifier for a file, for use in functions requiring a FileHandle, like fread(), fwrite() and fclose().\nConsider the following code:\nhandle = fopen(\u0026quot;file.txt\u0026quot;,O_READ);  The fopen() function will try to open the \u0026ldquo;file.txt\u0026rdquo; for reading. If it fails to open the file for whatever reason (e.g. file not found or insufficient user rights) handle will have the value of 0. If opening the file for reading succeeded, the handle will have a value other than 0. What the value will be depends on the OS and runtime circumstances. It represents an OS internal pointer to the actual file.\nThe file will remain open for reading, until it is closed using fclose():\nfclose(handle);  This is important, because else the operating system and other programs think you are still using it and this can result in them not being able to open the file.\nExample So always check if a file has been successfully opened and close the file when you are done with it.\nimport \u0026quot;mod_file\u0026quot; import \u0026quot;mod_say\u0026quot; Process Main() Private int handle; // handle for the loaded file string first_line; // here's where the first line of the file will go Begin // Open the file \u0026quot;file.txt\u0026quot; handle = fopen( \u0026quot;file.txt\u0026quot;,O_READ); if (handle == 0) say( \u0026quot;Could not open file\u0026quot; ); return; end // Read the first line form the file first_line = fgets(handle); // Output the read line say( \u0026quot;Read from file:\u0026quot; ); say('\u0026quot;' + first_line + '\u0026quot;'); // Close the file (important!) fclose(handle); End  Used in example: fopen(), say(), fgets(), fclose()\nCategory:general Category:mod_file\n","permalink":"https://divhub.github.io/pixtudio-website/docs/filehandle/","title":""},{"contents":" Definition FileID\nA FileID is an identifier associated with a certain file (FPG). It is returned by load_fpg(), when a file is loaded to memory and can be used in many functions, wanting a FileID, for example map_put() or start_scroll(). A FileID can also be assigned to the local variable file of a process or function, which will make the process in question look in that file (FPG) for the graphic, associated with the GraphID specified by the process\u0026rsquo; graph local variable.\nNotes You can fill out 0 for the FileID to target the system file, for graphics with an ID of 1000 or higher, which are graphics created on the fly.\nExample Program files; Global int file_id; Begin // Load FPG file_id = load_fpg(\u0026quot;example.fpg\u0026quot;); // Set locals for display of graph file = file_id; graph = 1; x = y = 50; Repeat frame; Until(key(_frame)) End  Used in example: load_fpg(), key(), file, graph\nCategory:general\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fileid/","title":""},{"contents":" category:variables category:predefined category:global variables category:mod_dir\nUp to Global Variables\nDefinition Struct Fileinfo\nFileinfo is a global variable struct, containing information about a file/directory entry, lastly returned by glob().\nMembers Member name - Description STRING path - The path to the file/directory (without the name of the file/directory). STRING name - The name of the file/directory. INT directory - true/false: whether the file/directory is a directory or not INT hidden - true/false: whether the file is hidden or not INT readonly - true/false: whether the file is read only or not INT size - The size in bytes of the file/directory. STRING created - The date when the file/directory was created. *. Not available in Unix/Linux** STRING modified - The date when the file/directory was last modified. * STRING accessed - The date when the file/directory was last accessed. * STRING statechg - The date when the file/directory\u0026rsquo;s inode was last modified. *. Only in Unix/Linux**\n* - The strings created and modified are in the format: DD/MM/YYYY hh:mm.\n** - In Unix/Linux the creation time is not stored. Instead it has a change time (ctime) that indicate when changes to the file or directory\u0026rsquo;s inode (owner, permissions, etc.) were made.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fileinfo/","title":""},{"contents":" Definition Bennu knows multiple filetypes.\nList  category = filetypes mode = userformat columns = 1 listseparators = ,\\n* %TITLE%,, redirects = include ordermethod = titlewithoutnamespace resultsfooter = \\n%PAGES% filetypes \nCategory:General\n","permalink":"https://divhub.github.io/pixtudio-website/docs/filetypes/","title":""},{"contents":" Definition INT filter ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; , \u0026lt;POINTER filter_table\u0026gt; )\nThis function allows the colors of a graphic to be filtered with a nummerical range, defined as an array.\nParameters INT fileID - The fileID of the file that holds the graphics. INT graphID - The graphID of the graphic. POINTER fileter_table - Pointer to a table array with values that are applied to the graphic).\nReturns INT\n0 - Invalid graphic or non 16bit graphic used. 1 - Success.\nExample /* Example converted from bennupack, fenix test section, 2 Medium\\fenix test\\Fenix Test3\\Test_FILTER.prg */ // import modules IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_map\u0026quot;; IMPORT \u0026quot;mod_effects\u0026quot;; IMPORT \u0026quot;mod_proc\u0026quot;; IMPORT \u0026quot;mod_grproc\u0026quot;; IMPORT \u0026quot;mod_map\u0026quot;; IMPORT \u0026quot;mod_key\u0026quot;; IMPORT \u0026quot;mod_video\u0026quot;; IMPORT \u0026quot;mod_screen\u0026quot;; GLOBAL int fpg; int png; int filter[]=8,20,3,4,5,6,7,8,9,70; //int filter[]=448,20,3,4,5,6,7,8,9,70,255,344,255,1,0,0; //int filter[]=5,30,20,40,60,80,100,1,1,2,3; PROCESS main(); BEGIN scale_mode=scale_normal2x; set_mode(320,200,mode_16bits); fpg=load_fpg(\u0026quot;FPG2.FPG\u0026quot;); png=load_png(\u0026quot;PNG-1.PNG\u0026quot;); say(\u0026quot;Filter test...\u0026quot;); say(\u0026quot;Press ESC to quit...\u0026quot;); put_screen(fpg,1); bola(100,100,\u0026quot;Normal\u0026quot;,0); bola(200,100,\u0026quot;Filtered\u0026quot;,1); REPEAT FRAME; UNTIL (key(_esc)) let_me_alone(); END PROCESS bola(int x,int y,string txt,int use_filter); BEGIN say(txt); size=200; graph=map_clone(0,png); IF (use_filter==TRUE) filter(0,graph,\u0026amp;filter); END LOOP FRAME; END END  Category:functions Category:graphical effects Category:mod_effects\n","permalink":"https://divhub.github.io/pixtudio-website/docs/filter/","title":""},{"contents":" Definition INT find ( \u0026lt;STRING str\u0026gt; , \u0026lt;STRING searchstring\u0026gt; , [\u0026lt;INT startposition\u0026gt;] )\nReturns the position of the firstly found appearance of a searchstring in str or -1 if not found. The starting position can be specified optionally.\nParameters STRING str - The string in which to search. STRING searchstring - The string to search for. [INT startposition] - The position at which to start searching. Default is 0.\nReturns INT : The position of the firstly found appearance of searchstring in str or -1 if not found.\nExample In this example there\u0026rsquo;s a very long string in wich we\u0026rsquo;re going to look for 10 strings. Some of these are found (when the result is \u0026gt; -1), and others are deliberately bogus to show how you can detect if a string is not found. What you\u0026rsquo;ll see, is that when you specify a start position greater then 0, and the word exists but your start position is behind the actual position of the first character of the word you\u0026rsquo;re looking for, the function returns -1 (no match). If you specify 0 (the start of the string), you\u0026rsquo;ll be safe, because it will return the fist occurance of the word or character when it exists in the string.\nAs you can see, the working of the find function works very similarly to the find and search/replace function that you get in most text editors.\n#IFdef __VERSION__ IMPORT \u0026quot;mod_video\u0026quot;; IMPORT \u0026quot;mod_text\u0026quot;; IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_key\u0026quot;; IMPORT \u0026quot;mod_string\u0026quot;; IMPORT \u0026quot;mod_proc\u0026quot;; IMPORT \u0026quot;mod_map\u0026quot;; IMPORT \u0026quot;mod_draw\u0026quot;; IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_sys\u0026quot;; IMPORT \u0026quot;mod_wm\u0026quot;; #ENDIF GLOBAL /* this is the big string in wich we're going to try the find() function on with a couple of tests. */ string string_to_find_in = \u0026quot;hello, world! this is a very long string in wich the 'find' function must find another string. let's try a few things.\u0026quot;; /* these are the strings we're going to test. */ string search_string0 = \u0026quot;wich\u0026quot;; string search_string1 = \u0026quot;wich\u0026quot;; string search_string2 = \u0026quot;.\u0026quot;; string search_string3 = \u0026quot;str\u0026quot;; string search_string4 = \u0026quot;hello\u0026quot;; string search_string5 = \u0026quot;find\u0026quot;; string search_string6 = \u0026quot;i don't exist in the string\u0026quot;; string search_string7 = \u0026quot;me neither\u0026quot;; string search_string8 = \u0026quot;must\u0026quot;; string search_string9 = \u0026quot;a\u0026quot;; /* return values for the tests. a return value of \u0026quot;-1\u0026quot; means that the string could not be found. */ int find_result0; int find_result1; int find_result2; int find_result3; int find_result4; int find_result5; int find_result6; int find_result7; int find_result8; int find_result9; /* we store the find positions here. */ int find_pos0; int find_pos1; int find_pos2; int find_pos3; int find_pos4; int find_pos5; int find_pos6; int find_pos7; int find_pos8; int find_pos9; PRIVATE PROCESS main (); PRIVATE BEGIN /* experiment with these to try different results. */ find_pos0 = 0; find_pos1 = 45; find_pos2 = 118; find_pos3 = 0; find_pos4 = 0; find_pos5 = 70; find_pos6 = 0; find_pos7 = 0; find_pos8 = 94; find_pos9 = 94; /* INT find ( \u0026lt;STRING str\u0026gt; , \u0026lt;STRING searchstring\u0026gt; , [\u0026lt;INT startposition\u0026gt;] ); */ find_result0 = find (string_to_find_in, search_string0, find_pos0); /* search_string0 = \u0026quot;wich\u0026quot;; */ find_result1 = find (string_to_find_in, search_string1, find_pos1); /* search_string1 = \u0026quot;wich\u0026quot;; */ find_result2 = find (string_to_find_in, search_string2, find_pos2); /* search_string2 = \u0026quot;.\u0026quot;; */ find_result3 = find (string_to_find_in, search_string3, find_pos3); /* search_string3 = \u0026quot;str\u0026quot;; */ find_result4 = find (string_to_find_in, search_string4, find_pos4); /* search_string4 = \u0026quot;hello\u0026quot;; */ find_result5 = find (string_to_find_in, search_string5, find_pos5); /* search_string5 = \u0026quot;find\u0026quot;; */ find_result6 = find (string_to_find_in, search_string6, find_pos6); /* search_string6 = \u0026quot;i don't exist in the string\u0026quot;; */ find_result7 = find (string_to_find_in, search_string7, find_pos7); /* search_string7 = \u0026quot;me neither\u0026quot;; */ find_result8 = find (string_to_find_in, search_string8, find_pos8); /* search_string8 = \u0026quot;must\u0026quot;; */ find_result9 = find (string_to_find_in, search_string9, find_pos9); /* search_string9 = \u0026quot;a\u0026quot;; */ /* \u0026quot;hello, world! this is a very long string in wich the 'find' function must find another string. let's try a few things.\u0026quot;; | | char pos:0 118 */ /* display the results in the console. */ say(\u0026quot;\u0026quot;); say(\u0026quot;looking for: '\u0026quot;+search_string0+\u0026quot;'\u0026quot;); say (\u0026quot;search_string0 result: \u0026quot;+find_result0); IF (find_result0 == -1) say (\u0026quot;no match for: '\u0026quot;+search_string0+\u0026quot;' at the indicated position: \u0026quot;+find_pos0); ELSE say (\u0026quot;'\u0026quot;+search_string0+\u0026quot;'\u0026quot;+\u0026quot; found at position: \u0026quot;+find_result0); END say(\u0026quot;\u0026quot;); say(\u0026quot;looking for: '\u0026quot;+search_string1+\u0026quot;'\u0026quot;); say (\u0026quot;search_string1 result: \u0026quot;+find_result1); IF (find_result1 == -1) say (\u0026quot;no match for: '\u0026quot;+search_string1+\u0026quot;' at the indicated position: \u0026quot;+find_pos1); ELSE say (\u0026quot;'\u0026quot;+search_string1+\u0026quot;'\u0026quot;+\u0026quot; found at position: \u0026quot;+find_result1); END say(\u0026quot;\u0026quot;); say(\u0026quot;looking for: '\u0026quot;+search_string2+\u0026quot;'\u0026quot;); say (\u0026quot;search_string2 result: \u0026quot;+find_result2); IF (find_result2 == -1) say (\u0026quot;no match for: '\u0026quot;+search_string2+\u0026quot;' at the indicated position: \u0026quot;+find_pos2); ELSE say (\u0026quot;'\u0026quot;+search_string2+\u0026quot;'\u0026quot;+\u0026quot; found at position: \u0026quot;+find_result2); END say(\u0026quot;\u0026quot;); say(\u0026quot;looking for: '\u0026quot;+search_string3+\u0026quot;'\u0026quot;); say (\u0026quot;search_string3 result: \u0026quot;+find_result3); IF (find_result3 == -1) say (\u0026quot;no match for: '\u0026quot;+search_string3+\u0026quot;' at the indicated position: \u0026quot;+find_pos3); ELSE say (\u0026quot;'\u0026quot;+search_string3+\u0026quot;'\u0026quot;+\u0026quot; found at position: \u0026quot;+find_result3); END say(\u0026quot;\u0026quot;); say(\u0026quot;looking for: '\u0026quot;+search_string4+\u0026quot;'\u0026quot;); say (\u0026quot;search_string4 result: \u0026quot;+find_result4); IF (find_result4 == -1) say (\u0026quot;no match for: '\u0026quot;+search_string4+\u0026quot;' at the indicated position: \u0026quot;+find_pos4); ELSE say (\u0026quot;'\u0026quot;+search_string4+\u0026quot;'\u0026quot;+\u0026quot; found at position: \u0026quot;+find_result4); END say(\u0026quot;\u0026quot;); say(\u0026quot;looking for: '\u0026quot;+search_string5+\u0026quot;'\u0026quot;); say (\u0026quot;search_string5 result: \u0026quot;+find_result5); IF (find_result5 == -1) say (\u0026quot;no match for: '\u0026quot;+search_string5+\u0026quot;' at the indicated position: \u0026quot;+find_pos5); ELSE say (\u0026quot;'\u0026quot;+search_string5+\u0026quot;'\u0026quot;+\u0026quot; found at position: \u0026quot;+find_result5); END say(\u0026quot;\u0026quot;); say(\u0026quot;looking for: '\u0026quot;+search_string6+\u0026quot;'\u0026quot;); say (\u0026quot;search_string6 result: \u0026quot;+find_result6); IF (find_result6 == -1) say (\u0026quot;no match for: '\u0026quot;+search_string6+\u0026quot;' at the indicated position: \u0026quot;+find_pos6); ELSE say (\u0026quot;'\u0026quot;+search_string6+\u0026quot;'\u0026quot;+\u0026quot; found at position: \u0026quot;+find_result6); END say(\u0026quot;\u0026quot;); say(\u0026quot;looking for: '\u0026quot;+search_string7+\u0026quot;'\u0026quot;); say (\u0026quot;search_string7 result: \u0026quot;+find_result7); IF (find_result7 == -1) say (\u0026quot;no match for: '\u0026quot;+search_string7+\u0026quot;' at the indicated position: \u0026quot;+find_pos7); ELSE say (\u0026quot;'\u0026quot;+search_string7+\u0026quot;'\u0026quot;+\u0026quot; found at position: \u0026quot;+find_result7); END say(\u0026quot;\u0026quot;); say(\u0026quot;looking for: '\u0026quot;+search_string8+\u0026quot;'\u0026quot;); say (\u0026quot;search_string8 result: \u0026quot;+find_result8); IF (find_result8 == -1) say (\u0026quot;no match for: '\u0026quot;+search_string8+\u0026quot;' at the indicated position: \u0026quot;+find_pos8); ELSE say (\u0026quot;'\u0026quot;+search_string8+\u0026quot;'\u0026quot;+\u0026quot; found at position: \u0026quot;+find_result8); END say(\u0026quot;\u0026quot;); say(\u0026quot;looking for: '\u0026quot;+search_string9+\u0026quot;'\u0026quot;); say (\u0026quot;search_string9 result: \u0026quot;+find_result9); IF (find_result9 == -1) say (\u0026quot;no match for: '\u0026quot;+search_string9+\u0026quot;' at the indicated position: \u0026quot;+find_pos9); ELSE say (\u0026quot;'\u0026quot;+search_string9+\u0026quot;'\u0026quot;+\u0026quot; found at position: \u0026quot;+find_result9); END END  Notes A first character of a string is at position 0.\nCategory:functions Category:strings Category:mod_string\n","permalink":"https://divhub.github.io/pixtudio-website/docs/find/","title":""},{"contents":" Syntax INT Finite ( \u0026lt;FLOAT number\u0026gt; )\nDescription Checks if a given value is a finite number. This function is the opposite of the Isinf() function. It does not check for Not-A-Numbers. Use the Isnan() function for that.\nParameters FLOAT number - The value to check.\nReturns INT FALSE - The value is an infinity. INT TRUE - The value is a finite number.\nSee also Wikipedia page about the mathematical subject infinity.\nCategory:functions Category:math Category:mod_math\n","permalink":"https://divhub.github.io/pixtudio-website/docs/finite/","title":""},{"contents":" category:variables category:predefined category:local variables category:librender\nUp to Local Variables\nDefinition INT flags = 0\nFlags is a predefined local variable which is used to manipulate how the graphic of a process, assigned to its local variable graph, is displayed.\nTo alter the effect, change the value of this local variable by assigning it blit flags. Like most bit flags, constants can be added together to combine effects. A horizontally mirrored translucent graphic would need flags B_TRANSLUCENT (4) and B_HMIRROR (1), so flags = B_TRANSLUCENT|B_HMIRROR (5) will do the trick.\nExample To make the graphic of a process spin:\nProgram mirror Begin mirror_graphic(); Loop frame; End End Process mirror_graphic() Begin graph = new_map(50,50,8); map_clear(0,graph,rgb(0,255,255)); x = 100; //Position the graphic 100 pixels y = 100; //from the top and left of the screen Loop if (key(_l)) flags = B_HMIRROR; //if you press the L key, your graphic is horizontally mirrored else flags = 0; end frame; End End  The process will mirror its graphic when the key L is held down.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/flags/","title":""},{"contents":" Definition INT flength ( \u0026lt;INT filehandle\u0026gt; )\nGives back the size of a certain file.\nParameters INT filehandle - The FileHandle of the file returned by fopen().\nReturns INT: The size of the file in bytes.\nCategory:functions Category:files Category:mod_file\n","permalink":"https://divhub.github.io/pixtudio-website/docs/flength/","title":""},{"contents":" Definition FLOAT\nFloats are floating point numbers ranging from about -10^38.53 to about 10^38.53. This is achieved by dividing 32 bits (4 bytes) in a certain way, with a certain precision. A float is used for operations in which both very large and small numbers are used, while rounding is not permitted. Unlike ints or shorts, a float actually has decimal digits. Their accuracy is about 7 decimal digits.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/float/","title":""},{"contents":" Definition INT fmove ( \u0026lt;STRING source_file\u0026gt;, \u0026lt;STRING target_file\u0026gt; )\nRenames files, from the bennu source code: files.c.\nParameters STRING source_file - The source file. STRING target_file - The target file.\nReturns INT : true/false: the status result of the action.\ntrue - The action was a success. false - The action failed.\nCategory:functions Category:files Category:mod_file\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fmove/","title":""},{"contents":" Header Name Size (Bytes) Description\nMagic 3 character string that must containg \u0026ldquo;fnx\u0026rdquo; MSDOS-END 4 the four bytes 1Ah,0Dh,0Ah,00h Bits Per Pixel 1 Font color depht can be equal to: 1,8,16,32 Colors Palette 768 256 RGB colors using 1 byte for each component where the two first bits are ignored, so a component can be from 0 to 63 value. Color Gamuts 576 16 color gamuts (sutsets of colors) useful to quickly paint.NOTE: currenly ignored charset 4 Characters set, can be 0 or 1 to ISO8859 or CP850.\nNow goes 256 character Descriptors. one for each ASCII letter\nCharacters Desciptor Name Size (Bytes) Description\nwidth 4\nheight 4\nwidth offset 4\nheight offset 4\nhorizontal offset 4\nvertical offset 4\ndata offset 4\nAnd finaly the graphics data\nGraphics Data The size of each graphic will be width * height * bits_per_pixel / 8, except to 1 bit that use a rounded byte line formula, round(width/8)*8 * height. To optain the exact position you need use the data offset stored in the descriptor of each data.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fnt_format/","title":""},{"contents":" Definition INT fnt_load ( \u0026lt;STRING filename\u0026gt;, [ \u0026lt;POINTER id\u0026gt;] )\nLoads a FNT file into memory as a font. A font is usually with the extension .fnt.\nThe previous name load_fnt() is deprecated.\nParameters STRING filename - The filename of the FNT file that you wish to load (including extension and possible path). POINTER id - Optional parameter, for loading a font in the background.\nReturns INT : graphID\n-2 - Waiting for the file to be loaded, see notes. -1 - There was an error loading the file. \u0026gt;=0 - The graphID of the newly created font.\nthe following applies for versions prior rc282:\nINT : FontID\n-1 - Error: file does not exist. 0 - Filename could not be obtained from the specified string (doesn\u0026rsquo;t happen usually). \u0026gt;0 - The FontID.\nErrors Format not recognized - The format of the specified file could not be recognized.\nNotes The optional parameter id was introduced in version rc282 and allows you to load resources in the background. It used with the Offset operator. See example below:\n load_fnt(\u0026quot;archivo_gordo.fnt\u0026quot;, \u0026amp;idfnt); while(idfnt==-2) say(\u0026quot;Big File Loading ....\u0026quot;); frame; end if(idfnt==-1) say(\u0026quot;Something went wrong!!\u0026quot;); exit(); // o return end say(\u0026quot;Big file loaded ok!!\u0026quot;);  Category:functions Category:fonts Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fnt_load/","title":""},{"contents":" Definition INT fnt_new ( \u0026lt;INT depth\u0026gt; )\nCreates a new font with a certain color depth. There exists three variants of this function:\n INT fnt_new ( \u0026lt;INT depth\u0026gt; )\n INT fnt_new ( \u0026lt;INT charset\u0026gt; , \u0026lt;INT depth\u0026gt; )\n INT fnt_new ( \u0026lt;INT file\u0026gt; , \u0026lt;INT graph\u0026gt;, \u0026lt;INT charset\u0026gt; , \u0026lt;INT width\u0026gt; , \u0026lt;INT height\u0026gt; , \u0026lt;INT first\u0026gt; , \u0026lt;INT last\u0026gt; , \u0026lt;INT flags\u0026gt; )\n The first variant is a simple version wich uses the systemfont and the CP850 character set.\n The second version allows the user to select a different characterset.\n The third function allows custom fonts to made, from bitmaps in memory. It is similair to DIV gamestudio\u0026rsquo;s font generator. In this variant, the depth cannot be set.\n  The previous name new_fnt() is deprecated.\nParameters INT charset - The color characterset of the font, CHARSET_ISO8859 or CHARSET_CP850. INT depth - The color depth of the glyphs of the font. INT file - The fileID of the file wich contains the bitmaps with the letters. INT graph - The graphID of the bitmap wich contains the character set. INT width - The width of the glyph. INT height - The height of the glyph. INT first - The first character. INT last - The last character. INT flags - The kind of glyph width, NFB_VARIABLEWIDTH or NFB_FIXEDWIDTH.\nReturns INT : FontID\n-1 - Error: could not create font. \u0026gt;=0 - The FontID.\nErrors Insufficient memory - There is insufficient memory available. This error doesn\u0026rsquo;t occur often. Too many fonts - There are too many fonts loaded (255).\nExample IMPORT \u0026quot;mod_video\u0026quot;; IMPORT \u0026quot;mod_wm\u0026quot;; IMPORT \u0026quot;mod_text\u0026quot;; IMPORT \u0026quot;mod_map\u0026quot;; IMPORT \u0026quot;mod_key\u0026quot;; GLOBAL int a; int b; int c; int graph_id; int font_id1; int font_id2; PROCESS main(); BEGIN set_mode(640,480); graph_id=png_load(\u0026quot;font.png\u0026quot;); // new font, variable width font_id1=fnt_new(0,graph_id,CHARSET_ISO8859,16,16,0,255,NFB_VARIABLEWIDTH); write_int(font_id1,0,0,0,\u0026amp;a); write_int(font_id1,0,20,0,\u0026amp;b); write_int(font_id1,0,40,0,\u0026amp;c); write(font_id1,0,60,0,\u0026quot;hello world!\u0026quot;); // new font, fixed width font_id2=fnt_new(0,graph_id,CHARSET_ISO8859,16,16,0,255,NFB_FIXEDWIDTH); write_int(font_id2,0,100,0,\u0026amp;a); write_int(font_id2,0,120,0,\u0026amp;b); write_int(font_id2,0,140,0,\u0026amp;c); write(font_id2,0,160,0,\u0026quot;hello world!\u0026quot;); // write texts in standard system font write_int(0,320,0,0,\u0026amp;a); write_int(0,320,20,0,\u0026amp;b); write_int(0,320,40,0,\u0026amp;c); write(0,320,60,0,\u0026quot;hello world!\u0026quot;); WHILE (NOT key(_ESC) AND NOT exit_status) a++; b--; c*=2; IF (c==0) c=1; END FRAME; END END  Used in example: Png_load(), Write(), Write_int()\nNotes If only one argument is used, the CP850 character set is used. The charactermap is a bitmap, with the characters arranged in a grid. See this post\nCategory:functions Category:fonts Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fnt_new/","title":""},{"contents":" Definition INT fnt_save ( \u0026lt;INT fontID\u0026gt; , \u0026lt;STRING filename\u0026gt; )\nSaves a font as a file. A font is usually with the extension \u0026ldquo;.fnt\u0026rdquo;.\nIf the specified filename contains no extension, \u0026ldquo;.fnt\u0026rdquo; is added to it.\nThe previous name save_fnt() is deprecated.\nParameters INT fontID - The fontID of the font to be saved. STRING filename - The name of the font file to be saved, including a possible path.\nReturns INT : Successrate\nfalse - Filename could not be obtained from the specified string (doesn\u0026rsquo;t happen usually) or one of the errors. true - Font successfully saved.\nErrors Invalid fontID - The specified fontID was invalid. Unable to create file - The file could not be created. Font corrupt - The font trying to be saved is corrupt. Insufficient memory - There is insufficient memory available. This error doesn\u0026rsquo;t occur often.\nCategory:functions Category:fonts Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fnt_save/","title":""},{"contents":" Definition INT fnt_unload ( \u0026lt;INT fontID\u0026gt; )\nUnloads the specified font from memory.\nThe previous name unload_fnt() is deprecated.\nParameters INT fontID - The fontID of the file to unload.\nReturns INT : false\nCategory:functions Category:Fonts Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fnt_unload/","title":""},{"contents":" category:variables category:predefined category:global variables category:libwm\nUp to Global Variables\nDefinition INT focus_status\nfocus_status is a predefined global variable, holding whether or not the Bennu window has input focus.\nValue - Description false - The Bennu window does not have input focus. true - The Bennu window has input focus.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/focus_status/","title":""},{"contents":" Definition A font is a way of displaying text. A font is associated with a certain fontID.\nCategory:general Category:texts\n","permalink":"https://divhub.github.io/pixtudio-website/docs/font/","title":""},{"contents":" Definition FontID\nA FontID is an identifier associated with a certain font. It is returned by functions that load fonts, for example load_fnt(). You can use the FontID in functions to specify the font used in the writing of texts like write(), write_int(), write_float(), write_string(), write_var() and write_in_map().\nNotes Font \u0026ldquo;0\u0026rdquo; is the built-in font, and can be used in functions as well.\nExample import \u0026quot;mod_text\u0026quot; import \u0026quot;mod_key\u0026quot; Global My_font; End Process Main() Begin //Using the built-in font: My_font=0; Write(My_font,320/2,200/2,4,\u0026quot;Game programming is awesome!\u0026quot;); Repeat frame; Until(key(_ESC)) End  Used in example: write(), key()\nThis will result in something like:\nCategory:general Category:Texts\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fontid/","title":""},{"contents":" Definition INT fopen ( \u0026lt;STRING filename\u0026gt; , \u0026lt;INT mode\u0026gt; )\nOpens a file on the hard drive for reading or writing.\nParameters STRING filename - The filename of the file you wish to open (including extension and possible path). INT mode - The mode with which to access the file (see Readwrite_modes).\nReturns INT : FileHandle\n0 - Could not load. !0 - The identifier of the file now opened for reading/writing.\nExample Process loadthing(STRING loadpath); Private int handle; // handle for the loaded file int druppels; // here's where the loaded data go Begin handle=fopen(loadpath,O_READ); // opens the file in reading mode fread(handle,druppels); // reads from the file and puts the data in druppels fclose(handle); // zipping up after business is done write(0,0,0,0,druppels); // shows the value of druppels End  Used in example: fread(), fclose(), write()\nCategory:functions Category:files Category:mod_file\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fopen/","title":""},{"contents":" Definition STRING format ( \u0026lt;INT number\u0026gt; )\nSTRING format ( \u0026lt;FLOAT number\u0026gt; )\nSTRING format ( \u0026lt;FLOAT number\u0026gt;, \u0026lt;INT number\u0026gt;)\nFormats nummerical data for use in a string. There are three variants of this function, the first one only formats integers, the second one a floating point number, and the third one uses a fixed number of decimals, as given with the second parameter.\nParameters INT str - The number to format.\nFLOAT str - The decimal number to format.\nReturns STRING : The string with the fomatted number.\nExample // import modules IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_string\u0026quot;; GLOBAL int count=400000; float count2=2.50000; float count3=456.0000; PROCESS main(); BEGIN say(\u0026quot;format test.\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); say(format(count)); say(format(count2)); say(format(count3)); say(format(count2,0)); say(format(count2,1)); say(format(count2,2)); say(format(count2,3)); say(format(count3,0)); say(format(count3,1)); say(format(count3,2)); say(format(count3,3)); END  The program outputs this list:\n400,000 2.500000 456.000000 3 2.5 2.50 2.500 456 456.0 456.00 456.000  Notes The format function seems to like US number formats, even on a european machine.\nCategory:functions Category:strings Category:mod_string\n","permalink":"https://divhub.github.io/pixtudio-website/docs/format/","title":""},{"contents":"good post thx 395 chiladze\n","permalink":"https://divhub.github.io/pixtudio-website/docs/forum/","title":""},{"contents":" Definition INT fpg_add ( \u0026lt;INT destFileID\u0026gt; , \u0026lt;INT destGraphID\u0026gt; , \u0026lt;INT origFileID\u0026gt; , \u0026lt;INT origGraphID\u0026gt; )\nCopies a certain graphic in a certain file to a certain file with a certain graphID.\nParameters INT destFileID - The fileID of the destination file. INT destGraphID - The graphID in the destination file where to add the graphic. INT origFileID - The fileID of the original file where the graphic is located. INT origGraphID - The graphID of the graphic to add.\nReturns INT : graphID\n-1 - Invalid destination file or graphID. 0 - Invalid original file or graphID. \u0026gt;0 - The GraphID of the destination graphic.\nCategory:functions Category:fpg Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fpg_add/","title":""},{"contents":" Definition INT fpg_exists ( \u0026lt;INT FileID\u0026gt; )\nChecks if an FPG exists with the specified FileID.\nParameters INT FileID - The FileID of the File to check for existence.\nReturns INT : Whether the File exists\nfalse - The specified File does not exist. true - The specified File exists.\nCategory:functions Category:fpg Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fpg_exists/","title":""},{"contents":" Definition INT fpg_load ( \u0026lt;STRING filename\u0026gt;, [\u0026lt;INT POINTER\u0026gt; complete\u0026gt;] )\nLoads a graphics library into your program.\nThis function loads the whole contents of an FPG graphics library into your project, enabling the contained graphics to be used in your program as process\u0026rsquo; graphs, screen backgrounds (put_screen()) or other graphics.\nThe previous name load_fpg() is deprecated.\nParameters STRING filename - The filename of the FPG that you wish to load (including extension and possible path). [INT POINTER complete] - If this argument is specified the FPG is loaded asynchroneous, setting complete to FileID on completion.\nReturns INT : graphID\n-2 - Waiting for the file to be loaded, see notes. -1 - There was an error loading the file. \u0026gt;=0 - The FileID assigned to the archive.\nthe following applies for versions prior rc282:\nINT : FileID\n-1 - The specified archive could not be loaded. \u0026gt;=0 - The FileID assigned to the archive.\nErrors Archive not found - The specified archive could not be found.\nNotes Using an FPG file to contain all or some of the graphics used in a Bennu program is convenient, but isn\u0026rsquo;t always the best way to load graphics. Other methods of loading graphics into your program include load_map() and load_png() which load individual graphic files. Graphics loaded individually will be given FileID 0 and a GraphID starting at 1000. This is because mod_map reserves room for the first FPG loaded (FPG files can contain 999 different graphics max.), sometimes referred to as the system file or environment file.\nThe first FPG file loaded using mod_map returns and uses the FileID 0, which is reserved by mod_map for use as the system file. All extra FPG files loaded will have a different FileID, progressing from 1 upwards.\nAn FPG file holds all its contained graphs in memory simultaneously. Having a lot of large graphs being read from a single FPG file at once has been known to cause a slowdown.\nOnce an FPG file is no longer necessary to be held in the memory, its memory space can be released by using the function unload_fpg(). It is not necessary to unload files at the termination of a program, as Bennu always releases all used memory at the end of program execution.\nNotes The optional parameter id was introduced in version rc282 and allows you to load resources in the background. It used with the Offset operator. See example below:\n load_fpg(\u0026quot;archivo_gordo.fpg\u0026quot;, \u0026amp;idFpg); while(idFpg==-2) say(\u0026quot;Big File Loading ....\u0026quot;); frame; end if(idFpg==-1) say(\u0026quot;Something went wrong!!\u0026quot;); exit(); // o return end say(\u0026quot;Big file loaded ok!!\u0026quot;); file=idFpg; graph = 7;  Example Program example; Global int my_fpg; Begin my_fpg=load_fpg(\u0026quot;test.fpg\u0026quot;); //Loads the FPG file into memory put_screen(my_fpg,1); //Puts graphic with code 1 onto screen Repeat frame; Until(key(_esc)) unload_fpg(my_fpg); End  Used in example: put_screen(), unload_fpg()\nCategory:functions Category:fpg Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fpg_load/","title":""},{"contents":" Definition INT fpg_new ( )\nCreates and initializes a new file.\nTo add graphics to the created file, use the returned fileID in the function fpg_add(). The file can be saved with fpg_save(). To free a file, use fpg_unload().\nThe previous name new_fpg() is deprecated.\nReturns INT : fileID\n-1 - Too many files or insufficient memory. \u0026gt;=0 - The fileID of the new file.\nErrors Insufficient memory - There is insufficient memory available. This error doesn\u0026rsquo;t occur often.\nCategory:functions Category:fpg Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fpg_new/","title":""},{"contents":" Definition INT fpg_save( \u0026lt;INT fileID\u0026gt; , \u0026lt;STRING filename\u0026gt; )\nSaves a certain file to disk.\nThe previous name save_fpg() is deprecated.\nParameters INT fileID - The fileID of the file to save. STRING filename - The name of the file to be saved, including a possible path.\nReturns INT : Success\nfalse - Invalid fileID or filename; The errors under Errors. true - Success.\nErrors Insufficient memory - There is insufficient memory available. This error doesn\u0026rsquo;t occur often. Empty library - The specified file contains no graphics. Unsupported color depth - A graphic in the specified file has an unsupported color depth. Differing color depths - An FPG can\u0026rsquo;t hold graphics of different color depths.\nCategory:functions Category:fpg Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fpg_save/","title":""},{"contents":" Definition INT fpg_unload ( \u0026lt;INT fileID\u0026gt; )\nUnloads a certain file from memory.\nAlso called fpg_del(). The previous name unload_fpg() is deprecated.\nParameters INT fileID - The fileID of the file to unload.\nReturns INT : true\nCategory:functions Category:fpg Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fpg_unload/","title":""},{"contents":" category:utilities\nDefinition FPG Tool created in Fenix by the Fenix Team. 0.84a was used for coding and compiling, so Fenix 0.84a interpreter is included. Also used was GUI.DLL.\nSource included.\nDownload Download here.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fpgtool/","title":""},{"contents":" Definition Fenix palette file.\nSee Also  load_fpl() save_fpl()  Category:filetypes\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fpl/","title":""},{"contents":" category:general category:variables category:predefined category:global variables category:librender\nUp to Global Variables\nDefinition INT fps\nThe global variable fps holds the current frames per second on which Bennu is running. This means how many times a frame is executed every second and how many times the screen is updated every second.\nIf a different FPS is needed, the target FPS can be altered by use of set_fps().\nIf a more accurate FPS is needed, use frame_time to calculate it.\nIf you need to view the FPS in-game, please use the code (in a loop): write_int(0,0,0,0,\u0026amp;fps);\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fps/","title":""},{"contents":" Definition INT fputs ( \u0026lt;INT filehandle\u0026gt; , \u0026lt;STRING line\u0026gt; )\nWrites a line to a certain file.\nParameters INT filehandle - The FileHandle of the file returned by fopen().\nReturns INT: Number of bytes written.\n0 - There was an error. \u0026gt;0 - Number of bytes written.\nNotes The character \u0026lsquo;\\\u0026rsquo; will be put in front of every newline character, so that fgets() reads the lines like they were written.\nCategory:functions Category:files Category:mod_file\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fputs/","title":""},{"contents":" Syntax Frame [ ( \u0026lt;percentage\u0026gt; ) ] ;\nDescription The frame; command tells the interpreter when a process is done for one game cycle. When the frame; is reached, the screen is updated. If there are several processes running, the screen is updated once every process has reached its frame; statement.\nIt is commonly used in loops of processes that should do something like moving around by a certain amount of pixels per game cycle (or per frame).\nA possibility is to adjust the amount of cycles to wait. frame(100); would wait one cycle (100%), same as frame;. However frame(200); will wait two cycles (200% means the frame statement provides for 200% frame). So frame(50); will wait a half cycle or otherwise said, it will make a loop run twice per frame.\nExample Process Main() Begin square(); Repeat frame; Until(key(_ESC)) exit(); End Process square() Begin graph = new_map(5,5,16); map_clear(0,graph,rgb(255,255,255)); Loop x += 2 * (key(_right)-key(_left)); frame; //\u0026lt;-vital part End End  This example process would give you a square you can move around the screen by 2 pixel before it gets showed again, before the game cycle is over, before the frame; happens. If there would be no frame; in the loop, it would just run forever and the interpreter would wait forever for the frame;, which would result in freezing.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/frame/","title":""},{"contents":" category:variables category:predefined category:global variables category:librender\nUp to Global Variables\nDefinition FLOAT frame_time\nFrame_time is a global variable, holding the time passed the last frame. In other words: the difference in time between the start of the last frame and the current frame.\n Doing a bit of physics, we see that: FPS = 1 / frame_time\n Be advised that frame_time is in milliseconds accurate, so it can be 0 at times, so one might prevent such a case from happening: FPS = 1 / ( frame_time + (frame_time==0)*0.0001 );\n  This gives a sort of FPS which is accurate every frame.\nExample Display how long the program has been running, by use of frame_time:\nProgram timers; Private int ft; // Help variable int i; // how long the program has been running in 1/100s float f; // how long the program has been running in 1/100s Begin set_mode(320,400,8); write_int (0,0,300,0,\u0026amp;timer); write_int (0,0,310,0,\u0026amp;i); write_float (0,0,320,0,\u0026amp;f); Repeat // Calculate how long the program has been running in 1/100s without a float ft %= 10; // keep the milliseconds from last time ft += frame_time*1000; // add the last passed time to it in milliseconds i += ft/10; // add it to the integer without the milliseconds // Calculate how long the program has been running in 1/100s with a float f+=frame_time*100; frame; Until(key(_ESC)) End  Used in example: set_mode(), write_int(), write_float(), key(), timer\nLet a process wait for a certain time by calling this function:\nFunction int wait(float seconds) Begin While( (seconds-=frame_time) \u0026gt; 0 ) frame; End return -seconds; End  This can be done with a timer too, as is displayed here.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/frame_time/","title":""},{"contents":" Definition INT fread ( \u0026lt;INT filehandle\u0026gt; , \u0026lt;VARIABLE data\u0026gt; )\nINT fread ( \u0026lt;VOID POINTER data_pos\u0026gt; , \u0026lt;INT length\u0026gt; , \u0026lt;INT filehandle\u0026gt; )\nReads the information from a file loaded with fopen() to the variable data.\nThe second version reads length bytes to the memory pointed to by data_pos.\nParameters INT filehandle - The FileHandle of the file returned by fopen(). VARIABLE data - The data to read from the file (any type of variable). It will be loaded into this variable. VOID POINTER data_pos - The pointer to which the bytes read will be written to. INT length - The number of bytes to read from the specified file.\nReturns INT : The number of bytes read from the file.\nExample Process loadthing(STRING loadpath); Private int handle; // handle for the loaded file int druppels; // here's where the loaded data go Begin handle=fopen(loadpath,O_READ); // opens the file in reading mode fread(handle,druppels); // reads from the file and puts the data in druppels fclose(handle); // zipping up after business is done write(0,0,0,0,druppels); // shows the value of druppels End  Used in example: fopen(), fclose(), write()\nCategory:functions Category:files Category:mod_file\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fread/","title":""},{"contents":" Definition INT free ( \u0026lt;VOID POINTER data\u0026gt; )\nFrees a block of memory.\nThe pointer used must be a pointer to a previously allocated block of memory, else the behavior of free() is undefined.\nAlso called mem_free().\nParameters VOID POINTER data - Pointer to the block of memory to be freed.\nReturns INT : true\nExample Program example; Private byte pointer pbyte; word pointer pword; int pointer pint; int elements = 10; int i; Begin // Allocate memory pbyte = alloc(elements); pword = alloc(elements*sizeof(word)); pint = alloc(elements*sizeof(int)); // Reset memory to 0's memset (pbyte,0,elements); memsetw(pword,0,elements); // same as memset(pword,0,elements*sizeof(word)); // because value-parameter is 0. memset (pint ,0,elements*sizeof(int)); // There isn't a \u0026quot;memseti()\u0026quot;, so we need to // set the individual bytes to 0. To change // ints to nonzero values, memset() can't be // used easily // Write numbers to bytes and ints for(i=0; i\u0026lt;elements; i++) pbyte[i] = 133; // pbyte[i] is the same as *(pbyte+i) *(pint+i) = 4555; // pint[i] is the same as *(pint+i) end // Write numbers to words memsetw(pword,345,elements); // Show numbers for(i=0; i\u0026lt;elements; i++) say(\u0026quot;byte[\u0026quot;+i+\u0026quot;] = \u0026quot; + *(pbyte+i)); say(\u0026quot;word[\u0026quot;+i+\u0026quot;] = \u0026quot; + pword[i]); say(\u0026quot;int [\u0026quot;+i+\u0026quot;] = \u0026quot; + pint[i]); end Repeat frame; Until(key(_esc)) // Free the used memory free(pbyte); free(pword); free(pint); End  Used in example: alloc(), memset(), memsetw(), sizeof(), say(), free(), pointer\nCategory:functions Category:memory Category:mod_mem\n","permalink":"https://divhub.github.io/pixtudio-website/docs/free/","title":""},{"contents":" Definition INT fremove ( \u0026lt;STRING filename\u0026gt; )\nRemoves (deletes) files, from the bennu source code: files.c.\nParameters STRING filename - The file to remove.\nReturns INT : true/false: the status result of the action.\ntrue - The action was a success. false - The action failed.\nCategory:functions Category:files Category:mod_file\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fremove/","title":""},{"contents":" Definition UNDEFINED frewind ( \u0026lt;INT filehandle\u0026gt; )\nSets the byte offset (reading position) to the begin of a certain file. This is similair to using:\nfseek(file_id,0,SEEK_SET);  Parameters INT filehandle - The FileHandle of the file returned by fopen().\nReturns INT\n1 - The begin position of the file.\nSee also fseek()\nCategory:functions Category:files Category:mod_file\n","permalink":"https://divhub.github.io/pixtudio-website/docs/frewind/","title":""},{"contents":" Definition INT fseek ( \u0026lt;INT filehandle\u0026gt; , \u0026lt;INT position\u0026gt; , \u0026lt;INT seek_mode\u0026gt; )\nSets the byte offset (reading position) of a certain file. This means where a function will start reading in that file.\nParameters INT filehandle - The FileHandle of the file returned by fopen(). INT position - Number of bytes from the point indicated by seek_mode. INT seek_mode - Set the offset relative to a certain point (see seek modes).\nReturns INT: The new reading position.\nCategory:functions Category:files Category:mod_file\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fseek/","title":""},{"contents":" Definition INT ftell ( \u0026lt;INT filehandle\u0026gt; )\nReturns the current reading position of a certain file.\nThe reading position can be altered by fseek().\nParameters INT filehandle - The FileHandle of the file returned by fopen().\nReturns INT: The current reading position of the specified file.\nCategory:functions Category:files Category:mod_file\n","permalink":"https://divhub.github.io/pixtudio-website/docs/ftell/","title":""},{"contents":" Syntax STRING ftime ( \u0026lt;STRING format\u0026gt; , \u0026lt;INT time\u0026gt; )\nDescription Puts a certain time in a certain format.\nIt returns the specified string, with certain keywords replaced with their corresponding values, according to the specified time (see Notes). The current time is fetched by use of the function time().\nParameters STRING format - The format wanted. INT time - The time to be put in the formatted string.\nReturns STRING : The formatted string.\nNotes A list of keywords:\nKeyword - Replaced by %a - the locale\u0026rsquo;s abbreviated weekday name. %A - the locale\u0026rsquo;s full weekday name. %b - the locale\u0026rsquo;s abbreviated month name. %B - the locale\u0026rsquo;s full month name. %c - the locale\u0026rsquo;s appropriate date and time representation. %C - the century number (the year divided by 100 and truncated to an integer) as a decimal number [00-99]. %d - the day of the month as a decimal number [01,31]. %D - the same as %m/%d/%y. %e - the day of the month as a decimal number [1,31]; a single digit is preceded by a space. %h - the same as %b. %H - the hour (24-hour clock) as a decimal number [00,23]. %I - the hour (12-hour clock) as a decimal number [01,12]. %j - the day of the year as a decimal number [001,366]. %m - the month as a decimal number [01,12]. %M - the minute as a decimal number [00,59]. %n - a newline character. %p - the locale\u0026rsquo;s equivalent of either a.m. or p.m. %r - the time in a.m. and p.m. notation; in the POSIX locale this is equivalent to %I:%M:%S %p. %R - the time in 24 hour notation (%H:%M). %S - the second as a decimal number [00,61]. %t - a tab character. %T - the time (%H:%M:%S). %u - the weekday as a decimal number [1,7], with 1 representing Monday. %U - the week number of the year (Sunday as the first day of the week) as a decimal number [00,53]. %V - the week number of the year (Monday as the first day of the week) as a decimal number [01,53]. If the week containing 1 January has four or more days in the new year, then it is considered week 1. Otherwise, it is the last week of the previous year, and the next week is week 1. %w - the weekday as a decimal number [0,6], with 0 representing Sunday. %W - the week number of the year (Monday as the first day of the week) as a decimal number [00,53]. All days in a new year preceding the first Monday are considered to be in week 0. %x - the locale\u0026rsquo;s appropriate date representation. %X - the locale\u0026rsquo;s appropriate time representation. %y - the year without century as a decimal number [00,99]. %Y - the year with century as a decimal number. %Z - the timezone name or abbreviation, or by no bytes if no timezone information exists. %% - %.\nExample import \u0026quot;mod_timer\u0026quot; import \u0026quot;mod_time\u0026quot; import \u0026quot;mod_text\u0026quot; import \u0026quot;mod_key\u0026quot; Process Main() Private String timestring; // The string holding the formatted time Begin write_string(0,0,0,0,\u0026amp;timestring); // Display the timestring timer = 100; // Make it so it updates the timestring immediately Repeat if(timer\u0026gt;100) // Update the timestring every 1 second timer = 0; timestring = ftime(\u0026quot;%d-%m-%Y %H:%M:%S\u0026quot;,time()); end frame; Until(key(_esc)) End  Used in example: write_string(), time(), key(), timer\nCategory:functions Category:time Category:mod_time\n","permalink":"https://divhub.github.io/pixtudio-website/docs/ftime/","title":""},{"contents":" Definition STRING ftoa ( \u0026lt;FLOAT value\u0026gt; )\nReturns a string containing a certain float value.\nParameters \u0026rdquo;\u0026lsquo;FLOAT \u0026ldquo;\u0026rsquo; value - The value the returned string will contain.\nReturns STRING : The string containing the specified value, including sign and decimal point.\nCategory:functions Category:strings Category:mod_string\n","permalink":"https://divhub.github.io/pixtudio-website/docs/ftoa/","title":""},{"contents":" category:variables category:predefined category:global variables category:libvideo\nUp to Global Variables\nINT full_screen = false\nDescription full_screen is a predefined global variable. It defines whether Bennu (libvideo to be more precise) will be rendered in windowed (default) or fullscreen mode.\nThe value of full_screen can be changed. false for windowed mode and true for fullscreen mode. For the change to have effect, set_mode() needs to be called afterwards.\nSee also  graph_mode scale_mode  ","permalink":"https://divhub.github.io/pixtudio-website/docs/full_screen/","title":""},{"contents":" Syntax Function \u0026lt;returntype\u0026gt; \u0026lt;name\u0026gt; ( [ \u0026lt;parameters\u0026gt; ] ) [ Public [ \u0026lt;public variables\u0026gt; ] End ] [ Private [ \u0026lt;private variables\u0026gt; ] End ] Begin [ \u0026lt;function code\u0026gt; ] [ OnExit [ \u0026lt;exit code\u0026gt; ] ] End  Description Function is a reserved word used to start the code of a function.\nA function is a subroutine to which one or more of the following apply:\n it receives parameters it acts on the parameters it processes data located elsewhere it returns a value  The difference between a function and a process is that the calling process or function waits until the function is completed. When a process or function calls a process, it doesn\u0026rsquo;t wait. This means that, even when the called function contains frame statements, the calling function or process still waits for the function to finish. This is shown in this tutorial.\nExample  Function int addInts( int a , int b ) Private // Declare private variables here Begin // Start the main functioncode return a+b; End // End the main functioncode  addInts(3,6); will return 9. One can see that the function does indeed:\n receive parameters. act on the parameters. return a value.  ","permalink":"https://divhub.github.io/pixtudio-website/docs/function/","title":""},{"contents":" :Category:functions\nDefinition INT example_function ( \u0026lt;INT example_int\u0026gt; , \u0026lt;WORD example_word\u0026gt; , [\u0026lt;STRING example_string\u0026gt;] )\nDoes something.\nHere goes a more detailed story about the function.\nParameters INT example_int - Something about this int. WORD example_word - Something about this word. [STRING example_string] - Something about this optional string.\nReturns INT : Some int.\nErrors List all errors which could be thrown by use of this function.\nNotes Here are some notes, which explains some parts in more depth.\nExample Program example; Begin Repeat frame; Until(key(_ESC)) End  Used in example:\n","permalink":"https://divhub.github.io/pixtudio-website/docs/function_example/","title":""},{"contents":" category=functions \n","permalink":"https://divhub.github.io/pixtudio-website/docs/functionlist/","title":""},{"contents":"Up to Index\nFunction Categories\nList of all documented functions regarding Bennu: native, DLL or otherwise.\n category=functions notnamespace = Template redirects = include\nmode=userformat ordermethod = titlewithoutnamespace\ncolumns = 5 listseparators = ,\\n* %TITLE%(),, resultsfooter = \\n%PAGES% functions replaceintitle = /\\\\? /,_ \n","permalink":"https://divhub.github.io/pixtudio-website/docs/functions/","title":""},{"contents":" Definition INT fwrite ( \u0026lt;INT filehandle\u0026gt; , \u0026lt;VARIABLE data\u0026gt; )\nINT fwrite ( \u0026lt;VOID POINTER data_pos\u0026gt; , \u0026lt;INT length\u0026gt; , \u0026lt;INT filehandle\u0026gt;)\nWrites the variable data to a file loaded with fopen.\nto be extended\u0026hellip;\nParameters INT filehandle - Identifier of the file loaded with fopen. VARIABLE data - The data to write to the file (any type of variable).\nReturns INT : The number of bytes written to the file.\nExample Process writething(STRING loadpath); Private handle; // handle for the loaded file druppels; // the data to write to the file Begin druppels=rand(1,10); handle=fopen(loadpath,O_WRITE); // opens the file in writing mode fwrite(handle,druppels); // writes the druppels variable to the file fclose(handle); // zipping up after business is done End  Used in example: fopen(), fclose(), rand()\nCategory:functions Category:files Category:mod_file\n","permalink":"https://divhub.github.io/pixtudio-website/docs/fwrite/","title":""},{"contents":" Guide: Porting to your chosen system This is a general guide for getting your Bennu game onto your chosen system.\n\u0026rdquo;\u0026rsquo; If you have missed the front page of this Wiki please see Bennu_Wiki or click on the BennuWiki logo on the top left of this page. \u0026ldquo;\u0026rsquo;\n these OS or platforms: Windows\n Linux\n Caanoo (a later GP2X type handheld)\n GP2X Wiz\n Dingux (Dingoo OS for handheld)\n The rest are generally unsupported by BennuGD community but still quite possible: Playstation 2\n HTML5/Chrome Native Client\n Dreamcast\n Haiku OS\n FreeBSD\n MacOS X (Intel 32 bits)\n BennuGD PPA for Ubuntu 32 bits\n Nintendo Wii\n PSP\n Pandora\n Xbox\n Motorola linux phone (RU)\n Another exciting development is - BennuGD is being ported to: Android\n   ther exciting development is - BennuGD is being ported to: Android\n  Expect this to be added to the \u0026ldquo;unsupported\u0026rdquo; section list very soon.\nEssential: Check out Downloads page for BennuGD.\nYou can read about current developments on any ports at bennugd.org main page in the frontpage News feed.\nStarting Out If you have some experience with BennuGD you will have used bgdc (the compiler) and bgdi (the interpreter).\nOnce you have downloaded the Bennu port for your chosen target platform you will find it includes bgdc.xxx and bgdi.xxx. The compiler is the part that talks to the the machine, making your bennu code into a .dcb that is usable when executed with the interpreter. Also depending on which port, you will also find the set of standard libraries for the specific machine, or not. With bennu-monolithic ports you may find the libraries are not present as seperate files.\n\u0026rdquo; bennugd-monolithic - Many of recent ports are part of the bennugd-monolithic project, which enables certain machines to run Bennu successfully, including Wii, PSP iOS and Android. See josebita\u0026rsquo;s bennugd-monotlithic Google Code pages for information about this.\u0026rdquo;\nSo if you haven\u0026rsquo;t done so, see the Downloads page of bennugd.org and retrieve the relevant port for your system - (checking that you are downloading the latest version!)\nNotes on Setting Up Porting is quite a task sometimes. You may find you need to edit your source code, depending on requirements of the target system and the current state of the port you are using. This can be related to sound or display requirements for example. Sometimes you can find your game may not run fast enough and needs optimisation - the target system can be slower than the computer you originally wrote the game for. However this should be only attempted after testing your game! So read on!\nAlso some preparation work is desired in your game source for the peripherals (controls) of the console or platform, so a good idea is to ascertain what controls you will be using early on. There is a section on this next in the guide!\nThe other part of porting is getting the machine you want to run your Bennu game on to actually compile the game itself. This can be an easy process or rather tough. But you will find certain tools written by developers who have paved the way before you will make this infinitely easier.\nMost of all DON\u0026rsquo;T GIVE UP. You may find once your game compiles successfully with bgdc and you have a .dcb ready, there may be runtime errors when running and playing your game (with bgdi).\nOnce you have filesystem specifics set up for your chosen platform, the thing to remember is the standard commandline process which must be performed on the machine you intend to run your game on:\nbgdc.xxx [params] bennugame.prg\nWhich naturaly takes your code and builds a dcb of your program.\nbgdi.xxx bennugame.dcb\nThis will run your program.\nNote: Most testing scenarios will not require you to use parameters in the compilation of your game/program.\nHowever, one common parameter used is -a which automatically packages your commonly used resources - for example FPGs, WAVs into the dcb. This is optional for you of course, but can be very beneficial. When distributing your game or homebrew, people will not see your resource files and can help protect them from further use.\nFor further information on compile parameters you can ask bgdc itself:\nbgdc.xxx -help\nWhich prints a list of parameters and a description of their uses. \u0026ldquo;\u0026lsquo;Disclaimer: Be careful with these! They can sometimes crash your console or any equipment used! \u0026ldquo;\u0026rsquo;\nFor any platform specific questions I will direct you to the bennugd.org community boards for each supported platform. Here you can post questions or search for answers. (This is for more advanced or searching questions about each particular console/machine).\n","permalink":"https://divhub.github.io/pixtudio-website/docs/general/","title":""},{"contents":" Definition INT get_angle ( \u0026lt;INT processID\u0026gt; )\nReturns the angle between the coordinates of a certain process and the process calling get_angle().\nParameters INT processID - The other process.\nReturns INT : The wanted angle.\n-1 - An error may have occurred: invalid process. !-1 - The wanted angle.\nExample Program angling; import \u0026quot;mod_grproc\u0026quot;//modules import \u0026quot;mod_proc\u0026quot; import \u0026quot;mod_wm\u0026quot; import \u0026quot;mod_key\u0026quot; import \u0026quot;mod_video\u0026quot; import \u0026quot;mod_map\u0026quot; import \u0026quot;mod_draw\u0026quot; import \u0026quot;mod_text\u0026quot; Const screen_width = 320; screen_height = 200; screen_depth = 8; screen_fps = 60; screen_frameskip = 0; Global int distance; int tempID; Begin // Set the screen mode set_mode(screen_width,screen_height,screen_depth); set_fps(screen_fps,screen_frameskip); // Change this to see what happens resolution = 100; // Create mouse graph and start mousepointer x = new_map(20,20,screen_depth); map_clear(0,x,rgb(255,0,0)); mousepointer(0,x); // Create arrow, assign to graph graph = new_map(30,30,screen_depth); drawing_map(0,graph); drawing_color(rgb(0,255,0)); draw_line( 0,29,29,30/2); draw_line( 0, 0,30,30/2); // Set position x = screen_width /2 * resolution; y = screen_height/2 * resolution; // Display distance write(0,0,0,0,\u0026quot;Distance:\u0026quot;); write_int(0,60,0,0,\u0026amp;distance); // Always point to the mouse Repeat // Get the angle and distance between this process' coordinates and those of mousegraph. // We can use TYPE and get_id() here, because usually there would only be one // mousepointer and one always. tempID = get_id(type mousepointer); angle = get_angle(tempID); distance = get_dist(tempID); frame; Until(key(_esc)) End /** * Follows the mouse coordinates. x is always mouse.x and y is always mouse.y * for processes with priority \u0026lt;1. The graphic of this process will be a certain graphic. * int file - The fileID of the file where the graphic is located * int graph - The graphID of the graphic to be used for this process */ Process mousepointer(int file,int graph) Begin // Set the priority to 1, because we first want to have the correct coordinates of // the mouse set in this process. Then after that other process can use those coordinates. priority = 1; // Obtain father's resolution resolution = father.resolution; // Loop Loop // Obtain X and Y coordinates of the mouse and adjust for resolution // (mouse.y and mouse.y have an unchangeable resolution of 1) x = mouse.x * resolution; y = mouse.y * resolution; frame; End End  Used in example: set_mode(), new_map(), map_clear(), drawing_map(), drawing_color(), draw_line(), write(), write_int(), get_id(), get_angle(), get_dist(), resolution, mouse, graph, x, y, angle, priority\nThis example could also be done with fget_angle(), which is easier and doesn\u0026rsquo;t require an extra process.\nIt could look something like:\nhttp://wwwhome.cs.utwente.nl/~bergfi/fenix/wiki/get_angle.PNG\nCategory:functions Category:processinteraction Category:mod_grproc\n","permalink":"https://divhub.github.io/pixtudio-website/docs/get_angle/","title":""},{"contents":" Definition STRING get_base_path ( )\nUse this function to get the directory where the application was run from. This is where the application data directory is.\nIn macOS (and iOS), if the application is in a \u0026ldquo;.app\u0026rdquo; bundle, the function will return the path to the app\u0026rsquo;s resources directory (Game.app/Contents/Resources/).\nReturns STRING : The path to the directory where the application was run from. If the base path cannot be found, an empty string will be returned.\nExample IMPORT \u0026quot;mod_dir\u0026quot;; IMPORT \u0026quot;mod_say\u0026quot;; PROCESS main(); BEGIN say(\u0026quot;Base path: \u0026quot; + get_base_path()); END  ","permalink":"https://divhub.github.io/pixtudio-website/docs/get_base_path/","title":""},{"contents":" Syntax INT get_desktop_size ( \u0026lt;INT POINTER width\u0026gt;, \u0026lt;INT POINTER height\u0026gt; )\nDescription Get the desktop size.\nParameters INT POINTER width - Pointer to where the desktop width will be written. INT POINTER height - Pointer to where the desktop height will be written.\nReturns INT : Successrate\nfalse - Error. true - Ok.\nCategory:functions Category:programinteraction Category:mod_wm\n","permalink":"https://divhub.github.io/pixtudio-website/docs/get_desktop_size/","title":""},{"contents":" Definition INT get_dist ( \u0026lt;INT processID\u0026gt; )\nReturns the distance between the coordinates of a certain process and the process calling get_dist(). The distance returned is converted to the resolution of the process calling get_dist().\nParameters INT processID - The other process.\nReturns INT : The wanted distance.\n-1 - An error occurred: invalid process. !-1 - The wanted distance.\nExample Program angling; Const screen_width = 320; screen_height = 200; screen_depth = 8; screen_fps = 60; screen_frameskip = 0; Global int distance; int tempID; Begin // Set the screen mode set_mode(screen_width,screen_height,screen_depth); set_fps(screen_fps,screen_frameskip); // Change this to see what happens resolution = 100; // Create mouse graph and start mousepointer x = new_map(20,20,screen_depth); map_clear(0,x,rgb(255,0,0)); mousepointer(0,x); // Create arrow, assign to graph graph = new_map(30,30,screen_depth); drawing_map(0,graph); drawing_color(rgb(0,255,0)); draw_line( 0,29,29,30/2); draw_line( 0, 0,30,30/2); // Set position x = screen_width /2 * resolution; y = screen_height/2 * resolution; // Display distance write(0,0,0,0,\u0026quot;Distance:\u0026quot;); write_int(0,60,0,0,\u0026amp;distance); // Always point to the mouse Repeat // Get the angle and distance between this process' coordinates and those of mousegraph. // We can use TYPE and get_id() here, because usually there would only be one // mousepointer and one always. tempID = get_id(type mousepointer); angle = get_angle(tempID); distance = get_dist(tempID); frame; Until(key(_esc)) End /** * Follows the mouse coordinates. x is always mouse.x and y is always mouse.y * for processes with priority \u0026lt;1. The graphic of this process will be a certain graphic. * int file - The fileID of the file where the graphic is located * int graph - The graphID of the graphic to be used for this process */ Process mousepointer(int file,int graph) Begin // Set the priority to 1, because we first want to have the correct coordinates of // the mouse set in this process. Then after that other process can use those coordinates. priority = 1; // Obtain father's resolution resolution = father.resolution; // Loop Loop // Obtain X and Y coordinates of the mouse and adjust for resolution // (mouse.y and mouse.y have an unchangeable resolution of 1) x = mouse.x * resolution; y = mouse.y * resolution; frame; End End  Used in example: set_mode(), new_map(), map_clear(), drawing_map(), drawing_color(), draw_line(), write(), write_int(), get_id(), get_angle(), get_dist(), resolution, mouse, graph, x, y, angle, priority\nThis example could also be done with fget_dist(), which is easier and doesn\u0026rsquo;t require an extra process. It also give a much more accurate distance when the resolution is \u0026gt;1.\nResolution is 100:\nhttp://wwwhome.cs.utwente.nl/~bergfi/fenix/wiki/get_angle.PNG VS http://wwwhome.cs.utwente.nl/~bergfi/fenix/wiki/fget_angle.PNG get_angle() and get_dist() with a process fget_angle() and fget_dist()\nCategory:functions Category:processinteraction Category:mod_grproc\n","permalink":"https://divhub.github.io/pixtudio-website/docs/get_dist/","title":""},{"contents":" Definition INT get_distx ( \u0026lt;INT angle\u0026gt; , \u0026lt;INT distance\u0026gt; )\nReturns the horizontal distance in pixels of a specified displacement.\nThis is the same as [[cos]](''angle'')*''distance''.\nParameters INT angle - Angle, in thousandths of degrees (90° = 90000). INT distance - Length (in pixels) to measure.\nReturns INT : The horizontal distance, in pixels, of a specified displacement.\nNotes This function returns the width of an imaginary rectangle who\u0026rsquo;s opposite corners are the specified distance apart, at the specified angle from each other.\nExample Global xdist; ydist; dist; ang; mydraw; End Process Main() Begin set_mode(640,480,16); set_fps (50,0); graph = new_map(3,3,16); map_clear(0,graph,rgb(0,255,0)); x = 320; y = 240; set_text_color(rgb(0,0,0)); write (0,60, 0,2,\u0026quot;X Diff: \u0026quot;); write_int(0,60, 0,0,\u0026amp;xdist); write (0,60,10,2,\u0026quot;Y Diff: \u0026quot;); write_int(0,60,10,0,\u0026amp;ydist); write (0,60,20,2,\u0026quot;Angle: \u0026quot;); write_int(0,60,20,0,\u0026amp;ang); write (0,60,30,2,\u0026quot;Distance: \u0026quot;); write_int(0,60,30,0,\u0026amp;dist); write (0,10,40,0,\u0026quot;Left/right rotates your angle, up/down changes your distance\u0026quot;); put(0,graph,x,y); drawing_background(); repeat if(key(_up)) dist++; end if(key(_down)) dist--; end if(key(_left)) ang-=1000; end if(key(_right)) ang+=1000; end xdist = get_distx(ang,dist); ydist = get_disty(ang,dist); x = 320 + xdist; y = 240 + ydist; frame; until(key(_esc)) let_me_alone(); exit(); End Process drawing_background() Begin graph = new_map(640,480,16); set_ceter (0,graph,0,0); map_clear (0,graph,rgb(64,0,0)); drawing_map (0,graph); drawing_color(rgb(0,0,0)); loop map_clear(0,graph,rgb(255,255,255)); mydraw = draw_line(320,240,father.x,father.y); frame; delete_draw(mydraw); end OnExit unload_map(0,graph); End  Used in example: set_mode(), set_fps(), new_map(), set_text_color(), write(), write_int(), put(), key(), get_distx(), get_disty(), let_me_alone(), exit(), set_center(), map_clear(), rgb(), drawing_map(), drawing_color(), draw_line(), delete_draw(), unload_map()\nCategory:functions Category:math Category:mod_math\n","permalink":"https://divhub.github.io/pixtudio-website/docs/get_distx/","title":""},{"contents":" Definition INT get_disty ( \u0026lt;INT angle\u0026gt; , \u0026lt;INT distance\u0026gt; )\nReturns the vertical distance in pixels of a specified displacement.\nThis is the same as -[[sin]](''angle'')*''distance''.\nParameters INT angle - Angle, in thousandths of degrees (90° = 90000). INT distance - Length (in pixels) to measure.\nReturns INT : The vertical distance, in pixels, of a specified displacement.\nNotes This function returns the height of an imaginary rectangle who\u0026rsquo;s opposite corners are the specified distance apart, at the specified angle from each other.\nExample Global xdist; ydist; dist; ang; mydraw; End Process Main() Begin set_mode(640,480,16); set_fps (50,0); graph = new_map(3,3,16); map_clear(0,graph,rgb(0,255,0)); x = 320; y = 240; set_text_color(rgb(0,0,0)); write (0,60, 0,2,\u0026quot;X Diff: \u0026quot;); write_int(0,60, 0,0,\u0026amp;xdist); write (0,60,10,2,\u0026quot;Y Diff: \u0026quot;); write_int(0,60,10,0,\u0026amp;ydist); write (0,60,20,2,\u0026quot;Angle: \u0026quot;); write_int(0,60,20,0,\u0026amp;ang); write (0,60,30,2,\u0026quot;Distance: \u0026quot;); write_int(0,60,30,0,\u0026amp;dist); write (0,10,40,0,\u0026quot;Left/right rotates your angle, up/down changes your distance\u0026quot;); put(0,graph,x,y); drawing_background(); repeat if(key(_up)) dist++; end if(key(_down)) dist--; end if(key(_left)) ang-=1000; end if(key(_right)) ang+=1000; end xdist = get_distx(ang,dist); ydist = get_disty(ang,dist); x = 320 + xdist; y = 240 + ydist; frame; until(key(_esc)) let_me_alone(); exit(); End Process drawing_background() Begin graph = new_map(640,480,16); set_ceter (0,graph,0,0); map_clear (0,graph,rgb(64,0,0)); drawing_map (0,graph); drawing_color(rgb(0,0,0)); loop map_clear(0,graph,rgb(255,255,255)); mydraw = draw_line(320,240,father.x,father.y); frame; delete_draw(mydraw); end OnExit unload_map(0,graph); End  Used in example: set_mode(), set_fps(), new_map(), set_text_color(), write(), write_int(), put(), key(), get_distx(), get_disty(), let_me_alone(), exit(), set_center(), map_clear(), rgb(), drawing_map(), drawing_color(), draw_line(), delete_draw(), unload_map()\nCategory:functions Category:math Category:mod_math\n","permalink":"https://divhub.github.io/pixtudio-website/docs/get_disty/","title":""},{"contents":" Definition INT get_id ( \u0026lt;INT processTypeID\u0026gt; )\nReturns a ProcessID of a process of the specified ProcessType. On the next call of get_id() in the same process and in the same frame, the next process will be returned of the given type. After a frame statement, get_id() is reset and will return the first process of the given processType. When there are no more processes of a given type, which have not been returned, it will return 0.\nget_id(0) returns processes of any type.\nParameters INT processTypeID - The processTypeID of the processType to get the processes\u0026rsquo; processIDs of.\nReturns INT : The processID of a process of the given processType.\n0 - There are no more processes of the given processType, which have not been returned. \u0026gt;0 - The processID of a process of the given processType.\nExample Program example; Begin signaltype(type Monkey,s_kill); End /** * Empty process */ Process Monkey() Begin End /** * Signals every process of type 't' the signal 'signal'. */ Function int signaltype(int t, int signal) Begin while( (x=get_id(t)) ) // while there is an unprocessed process left and store that in 'x' signal(x,signal); // signal the process with processID 'x'. end End // Of course, the very observant of you already noticed that signaltype(my_type,my_signal) // does the same thing as the function signal(my_type,my_signal), but this is just to // illustrate the workings. /** * Signals every process the signal 'signal'. */ Function int signalall(int signal) Begin while( (x=get_id(0)) ) // while there is an unprocessed process left and store that in 'x' signal(x,signal); // signal the process with processID 'x'. end End // get_id(0) returns a process of any type. This is a possible implementation of a // function which signals all existing processes. Note that this can be dangerous to use, // as in some cases you might want one or two processes to stay alive.  Used in example: signal()\nCategory:functions Category:processinteraction Category:mod_proc\n","permalink":"https://divhub.github.io/pixtudio-website/docs/get_id/","title":""},{"contents":" Syntax POINTER get_modes ( \u0026lt;INT depth\u0026gt;, \u0026lt;INT flags\u0026gt; )\nDescription Returns a pointer to an array of available screen dimensions for the given depth and render flags, sorted largest to smallest.\nReturns NULL if there are no dimensions available for a particular format, or -1 if any dimension is okay for the given format.\nParameters INT depth - Color depth of the screen. See color_depths. INT flags - Mode of rendering. See render flags.\nReturns POINTER : A pointer to an array of available screen dimensions\nExample import \u0026quot;mod_say\u0026quot;; import \u0026quot;mod_video\u0026quot;; Process Main() Private int * modes; Begin // Modes will point to an array whose values are acceptable values for resolution // Get 8bpp acceptable modes when in fullscreen modes = get_modes(8, MODE_FULLSCREEN); say (\u0026quot;8bit modes\u0026quot;); say (\u0026quot;----------\u0026quot;); if (!modes) say (\u0026quot;no video modes available!\u0026quot;); elsif (modes == -1 ) say (\u0026quot;any video mode available!\u0026quot;); else while (*modes) say (\u0026quot;\u0026gt; \u0026quot; + *modes++ + \u0026quot; x \u0026quot; + *modes++ ); end end say (\u0026quot;\u0026quot;); // Get 16bpp acceptable modes when in fullscreen modes = get_modes(16, MODE_FULLSCREEN); say (\u0026quot;16bit modes\u0026quot;); say (\u0026quot;-----------\u0026quot;); if (!modes) say (\u0026quot;no video modes available!\u0026quot;); elsif (modes == -1 ) say (\u0026quot;any video mode available!\u0026quot;); else while (*modes) say (\u0026quot;\u0026gt; \u0026quot; + *modes++ + \u0026quot; x \u0026quot; + *modes++ ); end end say (\u0026quot;\u0026quot;); // Get 24bpp acceptable modes when in fullscreen modes = get_modes(24, MODE_FULLSCREEN); say (\u0026quot;24bit modes\u0026quot;); say (\u0026quot;-----------\u0026quot;); if (!modes) say (\u0026quot;no video modes available!\u0026quot;); elsif (modes == -1 ) say (\u0026quot;any video mode available!\u0026quot;); else while (*modes) say (\u0026quot;\u0026gt; \u0026quot; + *modes++ + \u0026quot; x \u0026quot; + *modes++ ); end end say (\u0026quot;\u0026quot;); // Get 32bpp acceptable modes when in fullscreen modes = get_modes(32, MODE_FULLSCREEN); say (\u0026quot;32bit modes\u0026quot;); say (\u0026quot;-----------\u0026quot;); if (!modes) say (\u0026quot;no video modes available!\u0026quot;); elsif (modes == -1 ) say (\u0026quot;any video mode available!\u0026quot;); else while (*modes) say (\u0026quot;\u0026gt; \u0026quot; + *modes++ + \u0026quot; x \u0026quot; + *modes++ ); end end say (\u0026quot;\u0026quot;); End  Used in example: say(), MODE_FULLSCREEN\nCategory:functions Category:programinteraction Category:mod_video\n","permalink":"https://divhub.github.io/pixtudio-website/docs/get_modes/","title":""},{"contents":" Definition INT get_pixel ( \u0026lt;INT x\u0026gt; , \u0026lt;INT y\u0026gt; )\nReturns the color of the specified pixel on the background. Is equivalent to map_get_pixel( 0, 0, x, y ).\nParameters INT x - The X-coordinate of the pixel the color is wanted. INT y - The Y-coordinate of the pixel the color is wanted.\nReturns INT : The color\nExample import \u0026quot;mod_video\u0026quot; import \u0026quot;mod_wm\u0026quot; import \u0026quot;mod_draw\u0026quot; import \u0026quot;mod_map\u0026quot;; import \u0026quot;mod_screen\u0026quot;; import \u0026quot;mod_mouse\u0026quot;; Process Main() Begin set_mode(640,480,16); // Creates a white box as mouse's cursor mouse.graph = new_map(20,20,16); map_clear(0,mouse.graph,rgb(255,255,255)); // This area will show the pixel's color behind the cursor graph=new_map(100,50,16); x=50; y=25; //Puts the background put_screen(0,load_png(\u0026quot;image.png\u0026quot;)); Repeat map_clear(0,graph,get_pixel(mouse.x,mouse.y)); frame; Until(exit_status) End  Used in example: set_mode(), new_map(), map_clear(), put_screen(), get_pixel()\nCategory:functions Category:maps Category:mod_draw Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/get_pixel/","title":""},{"contents":" Definition STRING get_pref_path ( \u0026lt;STRING company\u0026gt;, \u0026lt;STRING appname\u0026gt; )\nUse this function to get the preferences dir for the described application. This is where the game can store preferences and savegames. If the folder does not exist, it will be created for you.\nIn android systems, your app must be assigned a single identifier in the form of org.pixtudio.sampleapp. In this case, org.pixtudio should be the value for company and sampleapp the value for appname.\nParameters    Parameter name Explanation     STRING company The name of your company or development group.   STRING appname The name of this app.    Returns STRING : The path to the preferences directory. If the base path cannot be found, an empty string will be returned.\nExample IMPORT \u0026quot;mod_dir\u0026quot;; IMPORT \u0026quot;mod_say\u0026quot;; PROCESS main(); BEGIN2 say(\u0026quot;Pref path: \u0026quot; + get_pref_path(\u0026quot;org.pixtudio\u0026quot;, \u0026quot;sampleapp\u0026quot;)); END  ","permalink":"https://divhub.github.io/pixtudio-website/docs/get_pref_path/","title":""},{"contents":" Definition INT get_real_point( \u0026lt;INT controlpoint\u0026gt; , \u0026lt;INT POINTER x\u0026gt; , \u0026lt;INT POINTER y\u0026gt; )\nFinds the actual position on the screen of the calling process, given its graphic and the specified controlpoint on this graphic. All process-related variables are taken into account, like x, y, angle, even ctype. These coordinates are then assigned to the variables pointed to by x and y.\nParameters INT controlpoint - The controlpoint on the process\u0026rsquo; graphic of which the actual position is wanted. INT POINTER x - A pointer to an integer to which the X-coordinate will be assigned. INT POINTER y - A pointer to an integer to which the Y-coordinate will be assigned.\nReturns INT : Successrate\nfalse - Error: no graphic; invalid controlpoint; true - Success.\nCategory:functions Category:processinteraction Category:mod_grproc\n","permalink":"https://divhub.github.io/pixtudio-website/docs/get_real_point/","title":""},{"contents":" Definition INT get_status ( \u0026lt;INT processID\u0026gt; )\nGet the current status of a ProcessID. With this, you can check if a process is frozen, sleeping, dead, alive or non-existing.\nParameters INT processID - The ProcessID signal was send to.\nReturns INT :\nfalse - The specified processID does not exist (return status: 0). 1,2,3 or 4 - The state of the processID.\nReturn states 0 - The specified process does not exist. 1 - The specified process is dead. 2 - The specified process is alive. 3 - The specified process is sleeping. 4 - The specified process is frozen.\nExample // import modules IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_proc\u0026quot;; IMPORT \u0026quot;mod_grproc\u0026quot;; IMPORT \u0026quot;mod_key\u0026quot;; GLOBAL int proc1; int proc2; int proc3; int proc4; int proc5; PROCESS main(); PRIVATE BEGIN // create some processes proc1=dummy(); proc2=dummy(); proc3=dummy(); proc4=dummy(); // change the state signal(proc1,s_sleep); signal(proc2,s_freeze); signal(proc3,s_wakeup); signal(proc4,s_kill); // print the status of each instance say(\u0026quot;\u0026quot;); say(\u0026quot;status codes: ALIVE=2, SLEEP=3, FROZEN=4 ,DEAD=1, NON_EXISTING=0\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;proc1 status: \u0026quot;+get_status(proc1)); // sleeping (3) say(\u0026quot;proc2 status: \u0026quot;+get_status(proc2)); // frozen (4) say(\u0026quot;proc3 status: \u0026quot;+get_status(proc3)); // alive (2) say(\u0026quot;proc4 status: \u0026quot;+get_status(proc4)); // dead (1) say(\u0026quot;proc5 status: \u0026quot;+get_status(proc5)); // not existing (0) LOOP // quit. IF (key(_esc)) exit(\u0026quot;\u0026quot;,0); END FRAME; END END PROCESS dummy(); PRIVATE BEGIN // endless loop LOOP FRAME; END END  Used in example: exit(), say(), key(), signal\nCategory:functions Category:processinteraction Category:mod_proc\n","permalink":"https://divhub.github.io/pixtudio-website/docs/get_status/","title":""},{"contents":" Definition INT get_text_color( [\u0026lt;INT textID\u0026gt;] )\nGets the current text color (the color where texts will be written in).\nParameters INT textID: The identification code of the text (optional parameter, introduced in version rc282).\nReturns INT: color the text will be written in, or 0 when there is a problem.\nNotes None.\nErrors \nExample Program test; Global my_text; text_color; Begin set_text_color( rgb(192,112,0) ); text_color = get_text_color(); write (0,320/2 ,200/2,4,\u0026quot;The color of this text is:\u0026quot;); write_int(0,320/2+100,200/2,4,\u0026amp;text_color); Repeat frame; Until(key(_ESC)) End  Used in example: set_text_color(), write(), write_int(), key()\nThis will result in something like:\nCategory:functions Category:texts Category:mod_text\n","permalink":"https://divhub.github.io/pixtudio-website/docs/get_text_color/","title":""},{"contents":" Syntax INT get_timer ( )\nDescription Returns the time the program has been running in milliseconds.\nReturns INT : The time the program has been running in milliseconds.\nCategory:functions Category:time Category:mod_time\n","permalink":"https://divhub.github.io/pixtudio-website/docs/get_timer/","title":""},{"contents":" Syntax INT get_window_pos ( \u0026lt;INT POINTER x\u0026gt;, \u0026lt;INT POINTER y\u0026gt;)\nDescription Get the X and Y position of the window.\nParameters INT POINTER x - Pointer to where the X-coordinate of the window will be written. INT POINTER y - Pointer to where the Y-coordinate of the window will be written.\nReturns INT : Successrate\nfalse - The system is in fullscreen. true - Success ok.\nCategory:functions Category:programinteraction Category:mod_wm\n","permalink":"https://divhub.github.io/pixtudio-website/docs/get_window_pos/","title":""},{"contents":" Syntax INT get_window_size ( \u0026lt;INT POINTER window_width\u0026gt; , \u0026lt;INT POINTER window_height\u0026gt; , \u0026lt;INT POINTER client_width\u0026gt; , \u0026lt;INT POINTER client_height\u0026gt; )\nDescription Get the window and client size.\nParameters INT POINTER window_width - Pointer to where the window width will be written. INT POINTER window_height - Pointer to where the window height will be written. INT POINTER client_width - Pointer to where the client width of window will be written. INT POINTER client_height - Pointer to where the client height of window will be written.\nReturns INT : Successrate\nfalse - Error. true - Ok.\nExample import \u0026quot;mod_key\u0026quot; import \u0026quot;mod_video\u0026quot; import \u0026quot;mod_text\u0026quot; import \u0026quot;mod_wm\u0026quot; Global desktop_width = 640; desktop_height = 480; window_width = 0; window_height = 0; client_width = 0; client_height = 0; End Process Main() Begin get_desktop_size(\u0026amp; desktop_width,\u0026amp; desktop_height); get_window_size ( \u0026amp; window_width, \u0026amp;window_height , \u0026amp; client_width , \u0026amp; client_height ); set_mode (desktop_width-window_width+client_width,desktop_height-window_height+client_height,32); set_window_pos(0,0); write(0,desktop_width/2,desktop_height/2+30,0,\u0026quot;ESC to exit\u0026quot;); while (!key(_ESC) ) frame; end End  Used in example: get_desktop_size(), get_window_size(), set_mode(), set_window_pos(), write(), key()\nCategory:functions Category:programinteraction Category:mod_wm\n","permalink":"https://divhub.github.io/pixtudio-website/docs/get_window_size/","title":""},{"contents":" Definition STRING getenv ( \u0026lt;STRING variablename\u0026gt; )\nReturns the value of an environment variable (like PATH).\nParameters STRING variablename - The name of the variable to get the value of.\nReturns STRING : The value of the variable.\n\u0026rdquo;\u0026rdquo; - The variable is invalid or empty. !\u0026ldquo;\u0026rdquo; - The value of the variable.\nCategory:functions Category:programinteraction Category:mod_sys\n","permalink":"https://divhub.github.io/pixtudio-website/docs/getenv/","title":""},{"contents":" Definition STRING glob ( \u0026lt;STRING criteria\u0026gt; )\nGets a single filename or directoryname matching the criteria. If the same criteria is specified, it keeps returning new items on subsequent calls until it can\u0026rsquo;t find any more, in which case it returns \u0026ldquo;\u0026rdquo;. When different criteria are specified, the search is \u0026lsquo;reset\u0026rsquo;. To reset the search without returning an item, use \u0026quot;\u0026quot; as criteria.\nAfter a call to glob(), the global struct fileinfo is filled with information about the last file/directory entry returned.\nParameters STRING criteria - The search criteria to which the returned filenames apply. \u0026quot;\u0026quot; to reset search.\nReturns STRING : Filename or directoryname\n\u0026rdquo;\u0026rdquo; - No (new) file/directory entries. !\u0026ldquo;\u0026rdquo; - The name of a file/directory entry matching the search criteria.\nNotes The search criteria can hold many criteria: the folder in which you want to look, simple requirements for filenames, such as extensions, and directory names. A few examples:\n* - Returns the filename of any file/directory in the current directory. *.dat - Returns the filename of any file/directory with extension .dat in the current directory. MyDir/* - Returns the filename of any file/directory in MyDir\\ relative to the current directory. C:/Program Files/* - Returns the filename of any file/directory in C:\\Program Files\\*.\nExample import \u0026quot;mod_dir\u0026quot; Process Main() Private String filename; Begin // method one: Loop filename = Glob(\u0026quot;levels/*.tul\u0026quot;); // Looks for a file in the relative folder // \u0026quot;levels\u0026quot; that has the file extension \u0026quot;tul\u0026quot;. if(filename!=\u0026quot;\u0026quot;) load_level(filename); // load_level() would load the level file else break; end End //Reset search glob(\u0026quot;\u0026quot;); // method two: While( (filename = Glob(\u0026quot;levels/*.tul\u0026quot;)) != \u0026quot;\u0026quot; ) load_level(filename); End End  Both methods result in the same, but the second one is less code.\nCategory:functions Category:files Category:mod_dir\n","permalink":"https://divhub.github.io/pixtudio-website/docs/glob/","title":""},{"contents":" Syntax Global {global variables} End  Description Global is a reserved word used to initiate the declaration of global variables. Terminating the declaration block with an End is needed when the Global is not used in conjunction with the main code of the Program.\nFor a list of predefined global variables, see this page.\nExample  Global // Declare global variables here End Process Main() Begin End Global // Declare global variables here End  ","permalink":"https://divhub.github.io/pixtudio-website/docs/global/","title":""},{"contents":"This article, originally made by SplinterGU, tries to explain how to do a signal to all process and how to recover the initial state of all affected processes.\nHere there are the code of the two functions needed to do it.\nimport \u0026quot;mod_proc\u0026quot;; /* ---------------------------------- */ #define S_FORCE 50 #define S_TREE 100 /* ---------------------------------- */ local saved_status ; end /* ---------------------------------- */ function save_state_and_signal( int pid, int sig ) begin if ( sig \u0026gt;= S_TREE ) sig -= S_TREE; end if ( sig \u0026gt;= S_FORCE ) sig -= S_FORCE; end if ( !pid ) while ( pid = get_id(ALL_PROCESS) ) if ( pid != id \u0026amp;\u0026amp; pid != father ) pid.saved_status = get_status( pid ); signal( pid, S_FORCE + sig ); end end else if ( pid != father ) pid.saved_status = get_status( pid ); signal( pid, S_FORCE + sig ); end end end /* ---------------------------------- */ function restore_state( int pid ) begin if ( !pid ) while ( pid = get_id(ALL_PROCESS) ) if ( pid != id \u0026amp;\u0026amp; pid != father ) signal( pid, S_FORCE + pid.saved_status ); end end else if ( pid != father ) signal( pid, S_FORCE + pid.saved_status ); end end end /* ---------------------------------- */  You can add it to your main \u0026ldquo;.prg\u0026rdquo; code or make a file named \u0026ldquo;global_signal.prg\u0026rdquo; and add a include line to it in your code.\nHere is an example of how to call they:\nsave_state_and_signal( 0 , s_freeze ); // Freezes all processes. restore_state(0); // restore all processes  You can use it like signal function that saves the original state of the process, too.\nCategory:General Category:Tutorials\n","permalink":"https://divhub.github.io/pixtudio-website/docs/global_signals/","title":""},{"contents":" category:general\nDefinition A global variable is a variable that is accessible from anywhere in the code; it is shared by the whole code.\nThere\u0026rsquo;s also a number of predefined local variables.\nTo start the declaration of global variables, use Global.\nCategory:variablecategories\n","permalink":"https://divhub.github.io/pixtudio-website/docs/global_variable/","title":""},{"contents":"category:variablecategories category:predefinedvariablecategories\nUp to Variable Categories\nA list of predefined global variables.\n category = global variables mode = userformat columns = 2 listseparators = ,\\n* %TITLE%,, redirects = include ordermethod = titlewithoutnamespace noresultsheader = No global variables here yet. resultsfooter = \\n%PAGES% global variables replaceintitle = /\\\\? /,_ \n","permalink":"https://divhub.github.io/pixtudio-website/docs/global_variables/","title":""},{"contents":" Definition INT get_glyph ( \u0026lt;INT fontID\u0026gt; , \u0026lt;INT glyphID\u0026gt; )\nCreates a new graphic containing the specified glyph of the specified font.\nThe previous name get_glyph() is deprecated.\nParameters INT fontID - The fontID of the font the glyph is wanted. INT glyphID - The glyphID of the glyph in the specified font.\nReturns INT : GraphID\n0 - Invalid font; Invalid glyph; could not create graphic; \u0026gt;0 - The graphID of the graphic containing the glyph.\nSee also  set_glyph()  Category:functions Category:fonts Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/glyph_get/","title":""},{"contents":" Definition INT glyph_set ( \u0026lt;INT fontID\u0026gt; , \u0026lt;INT glyphID\u0026gt; , \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; )\nSets the specified glyph of the specified font. The new glyph will be a copy of the specified graphic and thus it may be freed after the call.\nThe previous name set_glyph() is deprecated.\nParameters INT fontID - The fontID of the font the glyph is to be set. INT glyphID - The glyphID of the glyph in the specified font. INT fileID - The fileID of the file that holds the graphic. INT graphID - The graphID of the graphic to be copied.\nReturns INT : false\nSee also  glyph_get()  Category:functions Category:fonts Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/glyph_set/","title":""},{"contents":"Equals to Jmp\n","permalink":"https://divhub.github.io/pixtudio-website/docs/goto/","title":""},{"contents":" category:variables category:predefined\nUp to Local Variables\nDefinition INT graph = 0\nGraph is a predefined local variable which holds the GraphID of the process. A graphic can be assigned to the process by assigning the GraphID of that graphic to graph. Assign 0 to the local variable graph to have the process display no graph. Keep in mind that this doesn\u0026rsquo;t free the memory used by the graphic; to free it, use unload_map().\nExample Process cyan_graphic() Begin graph = new_map(100,100,8); // create a new 100x100x8 map. map_clear(0,graph,rgb(0,255,255)); // clear it cyan-colored x = 100; //Position the graphic 100 pixels y = 100; //from the top and left of the screen Repeat frame; Until(key(_ESC)) End  Used in example: new_map(), map_clear(), graphic, x, y\nCategory:local variables\n","permalink":"https://divhub.github.io/pixtudio-website/docs/graph/","title":""},{"contents":" category:variables category:predefined category:global variables category:libvideo\nUp to Global Variables\nDefinition INT graph_mode\nGraph_mode is a global variable, holding the current graph mode. The mode can be changed by assigning a different mode to the variable. Default is 0 and after a call to set_mode() it reflects the set graph mode.\nSee also  sound_mode scale_mode full_screen  ","permalink":"https://divhub.github.io/pixtudio-website/docs/graph_mode/","title":""},{"contents":" Definition Graph modes are used to specify the color depth of the screen and the mode of rendering, by assigning them to the global variable graph_mode. This is also achieved by passing them to the parameters depth and flags in the function set_mode(), which is a pretty tidy solution.\nList Color depths constants:\nConstant - Value - Description MODE_8BITS - 8 - Use a color depth of 8bit. Also called MODE_8BPP. MODE_16BITS - 16 - Use a color depth of 16bit. Also called MODE_16BPP.\nRender flags constants:\nConstant - Value - Description MODE_WINDOW - 0 - Enables window view. MODE_2XSCALE - 256 - Doubles the resolution. Edges get smoothed. MODE_FULLSCREEN - 512 - Enables fullscreen view. MODE_DOUBLEBUFFER - 1024 - Enables using a double buffer for display. Also called DOUBLE_BUFFER. MODE_HARDWARE - 2048 - Enables writing directly to Video RAM instead of main RAM. Also called HW_SURFACE. MODE_MODAL - 4096 - Makes the main window a Modal window. MODE_FRAMELESS - 8192 - Makes the main window borderless.\nCategory:constantcategories\n","permalink":"https://divhub.github.io/pixtudio-website/docs/graph_modes/","title":""},{"contents":" Definition A graphic (graph or map) is a bitmap with certain properties, like width, height, depth and of course the pixel data. It is used to give the program a graphical look. One can load graphics from files with for example load_png() or use Image.DLL. They can also be obtained from within FPG\u0026rsquo;s or FGC\u0026rsquo;s files, which are graphic collection files. To create one on the fly, the function new_map() can be used. Here\u0026rsquo;s a list of functions related to graphics and maps.\nDisplaying a Graphic To display a graphic on the screen, there are two main ways of doing this:\n Using drawing operations listed here. Using processes and assigning graphics to their graph variable.  Combinations can also be used naturally.\nDrawing Operations Graphics can be drawn onto each other, by the use of various map functions. The functions use blitting as the method for drawing, which is a reasonably fast way, as Bennu makes use of MMX capabilities. A function like put() will draw a picture on the background, displaying it on the screen (if restore_type is not NO_RESTORE).\nProcess Graphs Graphics can be assigned to processes, which also have coordinate and transformation data. This is done by the use of the local variables graph, which holds the GraphID of a graph. The graphic is displayed, according to a few local variables influencing the graphic, like x, y, z, angle, etc.\nCategory:general\n","permalink":"https://divhub.github.io/pixtudio-website/docs/graphic/","title":""},{"contents":" Definition INT graphic_info ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; , \u0026lt;INT infotype\u0026gt; )\nGets some information about the graph specified. This function is also known as Map_info() and Map_info_get().\nParameters INT fileID - The file that holds the graph. INT graphID - The graph to get information from. INT infotype - What type of information you want.\nReturns INT : Returns the information you want.\nIf the specified graph was invalid it returns 0.\nIf the specified infotype was not recognized it returns 1.\nExample Program keuken; Local gxc; gyc; Begin set_mode(640,480,16); graph=new_map(rand(50,150),rand(50,150),16); //makes a randomly proportioned red rectangle map_clear(0,graph,rgb(255,0,0)); x=320; y=240; gxc=graphic_info(0,graph,G_X_CENTER); gyc=graphic_info(0,graph,G_Y_CENTER); //finds the graphic's center coordinates map_put_pixel(0,graph,gxc,gyc,rgb(255,255,255)); //puts a white pixel in the center of the graphic Loop frame; End End  Used in example: set_mode(), new_map(), map_clear(), map_put_pixel()\nCategory:functions Category:maps Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/graphic_info/","title":""},{"contents":" Definition INT Graphic_set ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; , \u0026lt;INT info_type\u0026gt; , \u0026lt;INT value\u0026gt; )\nChanges the x or y coordinate of the center pixel (controlpoint 0). This function is also known as Map_info_set().\nParameters INT fileID - The file that holds the graph. INT graphID - The graph to get information from. INT info_type - What type of information you want to change, see note. INT value - The new x or y coordinate of the center pixel.\nReturns INT : Returns the information you want.\nIf the specified graph was invalid it returns 0.\nIf the specified infotype was not recognized it returns 1.\nNotes As infotype, only two options are valid:\nG_X_CENTER - Change the x coordinate of the center pixel. G_Y_CENTER - Change the y coordinate of the center pixel.\nCategory:functions Category:maps Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/graphic_set/","title":""},{"contents":" Definition Graphical infotypes are used in graphic_info(), to specify what information about a graph is wanted.\nList Constant - Value - Description G_WIDTH - 0 - Width in pixels. G_WIDE is equivalent, but deprecated. G_HEIGHT - 1 - Height in pixels. G_X_CENTER - 2 - X-axis center. Also called G_CENTER_X G_Y_CENTER - 3 - Y-axis center. Also called G_CENTER_Y G_PITCH - 4 - Width in bytes. G_DEPTH - 5 - Color depth in bits per pixel. G_FRAMES - 6 - Number of frames. G_ANIMATION_STEP - 7 - Current frame in animation. G_ANIMATION_STEPS - 8 - Number of frames in animation. G_ANIMATION_SPEED - 9 - Current speed of animation. B_CLEAR - 1 - Used in function map_new(), indicates if a bitmap is cleared. CHARSET_ISO8859 - 0 - Used to select iso8859 character set in the function fnt_new(). CHARSET_CP850 - 1 - Used to select cp850 character set in the function fnt_new(). NFB_VARIABLEWIDTH - 0 - Flag for the function fnt_new(). NFB_FIXEDWIDTH - 1 - Flag for the function fnt_new().\nCategory:constantcategories Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/graphical_infotypes/","title":""},{"contents":" Definition GraphID\nA GraphID is an identifier associated with a certain graphic in the file (FPG) specified by a FileID.\nGraphID\u0026rsquo;s can be used to point to certain graphics in certain files (FPGs), for displaying them onscreen, or manipulating them in another way, like put() or map_put(). They can also be used to specify the graphic of a process or function, by assigning the GraphID to the local variable graph. This will make the process use the graphic in the file (FPG), specified by the local variable file, at the position specified by the local variable graph.\nExample Program files; Global int file_id; Begin // Load FPG file_id = load_fpg(\u0026quot;example.fpg\u0026quot;); // Set locals for display of graph file = file_id; graph = 1; x = y = 50; Repeat frame; Until(key(_frame)) End  Used in example: load_fpg(), key(), file, graph\nCategory:general\n","permalink":"https://divhub.github.io/pixtudio-website/docs/graphid/","title":""},{"contents":" Definition INT grayscale ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; , \u0026lt;BYTE method\u0026gt; )\nThis function will convert the specified graphic by using the specified method; see notes for the details.\nParameters INT fileID - The fileID of the file that holds the graphics. INT graphID - The graphID of the graphic to convert. BYTE method - The method used (see notes).\nReturns INT\n-1 - Invalid graphic. 1 - Success.\nGrayscale modes Constant - Value - Description GSCALE_RGB - 0 - changes the graphic to monochrome. GSCALE_R - 1 - changes the graphic to RED scale. GSCALE_G - 2 - changes the graphic to GREEN scale. GSCALE_B - 3 - changes the graphic to BLUE scale. GSCALE_RG - 4 - changes the graphic to YELLOW scale. GSCALE_RB - 5 - changes the graphic to PURPLE scale. GSCALE_GB - 6 - changes the graphic to CYAN scale. GSCALE_OFF - -1 - no change, graphic stays as it is, so filter is not applied.\nNotes The exact formula is:\nc = 0.3 * oldpixel_r + 0.59 * oldpixel_g + 0.11 * oldpixel_b  Method 0:\nfor every pixel: newpixel_rgb = (c,c,c)  Method 1:\nfor every pixel: newpixel_rgb = (c,0,0)  Method 2:\nfor every pixel: newpixel_rgb = (0,c,0)  Method 3:\nfor every pixel: newpixel_rgb = (0,0,c)  Method 4:\nfor every pixel: newpixel_rgb = (c,c,0)  Method 5:\nfor every pixel: newpixel_rgb = (c,0,c)  Method 6:\nfor every pixel: newpixel_rgb = (0,c,c)  Other methodnumbers:\nfor every pixel: newpixel_rgb = oldpixel_rgb  Note that [[rgbscale]](0,map,1,1,1) = [[grayscale]](0,map,0) for a valid graphic (0,map).\nExample /* Example converted from bennupack, fenix test section, 2 Medium\\fenix test\\Fenix Test3\\Test_GRAYSCALE.prg */ // import modules IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_map\u0026quot;; IMPORT \u0026quot;mod_effects\u0026quot;; IMPORT \u0026quot;mod_proc\u0026quot;; IMPORT \u0026quot;mod_grproc\u0026quot;; IMPORT \u0026quot;mod_map\u0026quot;; IMPORT \u0026quot;mod_key\u0026quot;; IMPORT \u0026quot;mod_video\u0026quot;; IMPORT \u0026quot;mod_screen\u0026quot;; GLOBAL int fpg; int png; PROCESS main(); BEGIN scale_mode=scale_normal2x; set_mode(320,200,mode_16bits); fpg=load_fpg(\u0026quot;FPG2.FPG\u0026quot;); png=load_png(\u0026quot;Triangulo_16.png\u0026quot;); say(\u0026quot;Grayscale test...\u0026quot;); say(\u0026quot;Press ESC to quit...\u0026quot;); put_screen(fpg,1); ball(110,50,\u0026quot;mode 0: GSCALE_RGB\u0026quot;,GSCALE_RGB); ball(160,50,\u0026quot;mode 1: GSCALE_R\u0026quot;,GSCALE_R); ball(210,50,\u0026quot;mode 2: GSCALE_G\u0026quot;,GSCALE_G); ball(160,100,\u0026quot;mode 3: GSCALE_B\u0026quot;,GSCALE_B); ball(110,150,\u0026quot;mode 4: GSCALE_RG\u0026quot;,GSCALE_RG); ball(160,150,\u0026quot;mode 5: GSCALE_RB\u0026quot;,GSCALE_RB); ball(210,150,\u0026quot;mode 6: GSCALE_GB\u0026quot;,GSCALE_GB); ball(260,150,\u0026quot;mode -1: GSCALE_OFF\u0026quot;,GSCALE_OFF); REPEAT FRAME; UNTIL (key(_esc)) let_me_alone(); END PROCESS ball(int x,int y,string txt,int blur); BEGIN say(txt); graph=map_clone(0,png); grayscale(fpg,graph,blur); LOOP FRAME; END END  Category:functions Category:graphical effects Category:mod_effects\n","permalink":"https://divhub.github.io/pixtudio-website/docs/grayscale/","title":""},{"contents":" Description Greyscale modes are used to specify the mode of color scaling in the Grayscale().\nGrayscale modes Constant - Value - Description GSCALE_RGB - 0 - changes the graphic to monochrome. GSCALE_R - 1 - changes the graphic to RED scale. GSCALE_G - 2 - changes the graphic to GREEN scale. GSCALE_B - 3 - changes the graphic to BLUE scale. GSCALE_RG - 4 - changes the graphic to YELLOW scale. GSCALE_RB - 5 - changes the graphic to PURPLE scale. GSCALE_GB - 6 - changes the graphic to CYAN scale. GSCALE_OFF - -1 - no change, graphic stays as it is, so filter is not applied.\nNotes The exact formula is:\nc = 0.3 * oldpixel_r + 0.59 * oldpixel_g + 0.11 * oldpixel_b  Method 0:\nfor every pixel: newpixel_rgb = (c,c,c)  Method 1:\nfor every pixel: newpixel_rgb = (c,0,0)  Method 2:\nfor every pixel: newpixel_rgb = (0,c,0)  Method 3:\nfor every pixel: newpixel_rgb = (0,0,c)  Method 4:\nfor every pixel: newpixel_rgb = (c,c,0)  Method 5:\nfor every pixel: newpixel_rgb = (c,0,c)  Method 6:\nfor every pixel: newpixel_rgb = (0,c,c)  Other methodnumbers:\nfor every pixel: newpixel_rgb = oldpixel_rgb  Note that [[rgbscale]](0,map,1,1,1) = [[grayscale]](0,map,0) for a valid graphic (0,map).\nCategory:constantcategories Category:mod_effects\n","permalink":"https://divhub.github.io/pixtudio-website/docs/grayscale_modes/","title":""},{"contents":" category:variables category:predefined category:local variables category:libscroll category:librender\nUp to Local Variables\nDefinition The predefined local variable height is used in Mode7 windows, and it is assigned to each process. It is therefore only relevant in the coordinate system of mode7 (Ctype=C_M7). It is used to define the height of the process graphics in relation to the semi-3d field. This is not to be confused with the local variable Z, as that is used to control the depth of the graphical layers.\nThe height is normally a positive number, because the height of the bottom is 0, and all the processes are placed above it. When the height variable is not defined, it is 0 by default. The graphic base is placed at the indicated height, with the exception when controlpoint number 0 is changed (the default is overruled by the Center_set() function). In that case, the controlpoint will be placed at that height.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/height/","title":""},{"contents":"The Bennu Hello World! Example.\nimport \u0026quot;mod_say\u0026quot; // import the module to output text to console, using say() Process Main() // start the definition of the main process Begin // start the code say(\u0026quot;Hello World!\u0026quot;); End // end the definition of the main process  Used in example: import, Process, Begin, End, say()\nThis will import the module \u0026ldquo;mod_say\u0026rdquo; which contains the definition of the \u0026ldquo;say()\u0026rdquo; function. The function will echo the argument \u0026ldquo;Hello World\u0026rdquo; to the screen.\nCategory:General Category:Tutorials\n","permalink":"https://divhub.github.io/pixtudio-website/docs/hello_world/","title":""},{"contents":" category:variables category:predefined category:local variables category:internal\nUp to Local Variables\nDefinition INT id\nid is a predefined local variable. It contains the process\u0026lsquo; processID.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/id/","title":""},{"contents":" Syntax IF ( \u0026lt;condition\u0026gt; ) [ \u0026lt;code\u0026gt; ] ( ELSEIF ( \u0026lt;condition\u0026gt; ) [ \u0026lt;code\u0026gt; ] ) [ ELSE [ \u0026lt;code\u0026gt; ] ] END  Description if statements are used to control the flow of your program by means of checking conditions.\nif( \u0026lt;condition1\u0026gt; ) // code1 elseif( \u0026lt;condition2\u0026gt; ) // code2 elseif( \u0026lt;condition3\u0026gt; ) // code3 else // code4 end // code5  The action that will be performed depends on the *condition*s: - If at the time the program reaches this if codeblock condition1 evaluates as true, then code1 will be executed and then code5. - If condition1 evaluates to false, the program will evaluate the next elseif and check if it is true or false: if condition2 evaluates as: - true, code2 and then code5 is executed. - false, the program will check the next elseif and do the same thing over.\nIf all other conditions evaluate to false and an else condition is present, the code in the else block will be executed. This code block thus acts as a default action that will be performed when no other condition is true.\nThe if statement must be closed with an end statement.\nExample Execute function This is a little example of how to make a function perform a certain task depending on a command.\nFunction int execute(String command, int* params) Begin if( command == \u0026quot;SEND\u0026quot; ) NET_Send(atoi(params[0]),params[1]); elseif( command == \u0026quot;RECV\u0026quot; ) NET_Recv(atoi(params[0])); elseif( command == \u0026quot;INIT\u0026quot; ) NET_Init(atoi(params[0]),atoi(params[1]),atoi(params[2])); elseif( command == \u0026quot;QUIT\u0026quot; ) NET_Quit(); else // error: command unknown return -1; end return 0; End  Movement Movement with Ifs.\nLoop if(key(_up)) y-=5; end if(key(_down)) y+=5; end if(key(_left)) x-=5; end if(key(_right)) x+=5; end End  Of course, this is faster:\nLoop y += 5 * (key(_down )-key(_up )); x += 5 * (key(_right)-key(_left)); End  ","permalink":"https://divhub.github.io/pixtudio-website/docs/if/","title":""},{"contents":" Syntax import \u0026quot;{module name}\u0026quot;  Description Imports a PixTudio module named module name into the program, which allows the usage of additional functionality in a PixTudio program.\nExample  import \u0026quot;mod_say\u0026quot; import \u0026quot;my_dll\u0026quot;; Process Main() Begin End  ","permalink":"https://divhub.github.io/pixtudio-website/docs/import/","title":""},{"contents":" Definition Bennu include file, containing code.\nSee also  Include  Category:filetypes\n","permalink":"https://divhub.github.io/pixtudio-website/docs/inc/","title":""},{"contents":" Syntax include \u0026quot;{filename}\u0026quot;  Description When the compiler reaches an include statement, it continues compilation at the included file and when it\u0026rsquo;s done resumes compiling from the statement right after the include. In other words, these files contain code that gets inserted at the place of inclusion.\nThis is very handy for breaking up your code into pieces. The handling of video in one include file, audio in another, game logic in another, etc. This makes code more maintainable and understandable; moreover it makes code reusable. The video handling include file you made for one game can be used for another game (if it was coded in a generic fashion) without spitting through the whole sourcecode of the first game.\nAlso headers can be used to import modules and possibly give a little more functionality to that module.\nExample main.prg\n // The code in \u0026quot;bar.inc\u0026quot; will be inserted here: include \u0026quot;bar.inc\u0026quot; import \u0026quot;mod_say\u0026quot; Process Main() Private int barcode; Begin barcode = bar(); say(barcode); End  bar.inc\n import \u0026quot;mod_rand\u0026quot; Function int bar() Begin return rand(0,10); End  Used in example: include, import, write_int(), key()\n","permalink":"https://divhub.github.io/pixtudio-website/docs/include/","title":""},{"contents":"Functions:\n List of functions List of function categories  Variables:\n List of variables List of variable categories  Constants:\n List of constants List of constant categories  General/language/syntax:\n List of general pages List of language pages  Tutorials:\n List of tutorials  DLL\u0026rsquo;s:\n List of DLL\u0026rsquo;s  Projects:\n List of Projects  ","permalink":"https://divhub.github.io/pixtudio-website/docs/","title":""},{"contents":"Protected page, so buzz off, spammers.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/index.php/","title":""},{"contents":" Definition INT\nInts (short for integer, meaning wholes), are whole numbers ranging from -2^31 to 2^31-1 ( -2147483648 to 2147483647 ). This is because an integer uses 32bits (4 bytes) to denote its value using the Two\u0026rsquo;s complement system.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/int/","title":""},{"contents":" Up to Modules\nInternal default data.\nUsage Category:modules Category:internal\n","permalink":"https://divhub.github.io/pixtudio-website/docs/internal/","title":""},{"contents":" Definition INT is_playing_song ( )\nChecks to see if Bennu is playing a song file, started with play_song().\nReturns INT : Whether Bennu is playing a song at the moment of calling.\ntrue - Bennu is playing a song. false - Bennu is not playing a song.\nExample program music_example; global my_song; playing; paused; faded_in; v; begin set_mode(640,480,16); my_song=load_song(\u0026quot;beat.ogg\u0026quot;); write(0,320,30,4,\u0026quot;Use the keyboard to control the music playback.\u0026quot;); write(0,320,50,4,\u0026quot;Key [ENTER] starts / stops the song.\u0026quot;); write(0,320,60,4,\u0026quot;Key [SPACE] pauses / resumes the song.\u0026quot;); write(0,320,70,4,\u0026quot;Key [0] through key [9] changes the song volume.\u0026quot;); write(0,320,80,4,\u0026quot;Key [F] fades the song in or out.\u0026quot;); write(0,320,120,5,\u0026quot;Playing: \u0026quot;); write_int(0,320,120,3,\u0026amp;playing); write(0,320,140,5,\u0026quot;Paused: \u0026quot;); write_int(0,320,140,3,\u0026amp;paused); write(0,320,160,5,\u0026quot;Faded in: \u0026quot;); write_int(0,320,160,3,\u0026amp;faded_in); write(0,320,180,5,\u0026quot;Volume: \u0026quot;); write_int(0,320,180,3,\u0026amp;v); v=128; faded_in=true; repeat if(key(_enter)) if(is_playing_song()) stop_song(); playing=false; else play_song(my_song,1); playing=true; end while(key(_enter))frame;end end if(key(_space)) if(paused) paused=false; resume_song(); else paused=true; pause_song(); end while(key(_space))frame;end end if(key(_f)) if(faded_in) faded_in=false; fade_music_off(100); else faded_in=true; fade_music_in(my_song,1,100); end while(key(_f))frame;end end if(key(_0))v=0;end if(key(_1))v=14;end if(key(_2))v=28;end if(key(_3))v=43;end if(key(_4))v=57;end if(key(_5))v=71;end if(key(_6))v=85;end if(key(_7))v=100;end if(key(_8))v=114;end if(key(_9))v=128;end set_song_volume(v); frame; until(key(_esc)) exit(); end  Used in example: key(), set_mode(), load_song(), write(), write_int(), pause_song(), play_song(), stop_song(), resume_song(), fade_music_in(), fade_music_off(), set_song_volume().\nCategory:functions Category:sound Category:mod_sound\n","permalink":"https://divhub.github.io/pixtudio-website/docs/is_playing_song/","title":""},{"contents":" Definition INT is_playing_wav ( INT )\nChecks to see if Bennu is playing a wave file on the indicated Sound_channel, started with play_wav().\nParameters INT channel: The Sound_channel\nReturns INT : Whether Bennu is playing a song at the moment of calling.\ntrue - Bennu is playing a song. false - Bennu is not playing a song.\nExample Used in example:\nCategory:functions Category:sound Category:mod_sound\n","permalink":"https://divhub.github.io/pixtudio-website/docs/is_playing_wav/","title":""},{"contents":" Syntax INT isinf ( \u0026lt;FLOAT number\u0026gt; )\nDescription Checks if a given value is an infinity. It does not check for Not-A-Numbers. Use the Isnan() function for that.\nParameters FLOAT number - The value to check.\nReturns INT FALSE - The value is a not an infinity. INT TRUE - The value is a positive or negative infinity.\nSee also Wikipedia page about the mathematical subject infinity.\nCategory:functions Category:math Category:mod_math\n","permalink":"https://divhub.github.io/pixtudio-website/docs/isinf/","title":""},{"contents":" Syntax INT isnan ( \u0026lt;FLOAT number\u0026gt; )\nDescription Checks if a given value is a number. It does not check for infinties. Use the Isinf() function for that.\nParameters FLOAT number - The value to check.\nReturns INT FALSE - The value is a number. INT TRUE - The value is NOT a number.\nCategory:functions Category:math Category:mod_math\n","permalink":"https://divhub.github.io/pixtudio-website/docs/isnan/","title":""},{"contents":" Definition STRING itoa ( \u0026lt;INT value\u0026gt; )\nReturns a string containing a certain int value.\nParameters INT value - The value the returned string will contain.\nReturns STRING : The string containing the specified value, including sign.\nCategory:functions Category:strings Category:mod_string\n","permalink":"https://divhub.github.io/pixtudio-website/docs/itoa/","title":""},{"contents":" Syntax jmp \u0026lt;label\u0026gt; ;\nDescription The jmp command jumps to the given label inside a function. Unlike the call command, there is nothing more to it.\nExample import \u0026quot;mod_say\u0026quot; Process Main() Begin say(my_function(1)); End Function my_function(int value) Private int ret; Begin Jmp real_begin; jumping: ret = 300; return; real_begin: ret = 100; if(value == 1) Call jumping; end ret += 200; return ret; End  Used in example: process, function, jmp, call, return\nThe output of this example is 500, when value is 1. This example show 500 because the input value is a one and it causes that goes to the jumping label inserting a 300 and adding a 200 after.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/jmp/","title":""},{"contents":" Syntax STRING join ( \u0026lt;STRING separator\u0026gt; , \u0026lt;POINTER array\u0026gt; , \u0026lt;INT array_size\u0026gt; )\nDescription Joins an array of strings, given a separator. Returns the resulting string. The function is the opposite of Split(). It is usefull for generating comma seperated value lists, i.e. for use in spreadsheets or text based file formats.\nThe function concatinates individual strings from an array, and adds a separator between them, the first piece will be copied from array[0], the second from array[1], and so forth, until either there are no more pieces left or max_number pieces are copied from the array.\nParameters STRING separator - The regular expression used as separator, i.e. comma\u0026rsquo;s, spaces, semi columns, etc. POINTER array - Pointer to the string array where the strings are stored that are to be joined. INT array_size - The length of the array.\nReturns STRING : The resulting (concatinated) string.\nExample // import modules IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_regex\u0026quot;; GLOBAL string separator=\u0026quot;,\u0026quot;; // the separator character string csv_list[9]; // array with 10 strings PROCESS main(); BEGIN // fill the array with words, that will become an comma seperated list // this is could for instance be data for a some spreadsheet file csv_list[0]=\u0026quot;A\u0026quot;; csv_list[1]=\u0026quot;300\u0026quot;; csv_list[2]=\u0026quot;100\u0026quot;; csv_list[3]=\u0026quot;B\u0026quot;; csv_list[4]=\u0026quot;255\u0026quot;; csv_list[5]=\u0026quot;30\u0026quot;; csv_list[6]=\u0026quot;C\u0026quot;; csv_list[7]=\u0026quot;1000\u0026quot;; csv_list[8]=\u0026quot;10\u0026quot;; csv_list[9]=\u0026quot;\u0026lt;END_DATA\u0026gt;\u0026quot;; // print the joined string say(\u0026quot;\u0026quot;); say(join(separator,\u0026amp;csv_list, 10)); say(\u0026quot;\u0026quot;); END  This program will print as result:\nA,300,100,B,255,30,C,1000,10,\u0026lt;END_DATA\u0026gt;  Used in example: say() See also: split()\nCategory:functions Category:mod_regex\n","permalink":"https://divhub.github.io/pixtudio-website/docs/join/","title":""},{"contents":" Syntax INT joy_getaxis ( [ \u0026lt;INT joy\u0026gt;], \u0026lt;INT axis\u0026gt; )\nDescription Returns the selected joystick state for the given axis.\nThe JoyID is optional, if it is not present, the function uses the selected joystick. You can change the selected joystick with joy_select().\nAlso called joy_getposition(). The previous name get_joy_position() is deprecated.\nParameters [INT JoyID] - The JoyID of the joystick. INT axis - The axis of the joystick.\nReturns INT : state for the given axis.\nCategory:functions Category:Joystick Category:Mod_joy\n","permalink":"https://divhub.github.io/pixtudio-website/docs/joy_getaxis/","title":""},{"contents":" Syntax INT joy_getball ( [ \u0026lt;INT JoyID\u0026gt; ] , \u0026lt;POINTER dx\u0026gt; , \u0026lt;POINTER dy\u0026gt;)\nDescription Returns the state of the specfied ball on the current selected joystick.\nThe JoyID is optional, if it is not present, the function uses the selected joystick. You can change the selected joystick with joy_select().\nParameters [INT JoyID] - The JoyID of the joystick. POINTER dx - A pointer to the variable X of the ball. POINTER dy - A pointer to the variable Y of the ball.\nReturns INT : The state of the specfied ball on the current selected joystick.\nExample Category:functions Category:Joystick Category:Mod_joy\n","permalink":"https://divhub.github.io/pixtudio-website/docs/joy_getball/","title":""},{"contents":" Syntax INT joy_getbutton ( [ \u0026lt;INT joy\u0026gt;], \u0026lt;INT button\u0026gt; )\nDescription Returns the selected joystick state for the given button.\nThe JoyID is optional, if it is not present, the function uses the selected joystick. You can change the selected joystick with joy_select().\nThe previous name get_joy_button() is deprecated.\nParameters [INT JoyID] - The JoyID of the joystick. INT button - The button on the joystick.\nReturns INT : state for the given button.\nCategory:functions Category:Joystick Category:Mod_joy\n","permalink":"https://divhub.github.io/pixtudio-website/docs/joy_getbutton/","title":""},{"contents":" Syntax INT joy_gethat ( [ \u0026lt;INT JoyID\u0026gt; ] , \u0026lt;INT hat\u0026gt; )\nDescription Returns the current position of the digital POV hat of the controller pad selected.\nThe return values are:\nConstant - Value - Description JOY_HAT_CENTERED - 0 - The hat is centered. JOY_HAT_UP - 1 - The hat is moved up. JOY_HAT_RIGHT - 2 - The hat is moved right. JOY_HAT_DOWN - 4 - The hat is moved down. JOY_HAT_LEFT - 8 - The hat is moved left. JOY_HAT_RIGHTUP - 3 - The hat is moved right and up. JOY_HAT_RIGHTDOWN - 6 - The hat is moved right and down. JOY_HAT_LEFTUP - 9 - The hat is moved left and up. JOY_HAT_LEFTDOWN - 12 - The hat is moved left and down.\nYou may notice that some are combinations of others. For example JOY_HAT_RIGHTUP == (JOY_HAT_RIGHT | JOY_HAT_UP ). This is because the returned value has bit flags indicating four directions: up, down, left, right. These can be combined to make diagonal directions.\nA value of -1 is returned when there is no hat or joystick detected.\nThe JoyID is optional, if it is not present, the function uses the selected joystick. You can change the selected joystick with joy_select().\nParameters [INT JoyID] - The JoyID of the joystick. INT hat - The number of the hat, starting at 0\nReturns INT : The position of the POV hat.\nExample Category:functions Category:Joystick Category:Mod_joy\n","permalink":"https://divhub.github.io/pixtudio-website/docs/joy_gethat/","title":""},{"contents":" Syntax STRING joy_name ( \u0026lt;INT JoyID\u0026gt; )\nDescription Returns the name of the specified joystick. This is a string describing the specified joystick, mostly used for the brand and model of the joystick.\nParameters INT JoyID - The JoyID of the joystick.\nReturns STRING : The name of the joystick.\nCategory:functions Category:Joystick Category:Mod_joy\n","permalink":"https://divhub.github.io/pixtudio-website/docs/joy_name/","title":""},{"contents":" Syntax INT joy_numaxes ( [ \u0026lt;INT JoyID\u0026gt; ] )\nDescription Returns the number of axes on the specified joystick. If no joystick is specified, the number of axes on the currently selected joystick will be returned.\nThe JoyID is optional, if it is not present, the function uses the selected joystick. You can change the selected joystick with joy_select().\nAlso called joy_axes().\nParameters [INT JoyID] - The JoyID of the joystick.\nReturns INT : The number of axes.\nCategory:functions Category:Joystick Category:Mod_joy\n","permalink":"https://divhub.github.io/pixtudio-website/docs/joy_numaxes/","title":""},{"contents":" Syntax INT joy_numballs ( [ \u0026lt;INT JoyID\u0026gt; ] )\nDescription Returns the number of balls on the specified joystick. If no joystick is specified, the number of balls on the currently selected joystick will be returned.\nThe JoyID is optional, if it is not present, the function uses the selected joystick. You can change the selected joystick with joy_select().\nParameters [INT JoyID] - The JoyID of the joystick.\nReturns INT : The number of balls.\nCategory:functions Category:Joystick Category:Mod_joy\n","permalink":"https://divhub.github.io/pixtudio-website/docs/joy_numballs/","title":""},{"contents":" Syntax INT joy_number ( )\nDescription Returns the number of joysticks present in the system.\nAlso called joy_numjoysticks(). The previous name number_joy() is deprecated.\nReturns INT : The number of joysticks present in the system.\nCategory:functions Category:Joystick Category:Mod_joy\n","permalink":"https://divhub.github.io/pixtudio-website/docs/joy_number/","title":""},{"contents":" Syntax INT joy_numbuttons ( [ \u0026lt;INT JoyID\u0026gt; ] )\nDescription Returns the number of buttons on the specified joystick. If no joystick is specified, the number of buttons on the currently selected joystick will be returned.\nThe JoyID is optional, if it is not present, the function uses the selected joystick. You can change the selected joystick with joy_select().\nAlso called joy_buttons().\nParameters [INT JoyID] - The JoyID of the joystick.\nReturns INT : The number of buttons.\nCategory:functions Category:Joystick Category:Mod_joy\n","permalink":"https://divhub.github.io/pixtudio-website/docs/joy_numbuttons/","title":""},{"contents":" Syntax INT joy_numhats ( [ \u0026lt;INT JoyID\u0026gt; ] )\nDescription Returns the number of hats on the specified joystick. If no joystick is specified, the number of hats on the currently selected joystick will be returned.\nThe JoyID is optional, if it is not present, the function uses the selected joystick. You can change the selected joystick with joy_select().\nParameters [INT JoyID] - The JoyID of the joystick.\nReturns INT : The number of hats.\nCategory:functions Category:Joystick Category:Mod_joy\n","permalink":"https://divhub.github.io/pixtudio-website/docs/joy_numhats/","title":""},{"contents":" Syntax INT joy_select ( \u0026lt;INT JoyID\u0026gt; )\nDescription Select the joystick with id equals to JoyID. The old name select_joy() is deprecated.\nParameters INT JoyID - The JoyID of the joystick.\nReturns INT : The ID of the selected joystick number.\nCategory:functions Category:Joystick Category:Mod_joy\n","permalink":"https://divhub.github.io/pixtudio-website/docs/joy_select/","title":""},{"contents":" Description A joystick is a general term for not just actual joysticks. Joysticks can be, but are not limited to:\n (actual) joysticks steering wheels gamepads controllers on consols GP2X main controls  A joystick provides different controls for different purposes.\nInput Axis An axis is an analogue input, used for input that should be precise or sensitive. Examples are the flight stick control of the joystick (an actual joystick), the steer of a steering wheel and the analogue control on a gamepad.\nIn Bennu, values of axes range between -32768 and 32767.\nSee joy_numaxes(), joy_getaxis()\nButton A button is a binary input, meaning it is either pressed or not.\nIn Bennu, pressed is 1 and not pressed is 0.\nSee joy_numbuttons(), joy_getbutton()\nHat A hat is an 8-way digital pad. They are also called POV-hats because they are mostly used to alter the Point Of View. Examples are POV-hats on joysticks and steering wheels, but also D-pads on a gamepad can be a hat.\nIn Bennu, hat constants are used to describe the position of a hat.\nSee joy_numhats(), joy_gethat()\nBall A ball is like a mouse: only relative values are measured.\nIn Bennu, the relative values of balls range between -32768 and 32767.\nSee joy_numballs(), joy_getball()\nCategory:General Category:Joystick Category:mod_joy\n","permalink":"https://divhub.github.io/pixtudio-website/docs/joystick/","title":""},{"contents":" Definition Joystick constants are constants used with joysticks.\nList Constant - Value - Description JOY_HAT_CENTERED - 0 - The hat is centered. JOY_HAT_UP - 1 - The hat is moved up. JOY_HAT_RIGHT - 2 - The hat is moved right. JOY_HAT_DOWN - 4 - The hat is moved down. JOY_HAT_LEFT - 8 - The hat is moved left. JOY_HAT_RIGHTUP - 3 - The hat is moved right and up. JOY_HAT_RIGHTDOWN - 6 - The hat is moved right and down. JOY_HAT_LEFTUP - 9 - The hat is moved left and up. JOY_HAT_LEFTDOWN - 12 - The hat is moved left and down.\nCategory:constantcategories\n","permalink":"https://divhub.github.io/pixtudio-website/docs/joystick_constants/","title":""},{"contents":" Definition INT key( \u0026lt;INT scancode\u0026gt; )\nChecks if a certain key is being pressed.\nParameters INT scancode - The scancode of the key to be checked.\nReturns INT : true/false: Whether the key is being pressed.\nNotes Take a look at the scancodes for a complete list.\nExample Program input_test; Begin While( !key(_esc) ) delete_text(ALL_TEXT); if( key(_left) \u0026amp;\u0026amp; !key(_right) ) write(0,160,120,4, \u0026quot;LEFT\u0026quot;); end; if( key(_right) \u0026amp;\u0026amp; !key(_left) ) write(0,160,120,4, \u0026quot;RIGHT\u0026quot;); end; frame; End; exit(); End  Used in example: delete_text(), write(), exit(), ALL_TEXT\nThis will output the words LEFT or RIGHT according to the keys you press, or it will quit the program once ESCAPE is pressed.\nCategory:functions Category:programinteraction Category:mod_key\n","permalink":"https://divhub.github.io/pixtudio-website/docs/key/","title":""},{"contents":" Keywords are reserved words for a special purpose. For example the word \u0026lsquo;function\u0026rsquo; is reserved to declare a function, and cannot be used for any other purpose. Thus you the following declaration will be invalid:\nInvalid Example 1 Function Function( ) Begin return; End  Invalid Example 2 int function; float debug;  ","permalink":"https://divhub.github.io/pixtudio-website/docs/keywords/","title":""},{"contents":" Definition INT ksort ( \u0026lt;VARSPACE array\u0026gt; , \u0026lt;VARSPACE sort-variable\u0026gt; , [\u0026lt;INT datacount\u0026gt;] )\nSorts a certain array according to a sort-variable within the elements and by sorting a certain number of elements. By default the whole array is sorted.\nIf the array elements contain only one variable each or the first one is the sort-variable, sort() can be used. For more advanced sorting, look at quicksort().\nParameters VARSPACE array - The array to be sorted. VARSPACE sort-variable - The variable within each element to be used for the sorting. [INT datacount] - Number of elements to sort.\nReturns INT: Successrate\ntrue - Sorting succeeded. false - Sorting failed, probably the type of sort-variable isn\u0026rsquo;t supported.\nExample Program sorting; Type _player String name; int score; End Const maxplayers = 5; Global _player player[maxplayers-1]; Begin // Insert some values player[0].name = \u0026quot;That one bad looking dude\u0026quot;; player[1].name = \u0026quot;Ah pretty lame guy\u0026quot;; player[2].name = \u0026quot;Some cool dude\u0026quot;; player[3].name = \u0026quot;OMG ZOMG guy\u0026quot;; player[4].name = \u0026quot;This person is ok\u0026quot;; player[0].score = 70; player[1].score = 30; player[2].score = 80; player[3].score = 90; player[4].score = 50; // Show array say(\u0026quot;-------------------- unsorted\u0026quot;); for(x=0; x\u0026lt;maxplayers; x++) say(player[x].name + \u0026quot; - \u0026quot; + player[x].score); end /* Sort by name ( quicksort() can't be used to sort Strings, as a String in Fenix is a pointer to the actual String, so it would sort the pointer addresses */ // sort() sort(player); // sorts by name because name is the first variable in each element // Show array say(\u0026quot;-------------------- name - sort()\u0026quot;); for(x=0; x\u0026lt;maxplayers; x++) say(player[x].name + \u0026quot; - \u0026quot; + player[x].score); end // ksort() ksort(player,player[0].name,maxplayers); // Show array say(\u0026quot;-------------------- name - ksort()\u0026quot;); for(x=0; x\u0026lt;maxplayers; x++) say(player[x].name + \u0026quot; - \u0026quot; + player[x].score); end /* Sort by score (sort() cannot be used here, because score is not the first variable) */ // ksort() ksort(player,player[0].score,maxplayers); // Show array say(\u0026quot;-------------------- score - ksort()\u0026quot;); for(x=0; x\u0026lt;maxplayers; x++) say(player[x].name + \u0026quot; - \u0026quot; + player[x].score); end // quicksort() quicksort(\u0026amp;player[0],sizeof(_player),maxplayers,sizeof(String),sizeof(int),0); // Show array say(\u0026quot;-------------------- score - quicksort()\u0026quot;); for(x=0; x\u0026lt;maxplayers; x++) say(player[x].name + \u0026quot; - \u0026quot; + player[x].score); end // Wait until ESC is pressed Repeat frame; Until(key(_esc)) End  Used in example: say(), sort(), ksort(), quicksort(), type, array, pointer\nCategory:functions Category:sorting Category:mod_sort\n","permalink":"https://divhub.github.io/pixtudio-website/docs/ksort/","title":""},{"contents":"List of pages about the PixTudio language.\nThe pages listed here are mostly about the syntax of the language. In the \u0026lsquo;general\u0026rsquo; category are pages describing how the language works, with all its different aspects.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/language/","title":""},{"contents":" Definition STRING lcase ( \u0026lt;STRING str\u0026gt; )\nReturns a string identical to a certain string, with the exception that all uppercase characters are replaced by their lowercase counterparts.\nParameters STRING str - The string in \u0026ldquo;normal\u0026rdquo;-form.\nReturns STRING : The string in \u0026ldquo;lowercase\u0026rdquo;-form.\nCategory:functions Category:strings Category:mod_string\n","permalink":"https://divhub.github.io/pixtudio-website/docs/lcase/","title":""},{"contents":" Definition INT len ( \u0026lt;STRING str\u0026gt; )\nReturns the length, the number of characters, of a certain string.\nAlso called Strlen().\nParameters STRING str - The string of which the length will be returned.\nReturns INT : The length of the specified string.\nCategory:functions Category:strings Category:mod_string\n","permalink":"https://divhub.github.io/pixtudio-website/docs/len/","title":""},{"contents":" Definition INT let_me_alone ( )\nKills all processes except the calling one.\nTo kill only one process, use signal().\nReturns INT : true\nExample Const screen_width = 320; screen_height = 200; screen_depth = 8; End /** * Description * Generates an error. Puts the error in the console and stdout.txt and shows it onscreen * for certain time. Immediately kills all other processes and quits the program after a * certain time. * * Parameters * String message - The error message. * int delay - The time to display the error onscreen and after which the program will quit. * In 1/100seconds. * * Returns * 0 - Success. */ Process error(String message,int delay) Begin // Put the error message in the console and in stdout.txt say(\u0026quot;[ERROR] \u0026quot; + message); // Show the error message onscreen, the size adjust for the screen width set_text_color(rgb(255,0,0)); graph = write_in_map(0,message,4); size = 100*(screen_width-10)/graphic_info(0,graph,G_WIDTH); x = screen_width/2; y = screen_height/2; // Kill all other processes let_me_alone(); // Wait the specified time timer[0] = 0; Repeat frame; Until(timer[0]\u0026gt;delay) // Unload the used graph unload_map(0,graph); return 0; End Process Main(); Begin // Set the screen mode set_mode(screen_width,screen_height,screen_depth); // Generate an error error(\u0026quot;ERROR, QUITTING IN 2 SECONDS\u0026quot;,200); Repeat frame; Until(key(_esc)) End  Category:functions Category:processinteraction Category:mod_proc\n","permalink":"https://divhub.github.io/pixtudio-website/docs/let_me_alone/","title":""},{"contents":" Up to Modules\nInternal library for blitting.\nUsage Category:modules Category:internal\n","permalink":"https://divhub.github.io/pixtudio-website/docs/libblit/","title":""},{"contents":" Up to Modules\nInternal library for drawing.\nUsage Category:modules Category:internal\n","permalink":"https://divhub.github.io/pixtudio-website/docs/libdraw/","title":""},{"contents":" Up to Modules\nInternal library for fonts.\nUsage Category:modules Category:internal Category:libgrbase\n","permalink":"https://divhub.github.io/pixtudio-website/docs/libfont/","title":""},{"contents":" Up to Modules\nInternal library for certain graphical functionality.\nUsage Category:modules Category:internal\n","permalink":"https://divhub.github.io/pixtudio-website/docs/libgrbase/","title":""},{"contents":" Up to Modules\nInternal library for joystick support.\nUsage Category:modules Category:internal Category:libsdlhandler\n","permalink":"https://divhub.github.io/pixtudio-website/docs/libjoy/","title":""},{"contents":" Up to Modules\nInternal library for keyboard.\nUsage Category:modules Category:internal Category:libsdlhandler\n","permalink":"https://divhub.github.io/pixtudio-website/docs/libkey/","title":""},{"contents":" Up to Modules\nInternal library for mouse.\nUsage Category:modules Category:internal Category:libsdlhandler Category:libgrbase Category:libvideo Category:libblit\n","permalink":"https://divhub.github.io/pixtudio-website/docs/libmouse/","title":""},{"contents":" Up to Modules\nInternal library for rendering.\nUsage Category:modules Category:internal Category:libsdlhandler Category:libgrbase Category:libblit\n","permalink":"https://divhub.github.io/pixtudio-website/docs/librender/","title":""},{"contents":" Up to Modules\nInternal library for scrolls.\nUsage Category:modules Category:internal Category:libgrbase Category:libblit Category:librender Category:libvideo\n","permalink":"https://divhub.github.io/pixtudio-website/docs/libscroll/","title":""},{"contents":" Up to Modules\nInternal library for SDL events.\nUsage Category:modules Category:internal\n","permalink":"https://divhub.github.io/pixtudio-website/docs/libsdlhandler/","title":""},{"contents":" Up to Modules\nInternal library for texts.\nUsage Category:modules Category:internal Category:libgrbase Category:libblit Category:librender Category:libfont\n","permalink":"https://divhub.github.io/pixtudio-website/docs/libtext/","title":""},{"contents":" Up to Modules\nInternal library for video.\nUsage Category:modules Category:internal Category:libgrbase\n","permalink":"https://divhub.github.io/pixtudio-website/docs/libvideo/","title":""},{"contents":" Up to Modules\nInternal library for managing the window.\nUsage Category:modules Category:internal Category:libsdlhandler\n","permalink":"https://divhub.github.io/pixtudio-website/docs/libwm/","title":""},{"contents":" Up to Log.dll functions\nDefinition FLOAT ln ( \u0026lt;FLOAT n\u0026gt; )\nReturns the natural logarithm of number n (logarithm with base ε (Euler)).\nParameters FLOAT n - The number that will be used for the logarithm.\nReturns FLOAT : The natural logarithm of n.\nExample Import \u0026quot;log.dll\u0026quot;; Global float logarithm=0.0; End Process main() Begin write_float(0,160,100,4,\u0026amp;logarithm); While(not(key(_ESC))) If (key(_1)) logarithm=ln(13.37); End Frame; End End  Used in example: import, write_float(), key(), ln()\nCategory:functions Category:logdll Category:dll\n","permalink":"https://divhub.github.io/pixtudio-website/docs/ln/","title":""},{"contents":" Definition INT load ( \u0026lt;STRING filename\u0026gt; , \u0026lt;VARSPACE data\u0026gt; )\nLoads the data read from the specified file into the specified variable.\nParameters STRING filename - The name of the file to be loaded. VARSPACE data - The variable (of any datatype) in which the data read from the file will be loaded.\nReturns INT : The number of bytes read from the file.\nNotes To check whether a file exists before it is loaded, file_exists() can be used.\nExample Program test; Global struct My_struct Level_number; string Map_name; End Begin If (file_exists(\u0026quot;myfile.sav\u0026quot;)) Load(\u0026quot;myfile.sav\u0026quot;,My_struct); // Content from myfile.sav is loaded into My_struct Write(0,10,10,0,My_struct.level_number); // A variable from the loaded struct is shown on screen Write(0,10,20,0,My_struct.map_name); // Another variable loaded is shown on screen Else Write(0,10,10,0,\u0026quot;File couldn't be loaded, it doesn't exist.\u0026quot;); End While (!key(_esc)) Frame; End End  Used in example: file_exists(), load(), write(), key()\nCategory:functions Category:files Category:mod_file\n","permalink":"https://divhub.github.io/pixtudio-website/docs/load/","title":""},{"contents":" Definition INT load_song ( \u0026lt;STRING filename\u0026gt;, [ \u0026lt;POINTER id\u0026gt;] )\nLoads a song for later use with play_song().\nThere are multiple filetypes you can load using this function. Included are:\n OGG Vorbis (.ogg). Good quality for songs and doesn\u0026rsquo;t take too much space (it\u0026rsquo;s similar to *.mp3). MIDI (.mid). Takes very low space, but it\u0026rsquo;s limited to samples of the soundcard. Modules (.xm, .it, .s3m, .mod). Like MIDI, but Modules also contain the samples themselves.  Parameters STRING filename - The music file to be loaded, including a possible path. POINTER id - Optional parameter, for loading a song in the background.\nReturns INT : SongID\n-2 - Waiting for the file to be loaded, see notes. -1 - There was an error loading the file. \u0026gt;=0 - The songID of the newly created sound.\nthe following applies for versions prior rc282:\nINT : SongID\n-1 - Could not load music file (errormessage in console). \u0026gt;=0 - The SongID.\nNotes The optional parameter id was introduced in version rc282 and allows you to load resources in the background. It used with the Offset operator. See example below:\n load_song(\u0026quot;archivo_gordo.ogg\u0026quot;, \u0026amp;idsong); while(idsong==-2) say(\u0026quot;Big File Loading ....\u0026quot;); frame; end if(idsong==-1) say(\u0026quot;Something went wrong!!\u0026quot;); exit(); // o return end say(\u0026quot;Big file loaded ok!!\u0026quot;);  Example Program example; Private int song; Begin song = load_song(\u0026quot;my_song.ogg\u0026quot;); play_song(song,0); Repeat frame; Until(key(_ESC)) OnExit unload_song(song); End  Used in example: play_song(), key(), unload_song()\nCategory:functions Category:sound Category:mod_sound\n","permalink":"https://divhub.github.io/pixtudio-website/docs/load_song/","title":""},{"contents":" Definition INT load_wav ( \u0026lt;STRING filename\u0026gt;, [ \u0026lt;POINTER id\u0026gt;] )\nLoads a sound effect in the WAV format for later use with play_wav().\nParameters STRING filename - The WAV file to be loaded, including a possible path. POINTER id - Optional parameter, for loading a wav in the background.\nReturns INT : WaveID\n-2 - Waiting for the file to be loaded, see notes. -1 - There was an error loading the file. \u0026gt;=0 - The waveID of the newly created sound.\nthe following applies for versions prior rc282:\nINT : WaveID\n-1 - Error: sound inactive; opening file 0 - Could not load wave file. \u0026gt;0 - The WaveID.\nNotes The optional parameter id was introduced in version rc282 and allows you to load resources in the background. It used with the Offset operator. See example below:\n load_wav(\u0026quot;archivo_gordo.wav\u0026quot;, \u0026amp;idwav); while(idwav==-2) say(\u0026quot;Big File Loading ....\u0026quot;); frame; end if(idwav==-1) say(\u0026quot;Something went wrong!!\u0026quot;); exit(); // o return end say(\u0026quot;Big file loaded ok!!\u0026quot;);  Example Program Private int wave; Begin wave = load_wav(\u0026quot;my_wav.wav\u0026quot;); play_wav(wave,0); Loop frame; End End  Used in example: play_wav()\nCategory:functions Category:sound Category:mod_sound\n","permalink":"https://divhub.github.io/pixtudio-website/docs/load_wav/","title":""},{"contents":" Syntax Local {local variables} End  Description Local is a reserved word used to initiate the declaration of local variables. Terminating the declaration block with an End is needed when the Local is not used in conjunction with the main code of the Program.\nFor a list of predefined local variables, see this page.\nExample  Local // Declare local variables here End Process Main() Begin End Local // Declare local variables here End  ","permalink":"https://divhub.github.io/pixtudio-website/docs/local/","title":""},{"contents":" category:general\nDefinition A local variable is a variable that is specific to a process in the same way as a public variable: they are both accessible from other places in the code than the process/function itself. However, unlike a public variable, when a local variable is declared, all following processes will have that local.\nThere\u0026rsquo;s also a number of predefined local variables.\nTo start the declaration of local variables, use Local.\nExample Local // insert local variables that you can use here End Process Main() Begin // main code End  Used in example: Process, Local, Begin, End\nCategory:variablecategories\n","permalink":"https://divhub.github.io/pixtudio-website/docs/local_variable/","title":""},{"contents":"category:variablecategories category:predefinedvariablecategories\nUp to Variable Categories\nA list of predefined local variables.\n category=local variables mode=userformat columns=1 listseparators = ,\\n* %TITLE%,, redirects = include ordermethod = titlewithoutnamespace noresultsheader = No local variables here yet. resultsfooter = \\n%PAGES% local variables replaceintitle = /\\\\? /,_ \n","permalink":"https://divhub.github.io/pixtudio-website/docs/local_variables/","title":""},{"contents":" Up to Log.dll functions\nDefinition FLOAT log ( \u0026lt;FLOAT n\u0026gt; , [\u0026lt;FLOAT b\u0026gt;] )\nReturns a logarithm of number n with base b. If b is not specified, the number 10 will be used as base.\nParameters FLOAT n - The number that will be used for the logarithm. FLOAT base - The base that will be used for the logarithm.\nReturns FLOAT : The logarithm of n.\nExample Import \u0026quot;log.dll\u0026quot;; Global float logarithm=0.0; End Process main() Begin write_float(0,160,100,4,\u0026amp;logarithm); While(not(key(_esc))) If (key(_1)) logarithm=log(1000,9); End If (key(_2)) logarithm=log(1000); End Frame; End End  Used in example: import, write_float(), key(), log()\nCategory:functions Category:logdll Category:dll\n","permalink":"https://divhub.github.io/pixtudio-website/docs/log/","title":""},{"contents":" Up to Log.dll functions\nDefinition FLOAT log2 ( \u0026lt;FLOAT n\u0026gt; )\nReturns a logarithm of number n with base 2.\nParameters FLOAT n - The number that will be used for the logarithm.\nReturns FLOAT : The logarithm of n with base 2.\nExample Import \u0026quot;log.dll\u0026quot;; Global float logarithm=0.0; End Process main() Begin write_float(0,160,100,4,\u0026amp;logarithm); While(not(key(_esc))) If (key(_1)) logarithm=log2(1024); End Frame; End End  Used in example: import, write_float(), key(), log2()\nCategory:functions Category:logdll Category:dll\n","permalink":"https://divhub.github.io/pixtudio-website/docs/log2/","title":""},{"contents":" category:general\nLoops LOOP-END, WHILE-END, REPEAT-UNTIL, FOR-END, FROM-END\nLoops are used to create iterations in your code. The statements between these words will get repeated depending on a condition. There are several types of loops:\nLoop \u0026hellip; End Loop // Statements End   The statements will be repeated indefinitely.  While \u0026hellip; End While(\u0026lt;condition\u0026gt;) // Statements End   The statements will be repeated while condition is fulfilled.  Repeat \u0026hellip; Until Repeat // Statements Until(\u0026lt;condition\u0026gt;)   The statements will be repeated until condition is fulfilled.  For \u0026hellip; End For( [ \u0026lt;initializer\u0026gt; ] ; [ \u0026lt;condition\u0026gt; ] ; [ \u0026lt;counting expression\u0026gt; ] ) // Statements End   First, initializer will be executed. Then the statements will be repeated until condition is fulfilled. After each run of the statements, counting expression is executed.  From \u0026hellip; End From \u0026lt;variable\u0026gt;=\u0026lt;startvalue\u0026gt; To \u0026lt;endvalue\u0026gt; [ Step \u0026lt;incrementvalue\u0026gt; ] ; // Statements End   First, startvalue will be assigned to the variable. Then the statements will be repeated and incrementvalue added to the variable. When the variable is greater than endvalue, the loop ends. Note that incrementvalue must be a constant. The Step \u0026lt;incrementvalue\u0026gt; part is optional.  Manipulating a loop There are more ways to manipulate a loop, both internally and externally.\nIf the code inside a loop reaches a break; statement, the loop is immediately ended. This is particularly useful in the Loop-End loop, because that one has no other way to end the loop and continue code beneath it.\nIf the code inside a loop reaches a continue; statement, it executes the possible count- or stepping statement and then continues to the checking of the condition. So in a Repeat-Until loop, it would just skip to the Until() part.\nIf the loop is run in a specific process, one can influence the execution of the loop, by changing the state of that process, by use of signal() and signals.\nExample import \u0026quot;mod_say\u0026quot; Const startvalue = 1; endvalue = 8; incrementvalue = 2; End Process Main() Private int c; Begin /* Loop */ c = startvalue; Loop say(\u0026quot;Loop: \u0026quot; + c); c+=incrementvalue; if(c\u0026gt;endvalue) break; end End say(\u0026quot;End Loop: \u0026quot; + c); /* While */ c = startvalue; While(c\u0026lt;=endvalue) say(\u0026quot;While: \u0026quot; + c); c+=incrementvalue; End say(\u0026quot;End While: \u0026quot; + c); /* Repeat */ c = startvalue; Repeat say(\u0026quot;Repeat: \u0026quot; + c); c+=incrementvalue; Until(c\u0026gt;endvalue) say(\u0026quot;End Repeat: \u0026quot; + c); /* For */ For(c=startvalue;c\u0026lt;=endvalue;c+=incrementvalue) say(\u0026quot;For: \u0026quot; + c); End say(\u0026quot;End For: \u0026quot; + c); /* From */ From c=startvalue To endvalue Step incrementvalue; say(\u0026quot;From: \u0026quot; + c); End say(\u0026quot;End From: \u0026quot; + c); End  Used in example: say(), constants, loop, if, break, while, repeat, for, from\nIn the example, all the loops do the same thing, illustrated by the use of the same constants. The output is:\nLoop: 1 Loop: 3 Loop: 5 Loop: 7 End Loop: 9 While: 1 While: 3 While: 5 While: 7 End While: 9 Repeat: 1 Repeat: 3 Repeat: 5 Repeat: 7 End Repeat: 9 For: 1 For: 3 For: 5 For: 7 End For: 9 From: 1 From: 3 From: 5 From: 7 End From: 9  ","permalink":"https://divhub.github.io/pixtudio-website/docs/loops/","title":""},{"contents":" Definition STRING lpad( \u0026lt;STRING str\u0026gt; , \u0026lt;INT length\u0026gt; )\nReturns the string str, padding (adding spaces to) the front of the string if needed to make str of length length. The original string will remain unchanged.\nIf length is smaller or equal to the length of str, the returned string is str.\nParameters STRING str - The string to pad (add spaces to). INT length - The minimal length of the returned string.\nReturns STRING: padded string\nExample import \u0026quot;mod_string\u0026quot; import \u0026quot;mod_say\u0026quot; Process Main() Private string ABC = \u0026quot;ABC\u0026quot;; string _ABC; string ABC__; Begin ABC = lpad(ABC,2); _ABC = lpad(ABC,4); ABC__ = rpad(ABC,5); say('ABC = \u0026quot;' + ABC + '\u0026quot;'); say('_ABC = \u0026quot;' + _ABC + '\u0026quot;'); say('ABC__ = \u0026quot;' + ABC__ + '\u0026quot;'); End  Used in example: say(), lpad(), rpad()\nResult:\nABC = \u0026quot;ABC\u0026quot; _ABC = \u0026quot; ABC\u0026quot; ABC__ = \u0026quot;ABC \u0026quot;  Category:functions Category:strings Category:mod_string\n","permalink":"https://divhub.github.io/pixtudio-website/docs/lpad/","title":""},{"contents":"","permalink":"https://divhub.github.io/pixtudio-website/docs/main_page/","title":""},{"contents":" Definition Main program code is the code between Begin-End belonging to the program.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/main_program/","title":""},{"contents":" Setting up Source Before we start coding, download the latest Fenix Source here and the file fenixdll.def. Put the source somewhere appropriate, like *Fenix\\Fenix 0.92a Source\\*. Search for all *.c and *.h in that folder and put it into a new folder like *Fenix\\Fenix 0.92a Includes\\*, together with fenixdll.def.\nMVC++ So we got MVC++ eh, let\u0026rsquo;s do this then.\n Tools -\u0026gt; Options -\u0026gt; TAB: Directories. Show directories for: Include files. Add the directory you created earlier, Fenix\\Fenix 0.92a Includes, to the list. Yes the includes folder.   File -\u0026gt; New will bring up the New dialog box. Select Win32 Dynamic-Link Library and name your project. Click OK. A new dialog box pops up! Select An empty DLL project. and click Finish. Click OK. I myself like to have the list on the left to display the files; to do this select FileView under it.   File -\u0026gt; New again, select C++ Source File and name your file. Click OK.   Project -\u0026gt; Add To Project -\u0026gt; Files\u0026hellip; and add fenixdll.def to your project.  Code::Blocks Ah, so you\u0026rsquo;re a cool kid on the block. Let\u0026rsquo;s get cracking.\n File -\u0026gt; New -\u0026gt; Project. Select Empty project. Specify a name and project folder. Keep GNU GCC Compiler and just hit Finish.   File -\u0026gt; New -\u0026gt; Empty file. Select yes. Name the file anything you want, but for the sake of this tutorial, have it the extension .c; you can go rogue later.   Project -\u0026gt; Properties\u0026hellip;. Select TAB Build targets. For each target you want to use (on the left), select Dynamic library at the Type (on the right). You don\u0026rsquo;t need to create an import library.   Project -\u0026gt; Build options\u0026hellip;. Select the top item in the list on the left. Go to TAB Linker settings and add the following line to the right textfield: -def fenixdll.def. Now go to TAB Search directories -\u0026gt; TAB Compiler and add the directory you created earlier, the Fenix\\Fenix 0.92a Includes.   Copy fenixdll.def to your project folder.  Coding a DLL Now you have a setup for making a DLL for Fenix, but if you use libraries, you\u0026rsquo;ll have to set them up yourself. Fenix uses SDL by default, so you will need to set this up too. If the compiler complains it cannot find SDL*.h, go to where the file is included and change the inclusion of SDL*.h to SDL/SDL*.h. It also uses zlib.\nThe most basic code will be something like this:\n#include \u0026lt;fxdll.h\u0026gt; static int DLL_MYFUNC(INSTANCE * my, int * params) { return 0; } FENIX_MainDLL RegisterFunctions (COMMON_PARAMS) { FENIX_DLLImport FENIX_export ( \u0026quot;DLL_MYFUNC\u0026quot; , \u0026quot;\u0026quot; , TYPE_DWORD , DLL_MYFUNC ) ; }  If this doesn\u0026rsquo;t compile then something went wrong during setup. Let\u0026rsquo;s assume it compiles, so I can explain the code.\nRegisterFunctions This is where you tell Fenix which functions to make available for use in Fenix. To do this, add a line like this:\nFENIX_export ( \u0026lt;CHAR * functionname\u0026gt; , \u0026lt;CHAR * parameters\u0026gt; , \u0026lt;BASETYPE returntype\u0026gt; , \u0026lt;VOID * function\u0026gt; ) ;\n CHAR * functionname: This is how the function will be called in Fenix.   CHAR * parameters: The list of parameters, possible characters are:  I - TYPE_DWORD B - TYPE_BYTE W - TYPE_WORD S - TYPE_STRING P - TYPE_POINTER F - TYPE_FLOAT\n BASETYPE returntype: The datatype of the returnvalue. Possible are:  TYPE_UNDEFINED - 0 TYPE_INT - 1 TYPE_DWORD - 2 TYPE_SHORT - 3 TYPE_WORD - 4 TYPE_SBYTE - 5 TYPE_BYTE - 6 TYPE_CHAR - 8 TYPE_FLOAT - 9 TYPE_STRING - 16 TYPE_ARRAY - 17 TYPE_STRUCT - 18 TYPE_POINTER - 19\n VOID * function: This is the function you wish Fenix to call when the function is called. This is the name of the function, without \u0026ldquo;\u0026rdquo; and can differ from the functionname used in Fenix.  Functions Like stated, the most basic function is of the form:\nstatic int DLL_MYFUNC(INSTANCE * my, int * params) { return 0; }  The first parameter is like a processID: it is the process calling this function. The second parameter is a list of parameters. For some parameters you may wish to typecast them via a \u0026lsquo;pointer tyoecast\u0026rsquo; and put them into a proper variable before using them, for example:\nfloat my_float = *(float*)\u0026amp;params[0];  The return type of this function is always static int and you should always return an int. Of course you can return other datatypes, but it needs to be \u0026lsquo;pointer typecasted\u0026rsquo; to an int, like:\nreturn *(int*)\u0026amp;my_float;  Example #include \u0026lt;fxdll.h\u0026gt; #include \u0026lt;math.h\u0026gt; static int dll_log(INSTANCE * my, int * params) { // Store the result in a variable first, for the pointer typecasting float f = logf(*(float*)\u0026amp;params[0]); return *(int*)\u0026amp;f; } FENIX_MainDLL RegisterFunctions (COMMON_PARAMS) { FENIX_DLLImport // float log( float f) FENIX_export ( \u0026quot;log\u0026quot; , \u0026quot;F\u0026quot; , TYPE_FLOAT , dll_log) ; }  Tips \u0026amp; Tricks There are a few tips and tricks, but most of them come from experience. Some from a lot of experience.\n It is possible to use the same functionname multiple times, even with different properties. The only condition is that the number of parameters needs to be different:  FENIX_export ( \u0026quot;DLL_MYFUNC\u0026quot; , \u0026quot;I\u0026quot; , TYPE_DWORD , DLL_MYFUNC ) ; FENIX_export ( \u0026quot;DLL_MYFUNC\u0026quot; , \u0026quot;II\u0026quot; , TYPE_DWORD , DLL_MYFUNC2 ) ;   Some functions are handy to use, for example gr_con_printf(). Look in the sourcecode of for example Network.dll to see how it works. Keep in mind that flooding the console isn\u0026rsquo;t very nice, so leave the option open for the user of the DLL to turn it off.   Calling a Fenix function/process from a DLL can be handy sometimes, especially when used as a callback function. Initiating a process of a variable processtype in Fenix is also possible:  static int CALL(INSTANCE * my, int * params) { INSTANCE * proc = instance_new (procdef_get(params[0]), first_instance); return instance_go (proc); }  With this method the parameters of the called process won\u0026rsquo;t be initialized. Definition: ProcessID call( \u0026lt;ProcessTypeID\u0026gt; )\nExample: proc_id = call(type MyProcName);\nSome handy functions  void gr_con_printf (const char* fmt, \u0026hellip;) Outputs the message pointed to by fmt in the Fenix console.\n int string_new (const char* ptr) Creates a new string for Fenix, a copy of the string pointed to by ptr (so you can free the passed string). Returns the stringID of the created string.\n void string_use (int stringID) Increase the usage counter of a string. Use this when you store the identifier of the string somewhere. So in practice this should always be called after string_new().\n const char* string_get (int stringID) Returns the contents of a string. This pointer is only valid as long as no other string function is called (so duplicate the string if needed).\n  Be sure to discard the string once you don\u0026rsquo;t need it anymore with string_discard () or that memory won\u0026rsquo;t be freed until bennugd exits.\n void string_discard (int stringID) Decrease the usage counter of a string. Use this when you retrieve the identifier of the string and discard it.\n  For the rest, see fxdll.h in the Fenix source. If you\u0026rsquo;d like more documentation about a function or something else, let me know (IRC/discussion page).\n\u0026ndash;Sandman 19:10, 28 July 2008 (CEST)\n","permalink":"https://divhub.github.io/pixtudio-website/docs/making_dlls/","title":""},{"contents":" Definition Bennu bitmap file. A MAP file contains a simple and rectangular graphic of 1, 8, 16 or 32bpp. These files can be loaded and generated by using load_map and save_map functions respectively.\nThe main advantage of using MAP files instead of regular PNG files (or other more extended formats) is that the former stores not only bitmap data but also other information, e.g. Control Points data, which may be useful when programming with Bennu. Its main disadvantage is not being supported by conventional graphic editing programs.\nSome IDEs and other third-party tools give support to the MAP format and allow you to convert within this and other formats.\nSee also  MAP Format Specification map_new() map_load() map_save() map_unload()  Category:filetypes\n","permalink":"https://divhub.github.io/pixtudio-website/docs/map/","title":""},{"contents":" Definition INT map_block_copy ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT destinationGraphID\u0026gt; , \u0026lt;INT destinationX\u0026gt; , \u0026lt;INT destinationY\u0026gt; , \u0026lt;INT originGraphID\u0026gt; , \u0026lt;INT x\u0026gt; , \u0026lt;INT y\u0026gt; , \u0026lt;INT width\u0026gt; , \u0026lt;INT height\u0026gt;, \u0026lt;INT blitflags\u0026gt; )\nDraws (blits) a rectangular block from one graphic onto another graphic.\nIf the entire graphic is to be blitted, map_put() or map_xput() can be used.\nParameters INT fileID - The fileID of the file that holds the destination and origin graphics. INT destinationGraphID - The graphID of the graphic to draw on. INT destinationX - Where on the destination graph\u0026rsquo;s x-axis to put the block. INT destinationY - Where on the destination graph\u0026rsquo;s y-axis to put the block. INT originGraphID - The graphID of the graphic to draw with. INT x - The x-coordinate of the upperleft corner of the origin block. INT y - The y-coordinate of the upperleft corner of the origin block. INT width - The width of the block in pixels. INT height - The height of the block in pixels. INT blitflags - What blit flags to draw the graphic with.\nReturns INT : true\nNotes Blit flags can be used to give the drawing (blitting) a special effect.\nErrors Invalid origin graph - The origin graph is invalid. Invalid destination graph - The destination graph is invalid. Unsupported color depth - The origin graphic\u0026rsquo;s color depth is greater than the destination graph\u0026rsquo;s.\nCategory:functions Category:maps Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/map_block_copy/","title":""},{"contents":" Definition POINTER map_buffer ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; )\nGet access to the memory buffer of the map. This function is usefull in combination with Memset(). This way you can manipulate the actual bytes of the map.\nParameters INT fileID - The file that holds the graph. INT graphID - The graph to get information from.\nReturns POINTER : Pointer to the memory contents of the map.\nExample In this example I\u0026rsquo;m going to demonstrate how you can manipulate the pixel buffer of the map. I load the same map twice (each with their own ID), and one of them is butchered by messing with it\u0026rsquo;s pixel buffer. By assiging that map to a Pointer with map_buffer(), we can use Memset() to change the bytes in the memory area that the map occupies.\nIMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_key\u0026quot;; IMPORT \u0026quot;mod_map\u0026quot;; IMPORT \u0026quot;mod_video\u0026quot;; IMPORT \u0026quot;mod_wm\u0026quot;; IMPORT \u0026quot;mod_draw\u0026quot;; IMPORT \u0026quot;mod_screen\u0026quot;; IMPORT \u0026quot;mod_mem\u0026quot;; IMPORT \u0026quot;mod_text\u0026quot;; GLOBAL int map_id; // id code of the map to load int map_id2; pointer p_map; // pointer to the map_buffer PROCESS main(); BEGIN set_mode(320,200,32); write(0,10,10,3,\u0026quot;map_buffer example, press 'ESC' to quit.\u0026quot;); write(0,10,30,3,\u0026quot;press '1' to show the modified map.\u0026quot;); write(0,10,40,3,\u0026quot;press '2' to show the orginial map.\u0026quot;); // load two maps, this map can be found in bennupack: 2 Medium\\IA\\PATH.FIND\\3COCHE.MAP // it is a the \u0026quot;car\u0026quot; graphic of the pathfind tutorial for TYCO. Both maps are the same, // but one of them we're going to modify with map_buffer(). map_id=load_map(\u0026quot;3COCHE.MAP\u0026quot;); map_id2=load_map(\u0026quot;3COCHE.MAP\u0026quot;); // same map, but this one is left intact graph=map_id2; // original map x=100; y=100; // get the memory adress of the \u0026quot;raw\u0026quot; pixel buffer of the map. p_map=map_buffer(0,map_id); // now that we've got acccess to the pixel buffer, we can change individual bytes. // with memset we can modify memory contents of individual bytes. // in this case, we change the first 1000 bytes into the color #100. memset(p_map,100,1000); // no, we're offsetting 200 adresses from the start of the memory block, and change another // 1000 bytes into a different color. memset(p_map+200,150,1000); LOOP IF (key(_esc)) BREAK; END IF (key(_1)) // show the \u0026quot;butchered\u0026quot; map FRAME(100); graph=map_id; say(\u0026quot;showing map modified with map_buffer()\u0026quot;); END IF (key(_2)) // show the original map FRAME(100); graph=map_id2; say(\u0026quot;showing original map\u0026quot;); END FRAME; END END  Used in example: Load_map(), Memset(), Write(), Say(), Pointer()\nNotes In the Memset() function, indiviual bytes are used. The amount of bytes to store the color of one pixel depends on it\u0026rsquo;s colordepth. In 8 bit mode, you need only one byte per pixel, in rgb mode 3 bytes and in rgba mode 4 bytes per pixel. So that is something you should be aware of. This is a similair caveat as with the Alloc() function, because you\u0026rsquo;re dealing with raw memory contents here.\nCategory:functions Category:maps Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/map_buffer/","title":""},{"contents":" Definition INT map_clear ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; , \u0026lt;WORD color\u0026gt; )\nClears a certain graph to a certain color.\nParameters INT fileID - The file that holds the graphic. INT graphID - The graphic to clear. WORD color - The color used to clear.\nReturns INT : true\nNotes Instead of using map_clear() to clear the screen background, clear_screen() is recommended as it is a little bit faster.\nErrors Unsupported color depth - The specified graph has a not supported color depth.\nExample Program a_map_is_born; Private int map; Begin // Create a new graph of size 100x100 and color depth of 8bit map = new_map(100,100,8); // Clear the map red map_clear(0,map,rgb(255,0,0)); // Put it in the center of the screen put(0,map,160,100); Loop frame; End End  Used in example: new_map(), put()\nThis will result in something like:\nhttp://wwwhome.cs.utwente.nl/~bergfi/fenix/wiki/new_map.PNG\nCategory:functions Category:maps Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/map_clear/","title":""},{"contents":" Definition INT map_clone ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; )\nClones a certain graphic and puts it in the system file.\nParameters INT fileID - The fileID of the file holding the graphic. INT graphID - The graphID of the graphic to be cloned.\nReturns INT : GraphID\n0 - Invalid graphic specified; \u0026gt;0 - The graphID of the clone graphic.\nErrors Unsupported color depth - The specified graph has a not supported color depth. (Console) Insufficient memory - There is insufficient memory available. This error doesn\u0026rsquo;t occur often. (Console)\nCategory:functions Category:maps Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/map_clone/","title":""},{"contents":" Syntax INT map_exists ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; )\nDescription Checks if a graphic exists in the specified File with the specified graphID.\nParameters INT fileID - The fileID of the file that holds the graphic (or not). INT graphID - The graphID.\nReturns INT : Whether the graphic exists\nfalse - The specified graphic does not exist. true - The specified graphic exists.\nCategory:functions Category:maps Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/map_exists/","title":""},{"contents":" Format Specification This section describes the structure of a MAP file. It is not necessary to know these details to program games in Bennu, but they will be of help for those who want to develop external tools which are able to read or write MAP files.\nA MAP file does not have compression. Bennu, however, supports transparently GZIP compression in files and usually MAP files are saved to disk compressed with GZIP. In the following we will assume that the MAP file is not compressed.\nHeader (+0) MAP files start with the following header (8 bytes).\nName Size (bytes) Description\nMAGIC 3 Three character string identifying the MAP file. Must contain \u0026ldquo;m01\u0026rdquo;, \u0026ldquo;map\u0026rdquo;, \u0026ldquo;m16\u0026rdquo; or \u0026ldquo;m32\u0026rdquo;, in lower case. Depending on these value the information in the MAP file will refer to a 1 (m01), 8 (map), 16 (m16) or 32 (m32) bits per pixel (depth) MAP. MS-DOS Termination 4 The following bytes: 0x1A, 0x0D, 0x0A y 0x00. This termination will prevent a TYPE (in MS-DOS) command to show the binary data of the file. VERSION 1 Version number. The byte 0x00 for the specification in this document.\nSubtotal: 8 bytes\nDescriptor (+8) Following the header there are 40 bytes which describes the MAP file. This section can be understood as an extension of the header.\nName Size (bytes) Description\nWIDTH 2 The width in pixels of the graphic. HEIGHT 2 The height in pixels of the graphic. CODE 4 The GraphID of the graphic. Bennu ignores this value (a MAP loaded in Bennu will not have a graphID unless it is inside an FPG). This field, however, is kept for backwards compatibility with DIV and Fenix. When writing MAP files for Bennu you should always use 0. NAME 32 A 32 bytes string which may be used to briefly identify by name the contents of the graphic. If the length of the description is less than 32 bytes, the string must be null-terminated (last character must be \u0026lsquo;\\0\u0026rsquo;).\nSubtotal: 40 bytes\nPalette (+48) See PAL.\nName Size (bytes) Description\nPALETTE 768 See PAL.\nSubtotal: 768 bytes\nRanges of Colours (+816) See PAL.\nName Size (bytes) Description\nRANGE OF COLOURS 576 See PAL.\nSubtotal: 576 bytes\nControl Points (+1392) A section to store control points.\nName Size (bytes) Description\nNUMBER OF CONTROL POINTS 2 The number of control points stored in this MAP.\nCONTROL POINTS x Size Description \u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; 2 X coordinate of the first control point. 2 Y coordinate of the first control point. \u0026hellip; \u0026hellip; 2 X coordinate of the last control point. 2 Y coordinate of the last control point.\n The [control points](control_point \u0026quot;wikilink\u0026quot;). The coordinates of a control point are stored together in 4 bytes: first 2 for the x coordinate, last 2 for the y coordinate. This is repeated as many times as there are control points stored. *x = 4 \\* (number of control points)*  Subtotal: 2 + (4 * (number of control points) ) bytes\nGraphic data (+1394+4*(number of control points)) The actual graphic data.\nName Size (bytes) Description\nGRAPHIC DATA x \u0026mdash;\u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;- 0 (+0) 1 (+2) 2 (+4) 3 (+6) 4 (+8) 5 (+10) 6 (+12) 7 (+14) 8 (+16) 8 (+18) 10 (+20) 11 (+22) 12 (+24) 13 (+26) 14 (+28) 15 (+30) \u0026mdash;\u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;-\n The depth of the graphic (see [Header](#Header_(+0) \u0026quot;wikilink\u0026quot;)) determines how the data is stored. 1bpp graphics: Pixels are stored by rows. Each byte stores up to 8 pixels, meaning that a pixel is stored in one bit. If the width of the image in pixels is not multiple of 8, last byte of the row will contain up to 7 unused bits (least significant bits). [Bennu](Bennu \u0026quot;wikilink\u0026quot;) ignores these bits so they can be set either to 0 or 1. 8bpp graphics: Each pixel is stored in one byte. The value stored does not represent the color, but an index to the 256-color palette (see [Palette](#Palette_(+48) \u0026quot;wikilink\u0026quot;)). All pixels are stored consecutively, i.e., there is no padding. 16bpp graphics: Each pixel uses 2 bytes to store the color of the pixel. The color is in RGB565 format, meaning the first 5 most significant bits are used to store the red component, next 6 to store the green component and last 5 least significant bits store the blue component. Although this format does not contain information on alpha, [Bennu](Bennu \u0026quot;wikilink\u0026quot;) understands color 0x0000 as transparent. All pixels are stored consecutively, i.e., there is no padding. The example to the right shows a 16bit 4x4 graphic, with pixel numbers outside and byte offset inside the parenthesis. 32bpp graphics: Each pixel uses 4 bytes to store the color of the pixel. The color is in ARGB format, 8 bits for alpha component, 8 bits for red, 8 bits for green and 8 bits for blue. A pixel with an alpha component set to 0xFFFFFFFF is totally opaque while if set to 0x00000000 it will be completely transparent. All pixels are stored consecutively, i.e., there is no padding. *x = (width + ((8 - (width % 8)) \u0026amp; 7)) / 8 \\* height* (depth in bytes -1bpp graphics-) *x = width \\* height \\* depth/8* (depth in bytes -8, 16, 32bpp graphics-)  Subtotal: width * height * depth/8 bytes (depth in bytes)\nTotal: 1394 + (4*(number of control points)) + (width * height * depth/8) bytes\n","permalink":"https://divhub.github.io/pixtudio-website/docs/map_format_specification/","title":""},{"contents":" Definition INT map_get_pixel ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; , \u0026lt;INT x\u0026gt; , \u0026lt;INT y\u0026gt; )\nReturns the color on the specified graphic of the specified pixel.\nParameters INT fileID - The fileID of the file that holds the graphic. INT graphID - The graphID of the graphic to get the pixel from. INT x - The X-coordinate of the pixel the color is wanted. INT y - The Y-coordinate of the pixel the color is wanted.\nReturns INT : The color\n-1 - Error: invalid map; invalid; invalid pixel; invalid color depth of map. Note: in 32bit graphs this can be a color too. !-1 - The color.\nCategory:functions Category:maps Category:mod_draw Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/map_get_pixel/","title":""},{"contents":" Definition INT map_info ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; , \u0026lt;INT infotype\u0026gt; )\nGets some information about the graph specified. This function is also known as Graphic_info() and Map_info_get().\nParameters INT fileID - The file that holds the graph. INT graphID - The graph to get information from. INT infotype - What type of information you want.\nReturns INT : Returns the information you want.\nIf the specified graph was invalid it returns 0.\nIf the specified infotype was not recognized it returns 1.\nExample See Graphic_info() for example.\nCategory:functions Category:maps Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/map_info/","title":""},{"contents":" Definition INT map_info_get ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; , \u0026lt;INT infotype\u0026gt; )\nGets some information about the graph specified. This function is also known as Graphic_info() and Map_info().\nParameters INT fileID - The file that holds the graph. INT graphID - The graph to get information from. INT infotype - What type of information you want.\nReturns INT : Returns the information you want.\nIf the specified graph was invalid it returns 0.\nIf the specified infotype was not recognized it returns 1.\nExample See Graphic_info() for example.\nCategory:functions Category:maps Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/map_info_get/","title":""},{"contents":" Definition INT map_info_set ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; , \u0026lt;INT info_type\u0026gt; , \u0026lt;INT value\u0026gt; )\nChanges the x or y coordinate of the center pixel (controlpoint 0). This function is also known as Graphic_set().\nParameters INT fileID - The file that holds the graph. INT graphID - The graph to get information from. INT info_type - What type of information you want to change, see note. INT value - The new x or y coordinate of the center pixel.\nReturns INT : Returns the information you want.\nIf the specified graph was invalid it returns 0.\nIf the specified infotype was not recognized it returns 1.\nExample IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_key\u0026quot;; IMPORT \u0026quot;mod_map\u0026quot;; IMPORT \u0026quot;mod_video\u0026quot;; IMPORT \u0026quot;mod_wm\u0026quot;; IMPORT \u0026quot;mod_draw\u0026quot;; IMPORT \u0026quot;mod_screen\u0026quot;; GLOBAL int map_id; int status; PROCESS main(); BEGIN set_mode(320,200,32); map_id=load_map(\u0026quot;3COCHE.MAP\u0026quot;); // print the original data. say(\u0026quot;width of the map: \u0026quot;+graphic_info(0,map_id,G_WIDTH)); say(\u0026quot;height of the map: \u0026quot;+graphic_info(0,map_id,G_HEIGHT)); say(\u0026quot;g_x_center of the map: \u0026quot;+graphic_info(0,map_id,G_X_CENTER)); say(\u0026quot;g_y_center of the map: \u0026quot;+graphic_info(0,map_id,G_Y_CENTER)); // change the x and y coordinates of the center pixel and display it. status=map_info_set(0,map_id,G_X_CENTER,20); status=map_info_set(0,map_id,G_Y_CENTER,10); say(\u0026quot;center pixel changed:\u0026quot;); say(\u0026quot;g_x_center of the map: \u0026quot;+graphic_info(0,map_id,G_X_CENTER)); say(\u0026quot;g_y_center of the map: \u0026quot;+graphic_info(0,map_id,G_Y_CENTER)); say(\u0026quot;status: \u0026quot;+status); graph=map_id; x=100; y=100; LOOP IF (key(_esc)) BREAK; END FRAME; END END  Notes As infotype, only two options are valid:\nG_X_CENTER - Change the x coordinate of the center pixel. G_Y_CENTER - Change the y coordinate of the center pixel.\nCategory:functions Category:maps Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/map_info_set/","title":""},{"contents":" Definition INT map_load ( \u0026lt;STRING filename\u0026gt;, [ \u0026lt;POINTER id\u0026gt;] )\nCreates a new graphic, using the specified MAP file as contents and puts it in the system file. Returns the graphID of the created graphic. The color depth of the created graphic will be the same as the loaded MAP file.\nThe previous name load_map() is deprecated.\nParameters STRING filename - The name of the MAP file to be loaded, including a possible path. POINTER id - Optional parameter, for loading a map in the background.\nReturns INT : graphID\n-2 - Waiting for the file to be loaded, see notes. -1 - There was an error loading the file. \u0026gt;=0 - The graphID of the newly created graphic.\nthe following applies for versions prior rc282:\nINT : graphID\n0 - There was an error loading the file. \u0026gt;0 - The graphID of the newly created graphic.\nNotes The optional parameter id was introduced in version rc282 and allows you to load resources in the background. It used with the Offset operator. See example below:\n load_map(\u0026quot;archivo_gordo.map\u0026quot;, \u0026amp;idmap); while(idmap==-2) say(\u0026quot;Big File Loading ....\u0026quot;); frame; end if(idmap==-1) say(\u0026quot;Something went wrong!!\u0026quot;); exit(); // o return end say(\u0026quot;Big file loaded ok!!\u0026quot;);  Category:functions Category:maps Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/map_load/","title":""},{"contents":" Definition STRING map_name ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; )\nRetrieves the name of an in-game graphic.\nParameters INT fileID - The fileID of the file that holds the graphic. INT graphID - The graphID of the graphic.\nReturns STRING : Name of the graphic\nCategory:functions Category:maps Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/map_name/","title":""},{"contents":" Definition INT map_new ( \u0026lt;INT width\u0026gt; , \u0026lt;INT height\u0026gt; , \u0026lt;INT depth\u0026gt;, [ \u0026lt;INT flags\u0026gt; ] )\nCreates a new graphic, sets the color of all pixels to 0 (transparent) and puts it in the system file.\nThe previous name new_map() is deprecated.\nParameters INT width - The width of the to be created graph in pixels. INT height - The height of the to be created graph in pixels. INT depth - The color depth of the to be created graph in bits [INT flags] - can be: B_CLEAR (bitmap clear) or 0 (no clear new bitmap)\nReturns INT : GraphID\n0 - There was an error. \u0026gt;0 - The graphID of the newly created graphic.\nErrors Unsupported color depth - The specified color depth is not supported. (Console) Insufficient memory - There is insufficient memory available. This error doesn\u0026rsquo;t occur often. (Console)\nExample import \u0026quot;mod_map\u0026quot; import \u0026quot;mod_screen\u0026quot; import \u0026quot;mod_key\u0026quot; Process Main() Private int map; Begin // Create a new graph of size 100x100 and color depth of 8bit map = map_new(100,100,8); // Clear the map red map_clear(0,map,rgb(255,0,0)); // Put it in the center of the screen put(0,map,160,100); Repeat frame; Until(key(_ESC)) End  Used in example: map_new(), map_clear(), put(), key()\nThis will result in something like:\nCategory:functions Category:maps Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/map_new/","title":""},{"contents":" Syntax INT map_put ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT destinationGraphID\u0026gt; , \u0026lt;INT originGraphID\u0026gt; , \u0026lt;INT x\u0026gt; , \u0026lt;INT y\u0026gt; )\nDescription Draws (blits) a graph onto another graph.\nIf more advanced parameters are needed, map_xput() can be used. If a graph from one file needs to be drawn onto another graph in a different file, or a separate width and height scaling is needed, map_xputnp() can be used.\nParameters INT fileID - The fileID of the file that holds the graphics. INT destinationGraphID - The graphID of the graphic to draw on. INT originGraphID - The graphID of the graphic to draw with. INT x - Where on the destination graphic\u0026rsquo;s x-axis to put the graph. INT y - Where on the destination graphic\u0026rsquo;s y-axis to put the graph.\nReturns INT : true\nNotes The x and y parameters denote where to draw the graph, that is, where the center of the to be drawn graph will be.\nErrors Invalid origin graph - The origin graph is invalid. Invalid destination graph - The destination graph is invalid. Unsupported color depth - The origin graph\u0026rsquo;s color depth is greater than the destination graph\u0026rsquo;s.\nExample import \u0026quot;mod_video\u0026quot; import \u0026quot;mod_map\u0026quot; import \u0026quot;mod_wm\u0026quot; Process Main() Private int destgraph; int origgraph1; int origgraph2; Begin // Set the mode to 16bit and some resolution set_mode(320,200,16); // Makes the destination graphic a red square destgraph=new_map(100,100,16); map_clear(0,destgraph,rgb(255,0,0)); // Makes the first origin graphic a green square origgraph1=new_map(100,100,16); map_clear(0,origgraph1,rgb(0,255,0)); // Makes the second origin graphic a blue square origgraph2=new_map(100,100,16); map_clear(0,origgraph2,rgb(0,0,255)); // Draws the blue and green squares at a random position on the red square map_put(0,destgraph,origgraph1,rand(0,100),rand(0,100)); map_put(0,destgraph,origgraph2,rand(0,100),rand(0,100)); // Shows the final graph put(0,destgraph,160,100); Repeat frame; Until(exit_status) End  Used in example: set_mode(), new_map(), map_clear(), map_put(), put(), key(), exit_status\nThis will result in something like:\nCategory:functions Category:maps Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/map_put/","title":""},{"contents":" Definition INT map_put_pixel ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; , \u0026lt;INT x\u0026gt; , \u0026lt;INT y\u0026gt; , \u0026lt;INT color\u0026gt; )\nDraws a single colored pixel on a graph.\nParameters INT fileID - The file that holds the graph. INT graphID - The graph to draw on. INT x - Where on the graph\u0026rsquo;s x-axis to put the pixel. INT y - Where on the graph\u0026rsquo;s y-axis to put the pixel. INT color - What color to draw.\nReturns INT : true\nErrors Invalid map - Map doesn\u0026rsquo;t exist. Unsupported color depth - Destination graph is of an unsupported colordepth.\nExample import \u0026quot;mod_video\u0026quot; import \u0026quot;mod_map\u0026quot; import \u0026quot;mod_screen\u0026quot; import \u0026quot;mod_wm\u0026quot; import \u0026quot;mod_draw\u0026quot; Process Main() Private int map; int i; Begin // Set the mode to 16bit and some res set_mode(320,200,16); // Create a blue-ish square map map = new_map(100,100,16); map_clear(0,map,rgb(50,100,150)); // Puts 100 yellow-ish pixels in random places in the graphic for(i=0; i\u0026lt;100; i++) map_put_pixel(0,map,rand(0,100),rand(0,100),rgb(255,255,55)); end // Puts the map in the center of the screen put(0,map,160,100); Repeat frame; Until(exit_status) End  Used in example: set_mode(), new_map(), map_clear(), map_put_pixel(), rand(), put()\nCategory:functions Category:maps Category:mod_draw Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/map_put_pixel/","title":""},{"contents":" Definition INT map_save ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; , \u0026lt;STRING filename\u0026gt; )\nSaves the specified graphic as filename with the format MAP.\nThe previous name save_map() is deprecated.\nParameters INT fileID - The fileID of the file that holds the graphic. INT graphID - The graphID of the graphic to unload. STRING filename - The name of the MAP file to be saved, including a possible path.\nReturns INT : Successrate\nfalse - An error: Invalid graphic; could not open file. true - Graphic saved.\nCategory:functions Category:maps Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/map_save/","title":""},{"contents":" Definition INT map_set_name ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; , \u0026lt;STRING name\u0026gt;)\nSets the name of a graphic in an FPG. Useful in combination with map_name() to retrieve names of files and save_fpg() to save any changed values.\nParameters INT fileID - The fileID of the file that holds the graphic. INT graphID - The graphID of the graphic. STRING name - The new name of the graphic specified.\nReturns INT : 0\nCategory:functions Category:maps Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/map_set_name/","title":""},{"contents":" Definition INT map_unload ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; )\nFrees the memory used by the specified graphic. The associated (fileID,graphID) combination is no longer valid afterwards.\nAlso called map_del(). The previous name unload_map is deprecated.\nParameters INT fileID - The fileID of the file that holds the graphic. INT graphID - The graphID of the graphic to unload.\nReturns INT : Successrate\nfalse - Invalid graphic. true - Graphic unloaded.\nCategory:functions Category:maps Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/map_unload/","title":""},{"contents":" Definition INT map_xput ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT destinationGraphID\u0026gt; , \u0026lt;INT originGraphID\u0026gt; , \u0026lt;INT x\u0026gt; , \u0026lt;INT y\u0026gt; , \u0026lt;INT angle\u0026gt; , \u0026lt;INT size\u0026gt; , \u0026lt;INT blitflags\u0026gt; )\nDraws (blits) a graphic onto another graphic.\nIf the advanced parameters aren\u0026rsquo;t needed, map_put() can be used. If a graphic from one file needs to be drawn onto another graphic in a different file, or a separate width and height scaling is needed, map_xputnp() can be used.\nParameters INT fileID - The fileID of the file that holds the graphics. INT destinationGraphID - The graphID of the graphic to draw on. INT originGraphID - The graphID of the graphic to draw with. INT x - Where on the destination graphic\u0026rsquo;s x-axis to put the graphic. INT y - Where on the destination graphic\u0026rsquo;s y-axis to put the graphic. INT angle - What angle to draw the graphic at. INT size - What size to draw the graphic at. INT blitflags - What blit flags to draw the graphic with.\nReturns INT : true\nNotes The x and y parameters denote where to draw the graphic, that is, where the center of the to be drawn graphic will be. Blit flags can be used to give the drawing (blitting) a special effect.\nWhen angle is 0 and size is 100, the speed is greater, because the graph doesn\u0026rsquo;t need rotating or scaling.\nErrors Unsupported color depth - The origin graphic\u0026rsquo;s color depth is greater than the destination graphic\u0026rsquo;s.\nExample import \u0026quot;mod_video\u0026quot; import \u0026quot;mod_map\u0026quot; import \u0026quot;mod_wm\u0026quot; Process Main() Private int destgraph; int origgraph; Begin // Set the mode to 16bit and some resolution set_mode(320,200,16); // Makes the destination graphic a red square destgraph=new_map(100,100,16); map_clear(0,destgraph,rgb(255,0,0)); // Makes the origin graphic a blue square origgraph=new_map(100,100,16); map_clear(0,origgraph,rgb(0,0,255)); // Draws the blue square on the center of the red square transparently, // at a random angle and a random size map_xput(0,destgraph,origgraph,50,50,rand(-180000,180000),rand(50,150),4); map_xput(0,destgraph,origgraph,50,50,rand(-180000,180000),rand(50,150),4); // Shows the final graph put(0,destgraph,160,100); Repeat frame; Until(exit_status) End  Used in example: set_mode(), new_map(), map_clear(), map_xput(), put(), key(), exit_status\nThis will result in something like:\nCategory:functions Category:maps Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/map_xput/","title":""},{"contents":" Definition INT map_xputnp ( \u0026lt;INT destinationFileID\u0026gt; , \u0026lt;INT destinationGraphID\u0026gt; , \u0026lt;INT originFileID\u0026gt; , \u0026lt;INT originGraphID\u0026gt; , \u0026lt;INT x\u0026gt; , \u0026lt;INT y\u0026gt; , \u0026lt;INT angle\u0026gt; , \u0026lt;INT scale_x\u0026gt; , \u0026lt;INT scale_y\u0026gt; , \u0026lt;INT blitflags\u0026gt; )\nDraws (blits) a graphic onto another graphic.\nIf the advanced parameters aren\u0026rsquo;t needed, map_put() or map_xput() can be used.\nParameters INT destinationFileID - The fileID of the file that holds the destination graphic. INT destinationGraphID - The graphID of the graphic to draw on. INT originFileID - The fileID of the file that holds the origin graphic. INT originGraphID - The graphID of the graphic to draw with. INT x - Where on the destination graph\u0026rsquo;s x-axis to put the graphic. INT y - Where on the destination graph\u0026rsquo;s y-axis to put the graphic. INT angle - What angle to draw the graphic at. INT scale_x - What size to draw the origin graphic\u0026rsquo;s x-axis at (also see size_x) INT scale_y - What size to draw the origin graphic\u0026rsquo;s y-axis at (also see size_y). INT blitflags - What blit flags to draw the graphic with.\nReturns INT : true\nNotes The x and y parameters denote where to draw the graphic, that is, where the center of the to be drawn graphic will be. Blit flags can be used to give the drawing (blitting) a special effect.\nWhen angle is 0 and size is 100, the speed is greater, because the graphic doesn\u0026rsquo;t need rotating or scaling.\nErrors Unsupported color depth - The origin graphic\u0026rsquo;s color depth is greater than the destination graph\u0026rsquo;s.\nExample import \u0026quot;mod_video\u0026quot; import \u0026quot;mod_map\u0026quot; import \u0026quot;mod_wm\u0026quot; Process Main() Global int destgraph; int origgraph; Begin // Set the mode to 16bit and some resolution set_mode(320,200,16); // Makes the destination graphic a red square destgraph=new_map(100,100,16); map_clear(0,destgraph,rgb(255,0,0)); // Makes the origin graphic a blue square origgraph=new_map(100,100,16); map_clear(0,origgraph,rgb(0,0,255)); // Draws the blue square on the center of the red square transparently, // at a random angle and a random size map_xputnp(0,destgraph,0,origgraph,50,50,rand(-180000,180000),rand(50,150),rand(50,150),4); map_xputnp(0,destgraph,0,origgraph,50,50,rand(-180000,180000),rand(50,150),rand(50,150),4); // Shows the final graph put(0,destgraph,160,100); Repeat frame; Until(exit_status) End  Used in example: set_mode(), new_map(), map_clear(), map_xputnp(), put(), exit_status, blit flags\nThis will result in something like:\nCategory:functions Category:maps Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/map_xputnp/","title":""},{"contents":" Definition CHAR MAX_BYTE = 255\nThe maximum integer value reachable with a byte (unsigned char).\nSee also MIN_BYTE.\nCategory:constants Category:internal\n","permalink":"https://divhub.github.io/pixtudio-website/docs/max_byte/","title":""},{"contents":" Definition CHAR MAX_CHAR = 255\nThe maximum integer value reachable with a char (byte).\nSee also MIN_CHAR.\nCategory:constants Category:internal\n","permalink":"https://divhub.github.io/pixtudio-website/docs/max_char/","title":""},{"contents":" Definition DWORD MAX_DWORD = 4294967295\nThe maximum integer value reachable with a dword (unsigned integer).\nSee also MIN_DWORD.\nCategory:constants Category:internal\n","permalink":"https://divhub.github.io/pixtudio-website/docs/max_dword/","title":""},{"contents":" Definition INT MAX_INT = 2147483647\nThe maximum integer value reachable with an int.\nSee also MIN_INT.\nCategory:constants Category:internal\n","permalink":"https://divhub.github.io/pixtudio-website/docs/max_int/","title":""},{"contents":" Definition CHAR MAX_SBYTE = 127\nThe maximum integer value reachable with a signed byte.\nSee also MIN_SBYTE.\nCategory:constants Category:internal\n","permalink":"https://divhub.github.io/pixtudio-website/docs/max_sbyte/","title":""},{"contents":" Definition SHORT MAX_SHORT = 32767\nThe maximum integer value reachable with a short (signed word).\nSee also MIN_SHORT.\nCategory:constants Category:internal\n","permalink":"https://divhub.github.io/pixtudio-website/docs/max_short/","title":""},{"contents":" Definition WORD MAX_WORD = 65535\nThe maximum integer value reachable with a word (unsigned short).\nSee also MIN_WORD.\nCategory:constants Category:internal\n","permalink":"https://divhub.github.io/pixtudio-website/docs/max_word/","title":""},{"contents":" Definition INT memcmp ( \u0026lt;VOID POINTER ptr1\u0026gt; , \u0026lt;VOID POINTER ptr2\u0026gt; , \u0026lt;INT number\u0026gt; )\nCompares the first number bytes of the block of memory pointed by ptr1 to the first number bytes pointed by ptr2, returning zero if they all match or a value different from zero representing which is greater if they do not.\nAlso called mem_cmp().\nParameters VOID POINTER ptr1 - Pointer to a block of memory VOID POINTER ptr2 - Pointer to a block of memory. INT number - The number of bytes to be checked.\nReturns INT : Difference\n0 - The blocks of memory are identical. \u0026gt;0 - The first differing byte in both memory blocks has a greater value in ptr1. \u0026lt;0 - The first differing byte in both memory blocks has a greater value in ptr2.\nA byte ranges from 0 to 255, meaning 189 is a greater value than 105.\nExample Program example; Const elements = 10; End Private byte pointer pbyte1; byte pointer pbyte2; int result; End Begin // Allocate memory pbyte1 = alloc(elements); pbyte2 = alloc(elements); // Make the blocks the same and compare memset(pbyte1,3,elements); memset(pbyte2,3,elements); result = memcmp(pbyte1,pbyte2,elements); // You can also compare the first 5 bytes, // or the first elements/2 bytes, it // depends on what you want. say(\u0026quot;Memcmp 1: \u0026quot; + result); // Make the first block have a greater value and compare pbyte1[0] = 4; result = memcmp(pbyte1,pbyte2,elements); say(\u0026quot;Memcmp 2: \u0026quot; + result); // Make the blocks the same and compare pbyte2[0] = 4; result = memcmp(pbyte1,pbyte2,elements); say(\u0026quot;Memcmp 3: \u0026quot; + result); // Make the first block have a greater value and compare pbyte2[1] = 5; result = memcmp(pbyte1,pbyte2,elements); say(\u0026quot;Memcmp 4: \u0026quot; + result); Repeat frame; Until(key(_esc)) // Free the used memory free(pbyte1); free(pbyte2); End  Used in example: alloc(), memset(), memcmp(), say(), free(), pointer\nCategory:functions Category:memory Category:mod_mem\n","permalink":"https://divhub.github.io/pixtudio-website/docs/memcmp/","title":""},{"contents":" Syntax INT memcopy ( \u0026lt;VOID POINTER destination\u0026gt; , \u0026lt;VOID POINTER origin\u0026gt; , \u0026lt;INT size\u0026gt; )\nDescription Copies a certain number of bytes from one point in memory to another.\nDifference between memmove() and memcopy() is that the first one can be used if the destination section and origin section overlap. With memcopy(), this can go wrong, though some systems make memcopy() safe too.\nAlso called mem_copy().\nParameters VOID POINTER destination - Pointer to the first byte of the destination. VOID POINTER origin - Pointer to the first byte of the origin. INT size - The size of the to be copied memory in bytes.\nReturns INT : true\nExample import \u0026quot;mod_mem\u0026quot; import \u0026quot;mod_say\u0026quot; Const elements = 5; End Process Main() Private byte bytearray[elements-1]; byte* pbyte; int i; End Begin // Allocate memory pbyte = alloc(elements); // Set numbers for(i=0; i\u0026lt;elements; i++) bytearray[i] = i; end // Copy bytes to bytearray memcopy(pbyte,\u0026amp;bytearray[0],elements); // Show numbers for(i=0; i\u0026lt;elements; i++) say(\u0026quot;byte[\u0026quot;+i+\u0026quot;] = \u0026quot; + pbyte[i]); end OnExit // Free the used memory free(pbyte); End  Used in example: alloc(), memcopy(), say(), free(), array, pointer\nCategory:functions Category:memory Category:mod_mem\n","permalink":"https://divhub.github.io/pixtudio-website/docs/memcopy/","title":""},{"contents":" Definition INT memmove ( \u0026lt;VOID POINTER destination\u0026gt; , \u0026lt;VOID POINTER origin\u0026gt; , \u0026lt;INT size\u0026gt; )\nCopies a certain number of bytes from one point in memory to another.\nDifference between memmove() and memcopy() is that the first one can be used if the destination section and origin section overlap. With memcopy(), this can go wrong, though some systems make memcopy() safe too.\nAlso called mem_move().\nParameters VOID POINTER destination - Pointer to the first byte of the destination. VOID POINTER origin - Pointer to the first byte of the origin. INT size - The size of the to be copied memory in bytes.\nReturns INT : true\nExample import \u0026quot;mod_mem\u0026quot; import \u0026quot;mod_say\u0026quot; Const elements = 5; End Process Main() Private byte bytearray[elements-1]; byte* pbyte; int i; End Begin // Allocate memory pbyte = alloc(elements); // Set numbers for(i=0; i\u0026lt;elements; i++) bytearray[i] = i; end // Copy bytes to bytearray memmove(pbyte,\u0026amp;bytearray[0],elements); // Show numbers for(i=0; i\u0026lt;elements; i++) say(\u0026quot;byte[\u0026quot;+i+\u0026quot;] = \u0026quot; + pbyte[i]); end OnExit // Free the used memory free(pbyte); End  Used in example: alloc(), memmove(), say(), free(), array, pointer\nCategory:functions Category:memory Category:mod_mem\n","permalink":"https://divhub.github.io/pixtudio-website/docs/memmove/","title":""},{"contents":" Syntax INT memory_free ( )\nDescription Returns the free memory total in bytes.\nAlso called mem_available().\nReturns INT : Free memory total in bytes.\nExample import \u0026quot;mod_mem\u0026quot; import \u0026quot;mod_say\u0026quot; Process Main() Begin say(\u0026quot;Total memory: \u0026quot; + memory_total()); say(\u0026quot;Free memory: \u0026quot; + memory_free() ); End  Used in example: say(), memory_total(), memory_free()\nCategory:functions Category:memory Category:mod_mem\n","permalink":"https://divhub.github.io/pixtudio-website/docs/memory_free/","title":""},{"contents":" Definition INT memory_total ( )\nReturns the memory total in bytes.\nAlso called mem_total().\nReturns INT : Memory total in bytes.\nExample import \u0026quot;mod_mem\u0026quot; import \u0026quot;mod_say\u0026quot; Process Main() Begin say(\u0026quot;Total memory: \u0026quot; + memory_total()); say(\u0026quot;Free memory: \u0026quot; + memory_free() ); End  Used in example: say(), memory_total(), memory_free()\nCategory:functions Category:memory Category:mod_mem\n","permalink":"https://divhub.github.io/pixtudio-website/docs/memory_total/","title":""},{"contents":" Syntax INT memset ( \u0026lt;VOID POINTER data\u0026gt; , \u0026lt;BYTE value\u0026gt; , \u0026lt;INT bytes\u0026gt; )\nDescription Sets all bytes in the specified memory block to the specified value.\nAlso called mem_set().\nParameters VOID POINTER data - Pointer to the block of bytes in memory BYTE value - Value to set all bytes to. INT bytes - Number of bytes to change the value of.\nReturns INT : true\nExample See alloc().\nAlso useful in conjunction with map_buffer() with 8bit maps. (Example can be found in the map_buffer article.)\nCategory:functions Category:memory Category:mod_mem\n","permalink":"https://divhub.github.io/pixtudio-website/docs/memset/","title":""},{"contents":" Syntax INT memseti ( \u0026lt;VOID POINTER data\u0026gt; , \u0026lt;INT value\u0026gt; , \u0026lt;INT ints\u0026gt; )\nDescription Sets all ints in the specified memory block to the specified value.\nAlso called mem_seti().\nParameters VOID POINTER data - Pointer to the block of ints in memory. INT value - Value to set all ints to. INT ints - Number of ints to change the value of.\nReturns INT : true\nExample See alloc().\nAlso useful in conjunction with map_buffer() with 32bit maps. (Example needed.)\nCategory:functions Category:memory Category:mod_mem\n","permalink":"https://divhub.github.io/pixtudio-website/docs/memseti/","title":""},{"contents":" Syntax INT memsetw ( \u0026lt;VOID POINTER data\u0026gt; , \u0026lt;WORD value\u0026gt; , \u0026lt;INT words\u0026gt; )\nDescription Sets all words in the specified memory block to the specified value.\nAlso called mem_setw().\nParameters VOID POINTER data - Pointer to the block of words in memory. WORD value - Value to set all words to. INT words - Number of words to change the value of.\nReturns INT : true\nExample See alloc().\nAlso useful in conjunction with map_buffer() with 16bit maps. (Example needed.)\nCategory:functions Category:memory Category:mod_mem\n","permalink":"https://divhub.github.io/pixtudio-website/docs/memsetw/","title":""},{"contents":" Definition CHAR MIN_BYTE = 0\nThe minimum integer value reachable with a byte (unsigned char).\nSee also MAX_BYTE.\nCategory:constants Category:internal\n","permalink":"https://divhub.github.io/pixtudio-website/docs/min_byte/","title":""},{"contents":" Definition CHAR MIN_CHAR = 0\nThe minimum integer value reachable with a char (byte).\nSee also MAX_CHAR.\nCategory:constants Category:internal\n","permalink":"https://divhub.github.io/pixtudio-website/docs/min_char/","title":""},{"contents":" Definition DWORD MIN_DWORD = 0\nThe minimum integer value reachable with a dword (unsigned integer).\nSee also MAX_DWORD.\nCategory:constants Category:internal\n","permalink":"https://divhub.github.io/pixtudio-website/docs/min_dword/","title":""},{"contents":" Definition INT MIN_INT = -2147483648\nThe minimum integer value reachable with an int.\nSee also MAX_INT.\nCategory:constants Category:internal\n","permalink":"https://divhub.github.io/pixtudio-website/docs/min_int/","title":""},{"contents":" Definition CHAR MIN_SBYTE = -128\nThe minimum integer value reachable with a signed byte.\nSee also MAX_SBYTE.\nCategory:constants Category:internal\n","permalink":"https://divhub.github.io/pixtudio-website/docs/min_sbyte/","title":""},{"contents":" Definition SHORT MIN_SHORT = -32768\nThe minimum integer value reachable with a short (signed word).\nSee also MAX_SHORT.\nCategory:constants Category:internal\n","permalink":"https://divhub.github.io/pixtudio-website/docs/min_short/","title":""},{"contents":" Definition WORD MIN_WORD = 0\nThe minimum integer value reachable with a word (unsigned short).\nSee also MAX_WORD.\nCategory:constants Category:internal\n","permalink":"https://divhub.github.io/pixtudio-website/docs/min_word/","title":""},{"contents":" Definition INT minimize ( )\nIconifies/minimizes the window.\nReturns INT : success\n0 - If minimizing/iconification is not support or was refused by the window manager. !0 - Success.\nExample import \u0026quot;mod_key\u0026quot; import \u0026quot;mod_wm\u0026quot; Process Main() Begin Repeat if(key(_M)) while(key(_M)) frame; end minimize(); end frame; Until(key(_ESC)||exit_status) End  Used in example: key(), minimize(), exit_status\nCategory:functions Category:programinteraction Category:mod_wm\n","permalink":"https://divhub.github.io/pixtudio-website/docs/minimize/","title":""},{"contents":" Definition INT mkdir ( \u0026lt;STRING directoryname\u0026gt; )\nCreates a new directory in the current path of execution with a certain name.\nParameters STRING directoryname - The name of the directory to be created.\nReturns INT : Success\n0 (false) - Creating a new directory with the specified name failed. !0 (true) - Creating a new directory with the specified name succeeded.\nCategory:functions Category:files Category:mod_dir\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mkdir/","title":""},{"contents":" Up to Modules\nEncryption/decryption module for the encryption and decryption of data.\nUsage Category:modules\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_crypt/","title":""},{"contents":" Up to Modules\nDebug module. Adds the capacity to open the Bennu console.\nUsage Category:modules Category:librender Category:libkey\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_debug/","title":""},{"contents":" Up to Modules\nDirectory module, adding control over the current working directory and the file system.\nUsage Category:modules\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_dir/","title":""},{"contents":" Up to Modules\nPrimitive drawing module, adding drawing of primitive and pixels.\nUsage Category:modules Category:libgrbase Category:librender Category:libdraw\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_draw/","title":""},{"contents":" Up to Modules\nGraphical effects module, adding effects applicable to graphics.\nUsage Category:modules Category:libgrbase\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_effects/","title":""},{"contents":" Up to Modules\nFiles module, adding control over individual files (reading, writing, etc).\nUsage Category:modules\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_file/","title":""},{"contents":" Up to Modules\nGraphical processes module.\nUsage Category:modules Category:libmouse Category:libgrbase Category:libvideo Category:librender Category:libblit\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_grproc/","title":""},{"contents":" Up to Modules\nJoystick module.\nUsage Category:modules Category:libjoy\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_joy/","title":""},{"contents":" Up to Modules\nKeyboard module.\nUsage Category:modules Category:libkey\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_key/","title":""},{"contents":" Up to Modules\nMaps module.\nUsage Category:modules Category:libgrbase Category:libvideo Category:libblit Category:libfont\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_map/","title":""},{"contents":" Up to Modules\nMath module.\nUsage Category:modules\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_math/","title":""},{"contents":" Up to Modules\nMemory module.\nUsage Category:modules\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_mem/","title":""},{"contents":" Up to Modules\nMouse module.\nUsage Category:modules Category:libmouse\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_mouse/","title":""},{"contents":" Up to Modules\nPathfind module.\nUsage Category:modules Category:libgrbase\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_path/","title":""},{"contents":" Up to Modules\nProcess interaction and manipulation module.\nUsage Category:modules\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_proc/","title":""},{"contents":" Up to Modules\nRandom number generator module.\nUsage Category:modules\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_rand/","title":""},{"contents":" Up to Modules\nRegular expressions module.\nUsage Category:modules\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_regex/","title":""},{"contents":" Up to Modules\nSay (printf) module.\nUsage Category:modules\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_say/","title":""},{"contents":" Up to Modules\nScreen module.\nUsage Category:modules Category:libgrbase Category:libvideo Category:libblit Category:librender\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_screen/","title":""},{"contents":" Up to Modules\nScroll module.\nUsage Category:modules Category:libscroll\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_scroll/","title":""},{"contents":" Up to Modules\nSorting module.\nUsage Category:modules\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_sort/","title":""},{"contents":" Up to Modules\nSound module.\nUsage Category:modules\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_sound/","title":""},{"contents":" Up to Modules\nString manipulation module.\nUsage Category:modules\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_string/","title":""},{"contents":" Up to Modules\nSystem communication module.\nUsage Category:modules\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_sys/","title":""},{"contents":" Up to Modules\nText module.\nUsage Category:modules Category:libgrbase Category:libblit Category:libtext Category:libfont\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_text/","title":""},{"contents":" Up to Modules\nTime module.\nUsage Category:modules\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_time/","title":""},{"contents":" Up to Modules\nTimers module.\nUsage Category:modules\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_timers/","title":""},{"contents":" Up to Modules\nVideo module.\nUsage Category:modules Category:libgrbase Category:libvideo Category:librender\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_video/","title":""},{"contents":" Up to Modules\nWindow Manager module.\nUsage Category:modules Category:libsdlhandler Category:libvideo Category:libwm\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mod_wm/","title":""},{"contents":" Definition INT mode_is_ok ( \u0026lt;INT width\u0026gt; , \u0026lt;INT height\u0026gt; , \u0026lt;INT depth\u0026gt;, \u0026lt;INT flags\u0026gt; )\nReturns 0 if the requested mode is not supported under any bit depth,or returns the bits-per-pixel of the closest available mode with the given width, height and requested flags.\nParameters INT width - Width of the screen in pixels. INT height - Height of the screen in pixels. INT depth - Color depth of the screen. See color_depths. INT flags - Mode of rendering. See render flags.\nReturns INT : Whether the specified mode can be used.\n0 - The specified mode cannot be used. \u0026gt;0 - The bits-per-pixel of the closest available mode for the given width, height and flags.\nExample import \u0026quot;mod_video\u0026quot; import \u0026quot;mod_key\u0026quot; import \u0026quot;mod_wm\u0026quot; Process Main() Begin if (is_mode_ok(640,400,16,0)) set_mode(640,400,16); else set_mode(640,480,16); end Repeat frame; Until(key(_ESC)||exit_status) End  Used in example: is_mode_ok(),set_mode(), key(), exit_status\nCategory:functions Category:programinteraction Category:mod_video\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mode_is_ok/","title":""},{"contents":"Modules add extra functionality to PixTudio, as PixTudio on its own is just a language and a virtual machine. The default modules contain the basics you need to make a game: video, audio, input, etc. More advanced external libraries are available, like network and 3D rendering.\nEnabling a module is easy, using import:\nimport \u0026quot;\u0026lt;modulename\u0026gt;\u0026quot;  Some external libraries use a header (.INC) instead, so use include:\ninclude \u0026quot;\u0026lt;includename\u0026gt;\u0026quot;  ","permalink":"https://divhub.github.io/pixtudio-website/docs/modules/","title":""},{"contents":" category:variables category:predefined category:global variables category:libmouse\nUp to Global Variables\nDefinition Struct Mouse\nMouse is a global variable struct, containing information about the current state of the mouse. Also graphical settings can be configured to display a graphic following the mouse in a certain way.\nMembers Member name - Description INT x - The X-coordinate of the mouse. INT y - The Y-coordinate of the mouse. INT graph - The graphID of the graphic of the mouse. INT file - The fileID of the file in which the graphic of the mouse is located. INT z - The Z-coordinate of the mouse. INT angle - The angle of the mouse process. INT size - The size of the mouse process. INT flags - The render flags of the mouse process. INT region - The region of the mouse process. INT left - true/false: whether the left mouse button is pressed. INT middle - true/false: whether the middle mouse button is pressed. INT right - true/false: whether the right mouse button is pressed. INT wheelup - true/false: whether the mouse wheel is scrolled upwards. INT wheeldown - true/false: whether the mouse wheel is scrolled downwards.\nExample import \u0026quot;mod_map\u0026quot; import \u0026quot;mod_mouse\u0026quot; import \u0026quot;mod_wm\u0026quot; Process Main() Private int dmap; int rmap; int gmap; int bmap; int ymap; int cmap; int mmap; int wmap; Begin // Create a dark graph dmap = new_map(100,100,8); map_clear(0,dmap,rgb(50,50,50)); // Create a red graph rmap = new_map(100,100,8); map_clear(0,rmap,rgb(255,0,0)); // Create a green graph gmap = new_map(100,100,8); map_clear(0,gmap,rgb(0,255,0)); // Create a blue graph bmap = new_map(100,100,8); map_clear(0,bmap,rgb(0,0,255)); // Create a yellow graph ymap = new_map(100,100,8); map_clear(0,ymap,rgb(255,255,0)); // Create a cyan graph cmap = new_map(100,100,8); map_clear(0,cmap,rgb(0,255,255)); // Create a magenta graph mmap = new_map(100,100,8); map_clear(0,mmap,rgb(255,0,255)); // Create a white graph wmap = new_map(100,100,8); map_clear(0,wmap,rgb(255,255,255)); Repeat if(mouse.left) // +Red if(mouse.right) // +Green if(mouse.middle) // +Blue mouse.graph = wmap; else mouse.graph = ymap; end else if(mouse.middle) // +Blue mouse.graph = mmap; else mouse.graph = rmap; end end elseif(mouse.right) // +Green if(mouse.middle) // +Blue mouse.graph = cmap; else mouse.graph = gmap; end elseif(mouse.middle) // +Blue mouse.graph = bmap; else // Dark mouse.graph = dmap; end frame; Until(exit_status) End  Used in example: Mouse, new_map(), map_clear(), graph, exit_status\nShows some use of maps and the mouse.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mouse/","title":""},{"contents":" category:variables category:predefined category:global variables category:libwm\nUp to Global Variables\nDefinition INT mouse_status\nmouse_status is a predefined global variable, holding whether or not the mouse cursor is inside the Bennu window.\nValue - Description false - The mouse cursor is outside the Bennu window. true - The mouse cursor is inside the Bennu window.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/mouse_status/","title":""},{"contents":" Definition INT move_draw ( \u0026lt;INT DrawID\u0026gt; , \u0026lt;INT x\u0026gt; , \u0026lt;INT y\u0026gt; )\nMoves a certain drawing on the screen. Only drawings drawn with a certain z value can be moved like this, as other ones are drawn on a graphic and thus cannot be moved.\nParameters INT DrawID - DrawID of the drawing to be moved. INT x - The new x coordinate of the drawing. INT y - The new y coordinate of the drawing.\nReturns INT : true\nCategory:functions Category:drawing Category:mod_draw\n","permalink":"https://divhub.github.io/pixtudio-website/docs/move_draw/","title":""},{"contents":" Definition INT Move_scroll ( \u0026lt;INT scrollnumber\u0026gt;)\nThe move_scroll function is a slighty more advanced function. It allow the scroll\u0026rsquo;s internal coordinates x0, y0, x1 and y1 of the scroll structure to be updated in a forcefull way. This gives great flexibility when multiple scroll windows are used.\nFor instance, in a situation where multiple scroll windows are active on screen, and one scroll is controlled by the main player, the other scrolls can be updated manually. However, the function can also be usefull when there\u0026rsquo;s only one scroll active. In that case you can have any process take control over the scroll.\nAlso called scroll_move().\nParameters INT scrollnumber - The ID for the scroll window to be moved\nReturns INT : true\nExample IMPORT \u0026quot;mod_video\u0026quot;; IMPORT \u0026quot;mod_map\u0026quot;; IMPORT \u0026quot;mod_scroll\u0026quot;; IMPORT \u0026quot;mod_screen\u0026quot;; IMPORT \u0026quot;mod_key\u0026quot;; IMPORT \u0026quot;mod_proc\u0026quot;; GLOBAL int graphics; int counter; PRIVATE PROCESS main(); BEGIN set_fps(100, 0); graphics=load_fpg(\u0026quot;help.fpg\u0026quot;); start_scroll(0, graphics, 103, 102, 0, 15); scroll.camera=id; // assign the \u0026quot;main\u0026quot; process instance (this one) to the scroll's camera. priority=100; FROM counter=-2000 TO 2000 step 100; movable_process(counter); END say(\u0026quot;Use the right and left cursors to move\u0026quot;); graph=101; ctype=c_scroll; LOOP if (key(_right)) x+=2; flags=0; END if (key(_left)) x-=2; flags=1; END move_scroll(0); // Updates the scroll structure[], in this case affect scroll 0. FRAME; END END PROCESS movable_process(x_scroll); PRIVATE BEGIN ctype=c_scroll; z=100; graph=104; LOOP x=x_scroll-scroll.x0; FRAME; END END  Using Scrolling For each process that you want to be part of a scroll window, you must set the local variable ctype to value C_SCROLL. It should also be noted that the local variable c_number is used for selecting in which scroll a process should be displayed. Additionally, you must set the camera property of the scroll structure to the processID of the process you wish to be followed.\nCategory:functions Category:scrolls Category:mod_scroll\n","permalink":"https://divhub.github.io/pixtudio-website/docs/move_scroll/","title":""},{"contents":" Definition INT move_text ( \u0026lt;INT TextID\u0026gt; , \u0026lt;INT x\u0026gt; , \u0026lt;INT y\u0026gt;, \u0026lt;INT z\u0026gt;)\nMoves an existing text to another place on the screen.\nParameters INT TextID - Identifier of the text you want to move. This identifier should have been appointed to a text earlier on. INT x - The new horizontal coordinate (of the control point) of your text. INT y - The new vertical coordinate (of the control point) of your text. INT z - The new depthplane (of the control point) of your text. (introduced in version r282)\nReturns INT : TRUE\nNotes The \u0026ldquo;z\u0026rdquo; argument is a newer feature, so it is not anvailible in all versions.\nErrors None.\nExample Program test; Global My_text; Begin My_text=write(0,320/2,200/2,4,\u0026quot;Press space to move this.\u0026quot;); Loop If (key(_space)) Move_text(My_text,rand(0,319),rand(0,199)); End Frame; End End  Used in example: write(), key(), rand()\nThis will result in something like:\nExample 2 import \u0026quot;mod_text\u0026quot;; import \u0026quot;mod_mouse\u0026quot;; import \u0026quot;mod_key\u0026quot;; import \u0026quot;mod_video\u0026quot;; import \u0026quot;mod_rand\u0026quot;; import \u0026quot;mod_map\u0026quot;; private txt[10]; counter; tz; begin set_mode(640,480,32); txt[0]=write_int(0,10,10,10,0,\u0026amp;counter); txt[1]=write_int(0,10,20,-5,0,\u0026amp;tz); txt[2]=write(0,10,10,0,0,\u0026quot;hello world\u0026quot;); set_text_color(txt[1], rgb(255,0,0)); while(!key(_ESC)) counter++; move_text(txt[2], mouse.x, mouse.y, tz ); set_text_color(txt[0], rand(0101010h, 0ffffffh)); if ( key( _DOWN ) ) tz--; end if ( key( _UP ) ) tz++; end frame; end end  Used in example: write(), write_int(), key(), rand(), set_mode(), set_text_color()\nCategory:functions Category:texts Category:mod_text\n","permalink":"https://divhub.github.io/pixtudio-website/docs/move_text/","title":""},{"contents":" Definition INT move_window ( \u0026lt;INT x\u0026gt; , \u0026lt;INT y\u0026gt; )\nMoves the Bennu window so that the top left of the window is on the specified (x,y).\nAlso called Set window pos().\nParameters INT x - The new X coordinate of the top left of the window. INT y - The new Y coordinate of the top left of the window.\nReturns INT : true\nCategory:functions Category:programinteraction Category:mod_wm\n","permalink":"https://divhub.github.io/pixtudio-website/docs/move_window/","title":""},{"contents":" Definition INT near_angle ( \u0026lt;INT angle\u0026gt; , \u0026lt;INT final angle\u0026gt; , \u0026lt;INT increment\u0026gt; )\nReturns an angle closer to another angle, with the indicated increment. It is used for aiming the original angle and it gradually changes into the final angle. The increment controls the rate in wich the final angle is added or subtracted from the orginal angle. The returned angle will be ranging from 0 to 360000 (0-360º).\nParameters INT angle - The original angle. INT final angle - The new angle. INT increment - The addition or subtraction rate between the two angles.\nReturns INT : An angle nearer the final angle.\nNotes The angle value returned by this function is in thousandths of degrees, as most angles within Bennu are.\nExample /* Modified example converted from bennupack, fenix test section, 2 Medium\\fenix test\\Fenix Test3\\Test_NEAR_ANGLE.prg */ // import modules IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_debug\u0026quot;; //IMPORT \u0026quot;mod_math\u0026quot;; IMPORT \u0026quot;mod_mathi\u0026quot;; IMPORT \u0026quot;mod_map\u0026quot;; IMPORT \u0026quot;mod_key\u0026quot;; IMPORT \u0026quot;mod_video\u0026quot;; IMPORT \u0026quot;mod_screen\u0026quot;; IMPORT \u0026quot;mod_mouse\u0026quot;; IMPORT \u0026quot;mod_proc\u0026quot;; IMPORT \u0026quot;mod_grproc\u0026quot;; GLOBAL int fpg; int ang; //int increment=5000; int increment=10000; //int increment=25000; //int increment=50000; PROCESS main(); BEGIN full_screen=false; fpg=load_fpg(\u0026quot;Fpg.fpg\u0026quot;); say(\u0026quot;Test near_angle...\u0026quot;); say(\u0026quot;Press ESC to quit, and use mouse to move triangle.\u0026quot;); put_screen(fpg,2); // set the mouse cursor mouse.graph=200; mouse.x=0; mouse.y=0; graph=101; REPEAT // Returns the angle between two certain points. The returned angle will be ranging from 0 to 360000 (0-360º). ang=fget_angle(x,y,mouse.x,mouse.y); // int near_angle (int \u0026lt;angle\u0026gt;, int \u0026lt;final angle\u0026gt;, int \u0026lt;increment\u0026gt;) angle=near_angle(angle,ang,increment); say(\u0026quot;angle: \u0026quot;+angle); say(\u0026quot;ang: \u0026quot;+ang); say(\u0026quot;increment: \u0026quot;+increment); advance(5); FRAME; UNTIL(key(_esc)) END  Used in example: say(), fget_angle(), key(), Advance(), mouse, graph, x, y, angle\nCategory:functions Category:math Category:mod_math\n","permalink":"https://divhub.github.io/pixtudio-website/docs/near_angle/","title":""},{"contents":" Up to Network.DLL\nGeneral | NET_MAX_MSG_LEN - Maximum number of bytes per message. (doesn\u0026rsquo;t really apply, ignore it) | NET_FPS - The frame percentage of the NET Loop. (default is frame;)\nConnection Status codes | NET_STATUS_DISCONNECTING - -4 - The connection is being disconnected | NET_STATUS_DISCONNECTED - -2 - The connection is disconnected. | NET_STATUS_INACTIVE - 0 - (The connection is) inactive. | NET_STATUS_ACTIVE - 1 - (The connection is) active. | NET_STATUS_ESTABLISHED - 2 - The connection is established. | NET_STATUS_ESTABLISHING - 4 - The connection is being established.\nConsole Reports modes | NET_CONSOLEREPORTS_NO - false - Console reports disabled. | NET_CONSOLEREPORTS_YES - true - Console reports enabled.\nErrorcodes NET_Errorcodes\nCategory:defines Category:networkdll Category:dll\n","permalink":"https://divhub.github.io/pixtudio-website/docs/net_defines/","title":""},{"contents":"Up to Network.DLL\nHere is a list of all the errorcodes regarding Network.DLL.\nCatching errorcodes is very easy: just check if the return value is negative, then it is an error.\nresult = NET_Xxx(); if(result\u0026lt;0) say(\u0026quot;NET Error: \u0026quot; + NET_GetError(result)); else // success end  Constant - Description NET_ERROR_NONE - No error. NET_ERROR_INITIALIZATION - Error during initialization. NET_ERROR_NOTINITIALIZED - Network.DLL not initialized. Depecrated. NET_ERROR_INVALIDADDRESS - Invalid IP address. Deprecated. NET_ERROR_RESOLVINGHOST - Could not resolve host. NET_ERROR_ALLOCSOCKETSET - Could not allocate socketset. Deprecated. NET_ERROR_INVALIDSOCKETSET - The socketset is invalid. NET_ERROR_SOCKETSETINACTIVE - The socketset is inactive. NET_ERROR_ADDINGSOCKET - Could not add socket to socketset. NET_ERROR_INVALIDSOCKETSET - The socketset is invalid. NET_ERROR_DELETINGSOCKET - Could not delete the socket. NET_ERROR_CONNECTING - Could not connect. NET_ERROR_INVALIDCONN - The connection is invalid. NET_ERROR_CONNINACTIVE - The connection is inactive. NET_ERROR_LISTENINGONCONN - Could not listen on connection. NET_ERROR_TOOMANYCONNS - There are too many connections NET_ERROR_TOOFEWCONNS - Too small number of maximum connections NET_ERROR_INVALIDTYPE - The type specified is invalid. NET_ERROR_ALREADYINIT - Network.DLL already initialized. NET_ERROR_MESSAGETOOLONG - The message is too long. NET_ERROR_MESSAGETOOSHORT - The message is too short. NET_ERROR_OUTGOINGSTACKFULL - Outgoing Message stack is full. NET_ERROR_INCOMINGSTACKFULL - Incoming Message stack is full. NET_ERROR_SENDING - Could not send message. NET_ERROR_RECEIVING - Could not receive message. NET_ERROR_DISCONNECTING - Could not close connection. NET_ERROR_DISCONNECTED - Connection was closed. NET_ERROR_TOOMANYLISTENERS - Too many listenports specified. NET_ERROR_INVALIDPORTNUMBER - The portnumber is invalid (\u0026lt;0 or \u0026gt;65535). NET_ERROR_SIZEMISMATCH - Integral size mismatch. NET_ERROR_RESOLVINGIP - Could not resolve IP. NET_ERROR_NONEXTERNALCONN - Non-external connection. Deprecated. NET_ERROR_NONEWMESSAGE - The incomingbuffer is empty. NET_ERROR_UNFINISHEDMESSAGE - The message in the incomingbuffer is incomplete. NET_ERROR_NULLPOINTER - NULL pointer exception. NET_ERROR_NONEXISTINGGRAPH - The graph does not exist. NET_ERROR_NONEXISTINGFILE - The file does not exist. NET_ERROR_CREATINGGRAPH - Could not create graph. NET_ERROR_OPENINGFILE - Could not open file.\nCategory:errorcodes Category:networkdll Category:dll\n","permalink":"https://divhub.github.io/pixtudio-website/docs/net_errorcodes/","title":""},{"contents":" Up to Network.DLL\nStruct NET | INT Activity - true/false: whether there is an incoming message on a connection. READ ONLY | INT POINTER Incoming - The change of state of each connection. READ ONLY | INT POINTER Status - The status of each connection. READ ONLY | WORD MaxConnections - Maximum number of connections specified when NET_Init was called. READ ONLY | WORD MaxListenPorts - Maximum number of listenports specified when NET_Init was called. READ ONLY | WORD ActiveConnections - Number of currently active Connections; this does not include ListenConnections. READ ONLY | WORD ActiveListenPorts - Number of currently active ListenConnections. READ ONLY | BYTE ConsoleReports - true/false: whether general messages should be displayed in the console. READ/WRITE | BYTE ReturnNETDLLCommands - true/false: whether Network.DLL commands are visible to Fenix/Bennu. READ/WRITE Deprecated | INT totaltransferrate_up - The number of bytes sent this frame by all connections. READ ONLY | INT totaltransferrate_down - The number of bytes received this frame by all connections. READ ONLY | INT totaltransferred_up - The total number of bytes sent by all connections. READ ONLY | INT totaltransferred_down - The total number of bytes received by all connections. READ ONLY | INT POINTER transferrate_up - The number of bytes sent this frame by a connection. READ ONLY | INT POINTER transferrate_down - The number of bytes received this frame by a connection. READ ONLY | INT POINTER transferred_up - The total number of bytes sent by a connection. READ ONLY | INT POINTER transferred_down - The total number of bytes received by a connection. READ ONLY\nPointers To the int pointers in the NET struct applies the following:\n they point to an array with number of elements equal to NET.MaxConnections; each element contains data regarding one connection; every connection has a NetID and this NetID corresponds with the position in the array (so for example for the NetID n: NET.Status[n] works).  Incoming/Status To the incoming array the following status codes apply: NET_STATUS_DISCONNECTED, NET_STATUS_INACTIVE, NET_STATUS_ACTIVE, NET_STATUS_CONNECTED.\nTo the status array the following status codes apply: NET_STATUS_DISCONNECTING, NET_STATUS_DISCONNECTED, NET_STATUS_INACTIVE, NET_STATUS_CONNECTED, NET_STATUS_CONNECTING.\nThe status array tells the current status of each connection, while the incoming array tells the change of status of each connection. For example, if a connection would disconnect, the element of the incoming array of that connection would become NET_STATUS_DISCONNECT for one cycle and then become NET_STATUS_INACTIVE.\nFor the incoming array:\n NET_STATUS_DISCONNECTED lasts one cycle NET_STATUS_INACTIVE lasts until a different status is valid NET_STATUS_ACTIVE lasts one cycle NET_STATUS_ESTABLISHED lasts one cycle  Category:global variables Category:networkdll Category:dll\n","permalink":"https://divhub.github.io/pixtudio-website/docs/net_globals/","title":""},{"contents":"Up to Network.DLL\nNetwork.DLL functions!\n category=networkdllfunctions category=functions replaceintitle = /\\\\? /,_ mode=userformat listseparators = ,\\n* %TITLE%(),, resultsfooter = \\n%PAGES% Network.DLL functions noresultsheader = No functions in here yet. \n","permalink":"https://divhub.github.io/pixtudio-website/docs/networkdllfunctions/","title":""},{"contents":" Description NULL is a pointer, pointing to nothing. In programming it points to 0x00000000, or just plain 0.\nThe following check is the same as checking if a pointer variable is NULL:\nif(my_pointer) end  In which my_pointer is a pointer variable.\nConstant - Value - Description NULL - 0 - 0x00000000, pointing to nothing.\nCategory:constants Category:internal\n","permalink":"https://divhub.github.io/pixtudio-website/docs/null/","title":""},{"contents":" List of Operators General Operator - Description Type - Get the ProcessTypeID of a ProcessType or define a new datatype. See Type. . (period) - Element access. \u0026lt;struct\u0026gt;.\u0026lt;element\u0026gt;. In case of a struct array, if no arrayelement is specified, it points to [0] (see example).\nMaths Operator - Description + - Addition. - - Deduction * - Multiplication. / - Division. % - Modulus (remainder).\nLogic Operator - Description   \u0026amp;\u0026amp; - AND. Both. \\^\\^ - XOR. One or the other, but not both. ! - NOT.\nBitwise (Logical operation per bit.)\nOperator - Description | - BOR. One or the other or both. \u0026amp; - BAND. Both. \\^ - BXOR. One or the other, but not both. ~ - BNOT. \u0026lt;\u0026lt; - Bitshift left, causes bits to move left a certain number of positions. \u0026gt;\u0026gt; - Bitshift left, causes bits to move right a certain number of positions.\nMemory Operator - Description \u0026amp; - OFFSET. Get the memory address of a variable. See pointer. * - POINTER. Get access to the variable a pointer is pointing to. See pointer.\nExample Type _point int x; int y; End Global int int_1 = 1; int int_3 = 3; int int_4 = 4; int someint = -5; String somestring = \u0026quot;AAP\u0026quot;; String anotherstring = \u0026quot;BEER\u0026quot;; byte somebyte = 6; signed byte sbyte = -2; byte b_5 = 5; byte b_12 = 12; Struct Person[9] string name; int age; End _point myPoint; End Process Main() Begin say(\u0026quot;---------- maths\u0026quot;); say(int_3 + int_4); say(int_3 * int_4 + 1); say(\u0026quot;---------- strings with numerical datatypes\u0026quot;); say(somestring + anotherstring); say(somestring + \u0026quot;: \u0026quot; + int_3); say(anotherstring + \u0026quot;: \u0026quot; + int_3*sbyte); say(\u0026quot;---------- mixed numberical types and typecasting\u0026quot;); say(somebyte+someint); say((signed byte)someint); say((unsigned byte)someint); say(\u0026quot;---------- logic\u0026quot;); say(int_1\u0026amp;\u0026amp;int_4); say(int_4==int_3+int_1); say(!(somestring==anotherstring)); say(\u0026quot;---------- bitwise\u0026quot;); say(b_5|b_12); // 00000101 // 00001100 // -------- | // 00001101 = 13 say(b_5\u0026amp;b_12); // 00000101 // 00001100 // -------- \u0026amp; // 00000100 = 4 say(b_5^b_12); // 00000101 // 00001100 // -------- ^ // 00001001 = 9 say(~b_12); // 00001100 // -------- ~ // 11110011 = 243 person.name = \u0026quot;Mies\u0026quot;; // these are the same person[0].name = \u0026quot;Mies\u0026quot;; // person[1].name = \u0026quot;Aap\u0026quot;; person[2].name = \u0026quot;Noot\u0026quot;; // ...etc... person[9].name = \u0026quot;Last person\u0026quot;; // last array element setXY(\u0026amp;myPoint); Repeat frame; Until(key(_ESC)) End Function int setXY(_point* p) Begin p.x = 3; // this is actually (*p).x = 3, but . can be used like this p.y = 5; // this is actually (*p).y = 5, but . can be used like this return 0; End  Used in example: say(), key(), Global, Type, Struct, Array, Pointer, period\nThis will result in something like:\nCategory:General\n","permalink":"https://divhub.github.io/pixtudio-website/docs/operators/","title":""},{"contents":" Definition OS codes are codes used for the global variable os_id, to specify the current platform BGDI is running on.\nOS codes 1000 and above are used for unofficial ports and may not be available in the official Bennu version.\nList Constant - Value - Description OS_WIN32 - 0 - Microsoft Windows OS_LINUX - 1 - Linux OS_BEOS - 2 - Be Operating System OS_MACOS - 3 - Mac Operating System OS_GP32 - 4 - GP32 handheld console OS_DC - 5 - Sega Dreamcast OS_BSD - 6 - Berkeley Software Distribution OS_GP2X - 7 - GP2X handheld console OS_GP2X_WIZ - 8 - GP2X WIZ handheld console OS_CAANOO - 9 - GP2X Caanoo handheld console OS_DINGUX_A320 - 10 - Dingoo A320 handheld console OS_WII - 1000 - Nintendo Wii console (through Wii homebrew) OS_PSP - 1001 - PlayStation Portable OS_IOS - 1002 - iOS OS_ANDROID - 1003 - Android (under development)\nCategory:constantcategories Category:internal\n","permalink":"https://divhub.github.io/pixtudio-website/docs/os_codes/","title":""},{"contents":" category:variables category:predefined category:global variables category:internal\nUp to Global Variables\nDefinition INT os_id\nos_id is a predefined global variable, holding the OS code of the operating system Bennu is currently running on while executing. Default is -1.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/os_id/","title":""},{"contents":" Definition General palette file.\nFile Format Head Palette Range of Colours Category:filetypes\n","permalink":"https://divhub.github.io/pixtudio-website/docs/pal/","title":""},{"contents":" Syntax INT pal_clone ( \u0026lt;INT paletteID\u0026gt; )\nDescription This function is creates a copy of palette loaded with Pal_load(). It can be used for the functions Pal_get(), Pal_set() and Pal_map_assign().\nParameters INT paletteID - The handle of the color palette loaded with Pal_load().\nReturns INT : Error.\n0 - Error: could not open file; corrupt or truncated file; file doesn\u0026rsquo;t contain palette information. 1 - The identifier of the palette.\nExample /* original bennupack example FROM: \\2 Medium\\fenix test\\palettes\\rbear8-2.prg (from bomberlink) */ /* this program demonstrates the use of the functions: pal_load(), pal_clone(), pal_get(), */ /* pal_map_assign(), pal_set() and pal_refresh(). */ IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_map\u0026quot;; IMPORT \u0026quot;mod_key\u0026quot;; IMPORT \u0026quot;mod_video\u0026quot;; IMPORT \u0026quot;mod_text\u0026quot;; GLOBAL // palette identifiers int pal_orange; int pal_green; int pal_normal; int status1; int status2; // identifier of the fpg archive int fpg_id; // arrays for the data of the two color palettes. byte pal_orange_data[255]; byte pal_green_data[255]; int map_count; PROCESS main(); BEGIN set_fps(10,0); set_mode(320,200,16); // we use a 16 bit color mode // load two color palettes and duplicate one pal_green=pal_load(\u0026quot;rbear8-green.pal\u0026quot;); pal_orange=pal_load(\u0026quot;rbear8-orange.pal\u0026quot;); // pal_clone (int pal_id); pal_normal=pal_clone(pal_orange); // duplicate palette, i.e. make a copy of it. // load the fpg file fpg_id=fpg_load(\u0026quot;rbear8.fpg\u0026quot;); write_int(0,10,10,0,\u0026amp;fps); write(0,10,20,0,\u0026quot;F1/F2 - change palette\u0026quot;); x = 160; y = 120; // pal_get (int pal_id, int start_color, int num_colors, pointer pal_data); pal_get(pal_green,7,7,\u0026amp;pal_green_data); // get colors 7 - 13 and store them in the array pal_get(pal_orange,7,7,\u0026amp;pal_orange_data); FROM map_count=1 TO 102; // there are 102 frames in the animation // pal_map_assign (int fileid, int graph, int pal_id); pal_map_assign(fpg_id,map_count,pal_normal); // assign the \u0026quot;normal (original source)\u0026quot; color // palette that we duplicated earlier. END WHILE (NOT key(_ESC)) FROM graph=1 TO 13; FRAME; IF (key(_F1)) say(\u0026quot;switched to green palette\u0026quot;); // pal_set (int pal_id, int start_color, int num_colors, pointer pal_data); status1=pal_set(pal_normal,7,7,\u0026amp;pal_green_data); // change colors 7 - 13 in the \u0026quot;normal\u0026quot; // palette, by using the values from the // \u0026quot;green\u0026quot; color palette. say(\u0026quot;pal_set_status: \u0026quot;+status1); // pal_refresh (int pal_id); status2=pal_refresh(pal_normal); // apply the modified color palette to the graphics. // this function is required to make the change visible. say(\u0026quot;pal_refresh_status: \u0026quot;+status2); // conclusion: the difference between pal_map_assign() and pal_set() is that pal_map_assign() // works immediately, and that pal_set() requires the palette to be refreshed to make the // change visible. END IF (key(_F2)) say(\u0026quot;switched to orange palette\u0026quot;); pal_set(pal_normal,7,7,\u0026amp;pal_orange_data); // colors 7 - 13 pal_refresh(pal_normal); END IF (key(_ESC)) BREAK; END END END END  Used in example: Pal_load(), pal_get(), Pal_set(), Pal_map_assign(), Pal_refresh(), Say(), Set_fps(), Set_mode(), Write(), Write_int()\nCategory:functions Category:palettes Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/pal_clone/","title":""},{"contents":" Syntax INT pal_get ( [\u0026lt;INT paletteID\u0026gt;] , \u0026lt;INT first_color\u0026gt; , \u0026lt;INT num_colors\u0026gt; , \u0026lt;POINTER palette_data\u0026gt;)\nDescription This function is used in conjuction with Pal_set() to load palette data that was loaded with Pal_load() into an array, for later use with Pal_set(). This palette can also be loaded from MAP\u0026rsquo;s, FPG\u0026rsquo;s, FNT\u0026rsquo;s and other image formats, provided that they are 8 bit images.\nAlso called colors_get(). The previous name get_colors() is deprecated.\nParameters INT paletteID - The handle of the color palette loaded with Pal_load(). This paramter is optional. INT first_color - The first color number of the palette. This doesn\u0026rsquo;t necessarily have be the first color. INT num_colors - The number of colors you want to replace, wich counts from the first_color to the num_colors. See notes. POINTER palette_data - Pointer (Offset) to an array where the color values will be stored.\nNote The maximum number of colors cannot be bigger the 255. The num_colors starts counting from first_color, so if the first_color is 7, and num_colors is 7, the color value\u0026rsquo;s 7-13 are changed. So logically, the value num_colors can only be 255 when first_color is 0. This range gives you all the colors. To be safe, the formula for the number of colors to modified is: num_colors-first_color.\nI.e. num_colors: 55 - first_color: 4 = 51 colors are changed, the range from color index 4 up to color index 55.\nReturns INT : Error.\n0 - Error: could not open file; corrupt or truncated file; file doesn\u0026rsquo;t contain palette information. 1 - No error: palette was set with success.\nExample /* original bennupack example FROM: \\2 Medium\\fenix test\\palettes\\rbear8-2.prg (from bomberlink) */ /* this program demonstrates the use of the functions: pal_load(), pal_clone(), pal_get(), */ /* pal_map_assign(), pal_set() and pal_refresh(). */ IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_map\u0026quot;; IMPORT \u0026quot;mod_key\u0026quot;; IMPORT \u0026quot;mod_video\u0026quot;; IMPORT \u0026quot;mod_text\u0026quot;; GLOBAL // palette identifiers int pal_orange; int pal_green; int pal_normal; int status1; int status2; // identifier of the fpg archive int fpg_id; // arrays for the data of the two color palettes. byte pal_orange_data[255]; byte pal_green_data[255]; int map_count; PROCESS main(); BEGIN set_fps(10,0); set_mode(320,200,16); // we use a 16 bit color mode // load two color palettes and duplicate one pal_green=pal_load(\u0026quot;rbear8-green.pal\u0026quot;); pal_orange=pal_load(\u0026quot;rbear8-orange.pal\u0026quot;); // pal_clone (int pal_id); pal_normal=pal_clone(pal_orange); // duplicate palette, i.e. make a copy of it. // load the fpg file fpg_id=fpg_load(\u0026quot;rbear8.fpg\u0026quot;); write_int(0,10,10,0,\u0026amp;fps); write(0,10,20,0,\u0026quot;F1/F2 - change palette\u0026quot;); x = 160; y = 120; // pal_get (int pal_id, int start_color, int num_colors, pointer pal_data); pal_get(pal_green,7,7,\u0026amp;pal_green_data); // get colors 7 - 13 and store them in the array pal_get(pal_orange,7,7,\u0026amp;pal_orange_data); FROM map_count=1 TO 102; // there are 102 frames in the animation // pal_map_assign (int fileid, int graph, int pal_id); pal_map_assign(fpg_id,map_count,pal_normal); // assign the \u0026quot;normal (original source)\u0026quot; color // palette that we duplicated earlier. END WHILE (NOT key(_ESC)) FROM graph=1 TO 13; FRAME; IF (key(_F1)) say(\u0026quot;switched to green palette\u0026quot;); // pal_set (int pal_id, int start_color, int num_colors, pointer pal_data); status1=pal_set(pal_normal,7,7,\u0026amp;pal_green_data); // change colors 7 - 13 in the \u0026quot;normal\u0026quot; // palette, by using the values from the // \u0026quot;green\u0026quot; color palette. say(\u0026quot;pal_set_status: \u0026quot;+status1); // pal_refresh (int pal_id); status2=pal_refresh(pal_normal); // apply the modified color palette to the graphics. // this function is required to make the change visible. say(\u0026quot;pal_refresh_status: \u0026quot;+status2); // conclusion: the difference between pal_map_assign() and pal_set() is that pal_map_assign() // works immediately, and that pal_set() requires the palette to be refreshed to make the // change visible. END IF (key(_F2)) say(\u0026quot;switched to orange palette\u0026quot;); pal_set(pal_normal,7,7,\u0026amp;pal_orange_data); // colors 7 - 13 pal_refresh(pal_normal); END IF (key(_ESC)) BREAK; END END END END  Used in example: Pal_load(), pal_clone(), Pal_set(), Pal_map_assign(), Pal_refresh(), Say(), Set_fps(), Set_mode(), Write(), Write_int()\nCategory:functions Category:palettes Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/pal_get/","title":""},{"contents":" Syntax INT pal_load ( \u0026lt;STRING filename\u0026gt;, [ \u0026lt;POINTER id\u0026gt;] )\nDescription Loads a color palette from a file.\nThe current palette is switched to the loaded one. Note that one can load a palette from an 8bit FPG or MAP file (the remaining graphic data will not be loaded) or a PAL file.\nThe previous name load_pal() is deprecated.\nParameters STRING filename - The filename of the file that you wish to load the palette from (including extension and possible path). POINTER id - Optional parameter, for loading a palette in the background.\nReturns INT : graphID\n-2 - Waiting for the file to be loaded, see notes. -1 - There was an error loading the file. \u0026gt;=0 - The graphID of the newly created palette.\nthe following applies for versions prior rc282:\nINT : Error.\n-1 - Error: could not open file; corrupt or truncated file; file doesn\u0026rsquo;t contain palette information. 0 - Error: could not obtain filename; some FPL error. 1 - No error: palette was loaded with success.\nExample Program example; Begin load_pal(\u0026quot;example.pal\u0026quot;); Loop frame; End End  Notes The optional parameter id was introduced in version rc282 and allows you to load resources in the background. It used with the Offset operator. See example below:\n load_pal(\u0026quot;archivo_gordo.pal\u0026quot;, \u0026amp;idpal); while(idpal==-2) say(\u0026quot;Big File Loading ....\u0026quot;); frame; end if(idpal==-1) say(\u0026quot;Something went wrong!!\u0026quot;); exit(); // o return end say(\u0026quot;Big file loaded ok!!\u0026quot;);  Category:functions Category:palettes Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/pal_load/","title":""},{"contents":" Syntax INT pal_map_assign ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt;, \u0026lt;INT paletteID\u0026gt; )\nDescription Changes the color palette of an 8 bit (256 color) graphic, with the palette that is loaded with Pal_load(). This palette can also be loaded from MAP\u0026rsquo;s, FPG\u0026rsquo;s, FNT\u0026rsquo;s and other image formats, provided that they are 8 bit images. Unlike Pal_set(), the change is immediately visible.\nParameters INT fileID - The fileID of the graphic(s), i.e. 0 for the systemfile, or the id code of an FPG archive. INT graphID - The graphic (or mapcode) to modify. INT paletteID - The handle of the color palette loaded with Pal_load().\nReturns INT : Error.\n0 - Error: could not open file; corrupt or truncated file; file doesn\u0026rsquo;t contain palette information. 1 - No error: palette was loaded with success.\nExample /* Original example from bennupack: 2 Medium\\fenix test\\palettes\\rbear8_1.prg (from bomberlink) */ IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_map\u0026quot;; IMPORT \u0026quot;mod_key\u0026quot;; IMPORT \u0026quot;mod_video\u0026quot;; IMPORT \u0026quot;mod_text\u0026quot;; GLOBAL int pal_orange; // palette 1 int pal_green; // palette 2 int map_count; int fpg_id; PROCESS main(); BEGIN set_fps(10,0); set_mode(320,200,16); // load the fpg archive fpg_id=fpg_load(\u0026quot;rbear8.fpg\u0026quot;); // load the two palettes pal_orange=pal_load(\u0026quot;rbear8-orange.pal\u0026quot;); pal_green=pal_load(\u0026quot;rbear8-green.pal\u0026quot;); write_int(0,10,10,0,\u0026amp;fps); write(0,10,20,0,\u0026quot;F1/F2 - change palette\u0026quot;); x=160; y=120; WHILE (NOT key(_ESC)) FROM graph=1 TO 3; FRAME; IF (key(_F1)) FROM map_count=1 TO 102; say(\u0026quot;changing colors: \u0026quot;+map_count); pal_map_assign(fpg_id,map_count,pal_green); // apply palette 1 END END IF (key(_F2)) FROM map_count=1 TO 102; say(\u0026quot;changing colors: \u0026quot;+map_count); pal_map_assign(fpg_id,map_count,pal_orange); // apply palette 2 END END IF (key(_ESC)) BREAK; END END END END  Used in example: Pal_load(), Say(), Set_fps(), Set_mode(), Write(), Write_int()\nCategory:functions Category:palettes Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/pal_map_assign/","title":""},{"contents":" Syntax INT pal_map_getid ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; )\nDescription This function returns the identification code of the palette of a specific graphic.\nParameters INT fileID - The handle of the file. INT graphID - The handle of the graph.\nReturns INT : Error/status.\n0 - Error: could not open file; corrupt or truncated file; file doesn\u0026rsquo;t contain palette information. id - The identifier of the palette.\nExample /* original bennupack example FROM: \\2 Medium\\fenix test\\palettes\\rbear8-5.prg (from bomberlink) */ /* this program demonstrates the use of the functions: pal_load(), pal_map_get_id() */ /* pal_map_assign(), pal_set() and pal_refresh(). */ /* In this example pal_get() is not used but the table is filled with data by forehand. */ IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_map\u0026quot;; IMPORT \u0026quot;mod_key\u0026quot;; IMPORT \u0026quot;mod_video\u0026quot;; IMPORT \u0026quot;mod_text\u0026quot;; GLOBAL int pal_normal; // identifier of the palette int fpg_id; // identifier of the fpg file // the arrays with data (pre-filled) byte orange_palette_data[21] = 80,0,0, 110,0,0, 140,0,0, 170,0,0, 190,0,0, 220,0,0, 250,0,0; byte green_palette_data[21] = 0, 80,0, 0,110,0, 0,140,0, 0,170,0, 0,190,0, 0,220,0, 0,250,0; int count; PROCESS main(); BEGIN set_fps(10,0); set_mode(320,200,16); // load the fpg fpg_id=fpg_load(\u0026quot;rbear8.fpg\u0026quot;); write_int(0,10,10,0,\u0026amp;fps); write(0,10,20,0,\u0026quot;F1/F2 - change palette\u0026quot;); x=160; y=120; pal_normal=pal_map_getid(fpg_id,1); // file,graph say(\u0026quot;pal_normal: \u0026quot;+pal_normal); WHILE (NOT key(_ESC)) FROM graph=1 TO 13; FRAME; IF (key(_F1)) pal_set(pal_normal,7,7,\u0026amp;green_palette_data); // colors 7 - 13 pal_refresh(pal_normal); END IF (key(_F2)) pal_set(pal_normal,7,7,\u0026amp;orange_palette_data); // colors 7 - 13 pal_refresh(pal_normal); END IF (key(_ESC)) BREAK; END END END END  Used in example: , Pal_set(), Pal_map_assign(), Pal_refresh(), Say(), Set_fps(), Set_mode(), Write(), Write_int()\nSee also Pal_set(), Pal_get()\nCategory:functions Category:palettes Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/pal_map_getid/","title":""},{"contents":" Syntax INT pal_map_remove ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; )\nDescription Removes the color palette that assigned with Pal_map_assign(). It is basically an undo function for color palette changes.\nParameters INT fileID - The fileID of the graphic(s), i.e. 0 for the systemfile, or the id code of an FPG archive. INT graphID - The graphic (or mapcode).\nReturns INT : Status/Error.\n0 - Error: could not open file; corrupt or truncated file; file doesn\u0026rsquo;t contain palette information. 1 - No error: palette was reverted with success.\nExample /* Original example from bennupack: 2 Medium\\fenix test\\palettes\\rbear8_1.prg (from bomberlink) */ IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_map\u0026quot;; IMPORT \u0026quot;mod_key\u0026quot;; IMPORT \u0026quot;mod_video\u0026quot;; IMPORT \u0026quot;mod_text\u0026quot;; GLOBAL int pal_orange; // palette 1 int pal_green; // palette 2 int map_count; int fpg_id; int status; PROCESS main(); BEGIN set_fps(10,0); set_mode(320,200,16); // we use a 16 bit colormode // load the fpg archive fpg_id=fpg_load(\u0026quot;rbear8.fpg\u0026quot;); // load the two palettes pal_orange=pal_load(\u0026quot;rbear8-orange.pal\u0026quot;); pal_green=pal_load(\u0026quot;rbear8-green.pal\u0026quot;); write_int(0,10,10,0,\u0026amp;fps); write(0,10,20,0,\u0026quot;F1/F2 - change palette\u0026quot;); write(0,10,30,0,\u0026quot;F3 - to undo palette changes\u0026quot;); x=160; y=120; WHILE (NOT key(_ESC)) FROM graph=1 TO 3; // cycle through 3 graphics FRAME; IF (key(_F1)) FROM map_count=1 TO 102; // there are 102 frames in the animation. say(\u0026quot;changing colors: \u0026quot;+map_count); pal_map_assign(fpg_id,map_count,pal_green); // apply palette 1 END END IF (key(_F2)) FROM map_count=1 TO 102; say(\u0026quot;changing colors: \u0026quot;+map_count); pal_map_assign(fpg_id,map_count,pal_orange); // apply palette 2 END END IF (key(_F3)) FROM map_count=1 TO 102; say(\u0026quot;changing colors: \u0026quot;+map_count); status=pal_map_remove(fpg_id,map_count); say(\u0026quot;status: \u0026quot;+status); END END IF (key(_ESC)) BREAK; END END END END  Used in example: Say(), Pal_load(), Pal_map_assign(), Key(), Write(), Write_int()\nCategory:functions Category:palettes Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/pal_map_remove/","title":""},{"contents":" Syntax INT pal_new ()\nDescription This function creates a new palette in memory and returns the handle, for later use by other palette functions such as Pal_save(), Pal_get(), Pal_set, etc. When you\u0026rsquo;re done, you can free the memory with Pal_unload().\nThe previous name new_pal() is deprecated.\nReturns INT : Status.\nid - The identification code of the memory area for the newly created palette.\nCategory:functions Category:palettes Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/pal_new/","title":""},{"contents":" Syntax INT pal_refresh ( [\u0026lt;INT paletteID\u0026gt;] )\nDescription Refreshes the color palette after a call of Pal_set(), to the make color change visible.\nParameters INT paletteID - The handle of the color palette loaded with Pal_load(), and used by Pal_get and Pal_set(). The parameter is optional.\nReturns INT : Status.\n1 - The status.\nExample /* original bennupack example FROM: \\2 Medium\\fenix test\\palettes\\rbear8-2.prg (from bomberlink) */ /* this program demonstrates the use of the functions: pal_load(), pal_clone(), pal_get(), */ /* pal_map_assign(), pal_set() and pal_refresh(). */ IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_map\u0026quot;; IMPORT \u0026quot;mod_key\u0026quot;; IMPORT \u0026quot;mod_video\u0026quot;; IMPORT \u0026quot;mod_text\u0026quot;; GLOBAL // palette identifiers int pal_orange; int pal_green; int pal_normal; int status1; int status2; // identifier of the fpg archive int fpg_id; // arrays for the data of the two color palettes. byte pal_orange_data[255]; byte pal_green_data[255]; int map_count; PROCESS main(); BEGIN set_fps(10,0); set_mode(320,200,16); // we use a 16 bit color mode // load two color palettes and duplicate one pal_green=pal_load(\u0026quot;rbear8-green.pal\u0026quot;); pal_orange=pal_load(\u0026quot;rbear8-orange.pal\u0026quot;); // pal_clone (int pal_id); pal_normal=pal_clone(pal_orange); // duplicate palette, i.e. make a copy of it. // load the fpg file fpg_id=fpg_load(\u0026quot;rbear8.fpg\u0026quot;); write_int(0,10,10,0,\u0026amp;fps); write(0,10,20,0,\u0026quot;F1/F2 - change palette\u0026quot;); x = 160; y = 120; // pal_get (int pal_id, int start_color, int num_colors, pointer pal_data); pal_get(pal_green,7,7,\u0026amp;pal_green_data); // get colors 7 - 13 and store them in the array pal_get(pal_orange,7,7,\u0026amp;pal_orange_data); FROM map_count=1 TO 102; // there are 102 frames in the animation // pal_map_assign (int fileid, int graph, int pal_id); pal_map_assign(fpg_id,map_count,pal_normal); // assign the \u0026quot;normal (original source)\u0026quot; color // palette that we duplicated earlier. END WHILE (NOT key(_ESC)) FROM graph=1 TO 13; FRAME; IF (key(_F1)) say(\u0026quot;switched to green palette\u0026quot;); // pal_set (int pal_id, int start_color, int num_colors, pointer pal_data); status1=pal_set(pal_normal,7,7,\u0026amp;pal_green_data); // change colors 7 - 13 in the \u0026quot;normal\u0026quot; // palette, by using the values from the // \u0026quot;green\u0026quot; color palette. say(\u0026quot;pal_set_status: \u0026quot;+status1); // pal_refresh (int pal_id); status2=pal_refresh(pal_normal); // apply the modified color palette to the graphics. // this function is required to make the change visible. say(\u0026quot;pal_refresh_status: \u0026quot;+status2); // conclusion: the difference between pal_map_assign() and pal_set() is that pal_map_assign() // works immediately, and that pal_set() requires the palette to be refreshed to make the // change visible. END IF (key(_F2)) say(\u0026quot;switched to orange palette\u0026quot;); pal_set(pal_normal,7,7,\u0026amp;pal_orange_data); // colors 7 - 13 pal_refresh(pal_normal); END IF (key(_ESC)) BREAK; END END END END  Used in example: Pal_load(), pal_get(), Pal_set(), Pal_map_assign(), Pal_clone(), Say(), Set_fps(), Set_mode(), Write(), Write_int()\nCategory:functions Category:palettes Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/pal_refresh/","title":""},{"contents":" Syntax INT pal_save ( \u0026lt;STRING filename\u0026gt;, [\u0026lt;INT paletteID\u0026gt;] )\nDescription This function saves a palette to a file on disk in the PAL format. When the second parameter is omitted, the system palette is saved, otherwise the palette data indicate with the paletteID. Concluding from this, is that it\u0026rsquo;s possible to load multiple palettes in bennu and assign an unique identifier to them and save them to a file later.\nThe previous name save_pal() is deprecated.\nParameters STRING filename - The filename of the new palette file. INT paletteID - The handle of the palette that was loaded with Load_pal(). This parameter is optional.\nReturns INT : Status.\nid - The file handle.\nCategory:functions Category:palettes Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/pal_save/","title":""},{"contents":" Syntax INT pal_set ( [\u0026lt;INT paletteID\u0026gt;] , \u0026lt;INT first_color\u0026gt; , \u0026lt;INT num_colors\u0026gt; , \u0026lt;POINTER palette_data\u0026gt;)\nDescription Changes the color palette of an 8 bit (256 color) graphic, with the palette that is loaded with Pal_load(). This palette can also be loaded from MAP\u0026rsquo;s, FPG\u0026rsquo;s, FNT\u0026rsquo;s and other image formats, provided that they are 8 bit images. Unlike Pal_map_assign(), the change is not immediately visible, and the function Pal_refresh() has to be called afterwards to make the change visible. The difference however, is that it not replaces the whole palette, but allows a specified number of colors to be changed, so it\u0026rsquo;s a bit more flexible.\nAlso called colors_set(). The previous name set_colors() is deprecated.\nParameters INT paletteID - The handle of the color palette loaded with Pal_load(). This paramter is optional. INT first_color - The first color number of the palette. This doesn\u0026rsquo;t necessarily have be the first color. INT num_colors - The number of colors you want to replace, wich counts from the first_color to the num_colors. See notes. POINTER palette_data - Pointer (Offset) to an array with the color values, that where obtained with Pal_get().\nNote The maximum number of colors cannot be bigger the 255. The num_colors starts counting from first_color, so if the first_color is 7, and num_colors is 7, the color value\u0026rsquo;s 7-13 are changed. So logically, the value num_colors can only be 255 when first_color is 0. This range gives you all the colors. To be safe, the formula for the number of colors to modified is: num_colors-first_color.\nI.e. num_colors: 55 - first_color: 4 = 51 colors are changed, the range from color index 4 up to color index 55.\nReturns INT : Error.\n0 - Error: could not open file; corrupt or truncated file; file doesn\u0026rsquo;t contain palette information. 1 - No error: palette was set with success.\nExample /* original bennupack example FROM: \\2 Medium\\fenix test\\palettes\\rbear8-2.prg (from bomberlink) */ /* this program demonstrates the use of the functions: pal_load(), pal_clone(), pal_get(), */ /* pal_map_assign(), pal_set() and pal_refresh(). */ IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_map\u0026quot;; IMPORT \u0026quot;mod_key\u0026quot;; IMPORT \u0026quot;mod_video\u0026quot;; IMPORT \u0026quot;mod_text\u0026quot;; GLOBAL // palette identifiers int pal_orange; int pal_green; int pal_normal; int status1; int status2; // identifier of the fpg archive int fpg_id; // arrays for the data of the two color palettes. byte pal_orange_data[255]; byte pal_green_data[255]; int map_count; PROCESS main(); BEGIN set_fps(10,0); set_mode(320,200,16); // we use a 16 bit color mode // load two color palettes and duplicate one pal_green=pal_load(\u0026quot;rbear8-green.pal\u0026quot;); pal_orange=pal_load(\u0026quot;rbear8-orange.pal\u0026quot;); // pal_clone (int pal_id); pal_normal=pal_clone(pal_orange); // duplicate palette, i.e. make a copy of it. // load the fpg file fpg_id=fpg_load(\u0026quot;rbear8.fpg\u0026quot;); write_int(0,10,10,0,\u0026amp;fps); write(0,10,20,0,\u0026quot;F1/F2 - change palette\u0026quot;); x = 160; y = 120; // pal_get (int pal_id, int start_color, int num_colors, pointer pal_data); pal_get(pal_green,7,7,\u0026amp;pal_green_data); // get colors 7 - 13 and store them in the array pal_get(pal_orange,7,7,\u0026amp;pal_orange_data); FROM map_count=1 TO 102; // there are 102 frames in the animation // pal_map_assign (int fileid, int graph, int pal_id); pal_map_assign(fpg_id,map_count,pal_normal); // assign the \u0026quot;normal (original source)\u0026quot; color // palette that we duplicated earlier. END WHILE (NOT key(_ESC)) FROM graph=1 TO 13; FRAME; IF (key(_F1)) say(\u0026quot;switched to green palette\u0026quot;); // pal_set (int pal_id, int start_color, int num_colors, pointer pal_data); status1=pal_set(pal_normal,7,7,\u0026amp;pal_green_data); // change colors 7 - 13 in the \u0026quot;normal\u0026quot; // palette, by using the values from the // \u0026quot;green\u0026quot; color palette. say(\u0026quot;pal_set_status: \u0026quot;+status1); // pal_refresh (int pal_id); status2=pal_refresh(pal_normal); // apply the modified color palette to the graphics. // this function is required to make the change visible. say(\u0026quot;pal_refresh_status: \u0026quot;+status2); // conclusion: the difference between pal_map_assign() and pal_set() is that pal_map_assign() // works immediately, and that pal_set() requires the palette to be refreshed to make the // change visible. END IF (key(_F2)) say(\u0026quot;switched to orange palette\u0026quot;); pal_set(pal_normal,7,7,\u0026amp;pal_orange_data); // colors 7 - 13 pal_refresh(pal_normal); END IF (key(_ESC)) BREAK; END END END END  Used in example: Pal_load(), pal_clone(), Pal_get(), Pal_map_assign(), Pal_refresh(), Say(), Set_fps(), Set_mode(), Write(), Write_int()\nCategory:functions Category:palettes Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/pal_set/","title":""},{"contents":" Syntax INT pal_unload ( \u0026lt;INT paletteID\u0026gt; )\nDescription This function unloads the palette, thus freeing the memory it ouccupies.\nAlso called pal_del(). The previous name unload_pal() is deprecated.\nParameters INT paletteID - The handle of the palette that was loaded with Load_pal().\nReturns INT : Status.\n1 - Operation completed.\nCategory:functions Category:palettes Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/pal_unload/","title":""},{"contents":" What are palettes Color palettes are used in 8 bit indexed images and can have up to 256 colors. It\u0026rsquo;s called indexing because a palette is a list with r,g,b values denoted with an index number (wich is the color value). This is a cornerstone of functions like Map_get_pixel().\nMore information: Indexed color, Color look-up tables\nThe system palette uint8_t default_palette[] = { 0, 0, 0, /* Color 0 */ 16, 16, 16, /* Color 1 */ 32, 32, 32, /* Color 2 */ 48, 48, 48, /* Color 3 */ 64, 64, 64, /* Color 4 */ 84, 84, 84, /* Color 5 */ 100, 100, 100, /* Color 6 */ 116, 116, 116, /* Color 7 */ 132, 132, 132, /* Color 8 */ 148, 148, 148, /* Color 9 */ 168, 168, 168, /* Color 10 */ 184, 184, 184, /* Color 11 */ 200, 200, 200, /* Color 12 */ 216, 216, 216, /* Color 13 */ 232, 232, 232, /* Color 14 */ 252, 252, 252, /* Color 15 */ 40, 0, 0, /* Color 16 */ 72, 0, 0, /* Color 17 */ 108, 0, 0, /* Color 18 */ 144, 0, 0, /* Color 19 */ 180, 0, 0, /* Color 20 */ 216, 0, 0, /* Color 21 */ 252, 0, 0, /* Color 22 */ 252, 32, 0, /* Color 23 */ 252, 64, 0, /* Color 24 */ 252, 96, 0, /* Color 25 */ 252, 128, 0, /* Color 26 */ 252, 160, 0, /* Color 27 */ 252, 180, 56, /* Color 28 */ 252, 200, 112, /* Color 29 */ 252, 220, 168, /* Color 30 */ 252, 240, 224, /* Color 31 */ 0, 40, 0, /* Color 32 */ 0, 60, 0, /* Color 33 */ 0, 84, 0, /* Color 34 */ 0, 108, 0, /* Color 35 */ 0, 132, 0, /* Color 36 */ 0, 156, 0, /* Color 37 */ 0, 180, 0, /* Color 38 */ 0, 204, 0, /* Color 39 */ 0, 228, 0, /* Color 40 */ 0, 252, 0, /* Color 41 */ 48, 252, 32, /* Color 42 */ 96, 252, 64, /* Color 43 */ 144, 252, 96, /* Color 44 */ 192, 252, 132, /* Color 45 */ 216, 252, 176, /* Color 46 */ 240, 252, 220, /* Color 47 */ 0, 0, 40, /* Color 48 */ 0, 0, 72, /* Color 49 */ 0, 0, 104, /* Color 50 */ 0, 0, 140, /* Color 51 */ 0, 0, 172, /* Color 52 */ 0, 0, 208, /* Color 53 */ 0, 0, 252, /* Color 54 */ 0, 48, 252, /* Color 55 */ 0, 100, 252, /* Color 56 */ 0, 148, 252, /* Color 57 */ 0, 200, 252, /* Color 58 */ 0, 252, 252, /* Color 59 */ 56, 252, 252, /* Color 60 */ 112, 252, 252, /* Color 61 */ 168, 252, 252, /* Color 62 */ 224, 252, 252, /* Color 63 */ 28, 28, 0, /* Color 64 */ 52, 52, 0, /* Color 65 */ 76, 76, 0, /* Color 66 */ 100, 100, 0, /* Color 67 */ 124, 124, 0, /* Color 68 */ 152, 152, 0, /* Color 69 */ 176, 176, 0, /* Color 70 */ 200, 200, 0, /* Color 71 */ 224, 224, 0, /* Color 72 */ 252, 252, 0, /* Color 73 */ 252, 252, 36, /* Color 74 */ 252, 252, 72, /* Color 75 */ 252, 252, 108, /* Color 76 */ 252, 252, 144, /* Color 77 */ 252, 252, 180, /* Color 78 */ 252, 252, 220, /* Color 79 */ 28, 0, 28, /* Color 80 */ 52, 0, 52, /* Color 81 */ 76, 0, 76, /* Color 82 */ 100, 0, 100, /* Color 83 */ 124, 0, 124, /* Color 84 */ 152, 0, 152, /* Color 85 */ 176, 0, 176, /* Color 86 */ 200, 0, 200, /* Color 87 */ 224, 0, 224, /* Color 88 */ 252, 0, 252, /* Color 89 */ 252, 36, 252, /* Color 90 */ 252, 72, 252, /* Color 91 */ 252, 112, 252, /* Color 92 */ 252, 148, 252, /* Color 93 */ 252, 184, 252, /* Color 94 */ 252, 224, 252, /* Color 95 */ 0, 20, 20, /* Color 96 */ 0, 40, 40, /* Color 97 */ 0, 60, 60, /* Color 98 */ 0, 80, 80, /* Color 99 */ 0, 104, 100, /* Color 100 */ 0, 124, 120, /* Color 101 */ 0, 144, 144, /* Color 102 */ 0, 164, 164, /* Color 103 */ 0, 188, 184, /* Color 104 */ 0, 208, 204, /* Color 105 */ 0, 228, 224, /* Color 106 */ 0, 252, 248, /* Color 107 */ 44, 252, 248, /* Color 108 */ 92, 252, 248, /* Color 109 */ 140, 252, 248, /* Color 110 */ 188, 252, 248, /* Color 111 */ 24, 12, 0, /* Color 112 */ 44, 24, 0, /* Color 113 */ 64, 36, 0, /* Color 114 */ 84, 48, 0, /* Color 115 */ 108, 60, 0, /* Color 116 */ 128, 72, 0, /* Color 117 */ 148, 84, 0, /* Color 118 */ 168, 96, 0, /* Color 119 */ 192, 112, 0, /* Color 120 */ 196, 128, 28, /* Color 121 */ 204, 144, 60, /* Color 122 */ 212, 160, 92, /* Color 123 */ 216, 180, 120, /* Color 124 */ 224, 196, 152, /* Color 125 */ 232, 212, 184, /* Color 126 */ 240, 232, 216, /* Color 127 */ 24, 12, 12, /* Color 128 */ 40, 20, 20, /* Color 129 */ 60, 32, 32, /* Color 130 */ 80, 44, 44, /* Color 131 */ 96, 52, 52, /* Color 132 */ 116, 64, 64, /* Color 133 */ 136, 76, 76, /* Color 134 */ 156, 88, 88, /* Color 135 */ 176, 104, 104, /* Color 136 */ 196, 120, 120, /* Color 137 */ 216, 136, 136, /* Color 138 */ 240, 152, 152, /* Color 139 */ 240, 168, 168, /* Color 140 */ 244, 188, 188, /* Color 141 */ 244, 204, 204, /* Color 142 */ 248, 224, 224, /* Color 143 */ 24, 20, 12, /* Color 144 */ 44, 36, 24, /* Color 145 */ 68, 52, 36, /* Color 146 */ 88, 72, 48, /* Color 147 */ 112, 88, 60, /* Color 148 */ 132, 104, 72, /* Color 149 */ 156, 124, 88, /* Color 150 */ 172, 140, 100, /* Color 151 */ 188, 156, 112, /* Color 152 */ 204, 176, 124, /* Color 153 */ 220, 192, 136, /* Color 154 */ 240, 212, 152, /* Color 155 */ 240, 216, 168, /* Color 156 */ 244, 224, 188, /* Color 157 */ 244, 232, 204, /* Color 158 */ 248, 240, 224, /* Color 159 */ 32, 8, 0, /* Color 160 */ 60, 16, 0, /* Color 161 */ 88, 28, 0, /* Color 162 */ 120, 36, 0, /* Color 163 */ 148, 48, 0, /* Color 164 */ 176, 56, 0, /* Color 165 */ 208, 68, 0, /* Color 166 */ 216, 88, 0, /* Color 167 */ 224, 112, 0, /* Color 168 */ 232, 136, 0, /* Color 169 */ 240, 160, 0, /* Color 170 */ 252, 184, 0, /* Color 171 */ 252, 200, 56, /* Color 172 */ 252, 216, 112, /* Color 173 */ 252, 232, 168, /* Color 174 */ 252, 252, 224, /* Color 175 */ 20, 12, 12, /* Color 176 */ 36, 24, 24, /* Color 177 */ 56, 36, 36, /* Color 178 */ 72, 48, 48, /* Color 179 */ 92, 64, 64, /* Color 180 */ 108, 76, 76, /* Color 181 */ 128, 88, 88, /* Color 182 */ 144, 100, 100, /* Color 183 */ 164, 116, 116, /* Color 184 */ 172, 132, 132, /* Color 185 */ 184, 148, 148, /* Color 186 */ 192, 164, 164, /* Color 187 */ 204, 180, 180, /* Color 188 */ 212, 196, 196, /* Color 189 */ 224, 212, 212, /* Color 190 */ 236, 232, 232, /* Color 191 */ 12, 20, 12, /* Color 192 */ 24, 36, 24, /* Color 193 */ 36, 56, 36, /* Color 194 */ 48, 72, 48, /* Color 195 */ 64, 92, 64, /* Color 196 */ 76, 108, 76, /* Color 197 */ 88, 128, 88, /* Color 198 */ 100, 144, 100, /* Color 199 */ 116, 164, 116, /* Color 200 */ 132, 172, 132, /* Color 201 */ 148, 184, 148, /* Color 202 */ 164, 192, 164, /* Color 203 */ 180, 204, 180, /* Color 204 */ 196, 212, 196, /* Color 205 */ 212, 224, 212, /* Color 206 */ 232, 236, 232, /* Color 207 */ 12, 12, 16, /* Color 208 */ 24, 24, 32, /* Color 209 */ 36, 36, 48, /* Color 210 */ 48, 48, 64, /* Color 211 */ 64, 64, 80, /* Color 212 */ 76, 76, 96, /* Color 213 */ 88, 88, 112, /* Color 214 */ 100, 100, 128, /* Color 215 */ 116, 116, 148, /* Color 216 */ 132, 132, 160, /* Color 217 */ 148, 148, 172, /* Color 218 */ 164, 164, 184, /* Color 219 */ 180, 180, 196, /* Color 220 */ 196, 196, 208, /* Color 221 */ 212, 212, 220, /* Color 222 */ 232, 232, 236, /* Color 223 */ 40, 0, 0, /* Color 224 */ 80, 0, 0, /* Color 225 */ 124, 0, 0, /* Color 226 */ 164, 0, 0, /* Color 227 */ 208, 0, 0, /* Color 228 */ 252, 0, 0, /* Color 229 */ 252, 40, 0, /* Color 230 */ 252, 84, 0, /* Color 231 */ 252, 124, 0, /* Color 232 */ 252, 168, 0, /* Color 233 */ 252, 208, 0, /* Color 234 */ 252, 252, 0, /* Color 235 */ 252, 252, 44, /* Color 236 */ 252, 252, 92, /* Color 237 */ 252, 252, 140, /* Color 238 */ 252, 252, 188, /* Color 239 */ 0, 0, 0, /* Color 240 */ 0, 0, 88, /* Color 241 */ 0, 0, 128, /* Color 242 */ 0, 0, 168, /* Color 243 */ 0, 0, 208, /* Color 244 */ 0, 0, 248, /* Color 245 */ 40, 0, 248, /* Color 246 */ 84, 0, 248, /* Color 247 */ 124, 0, 248, /* Color 248 */ 168, 0, 248, /* Color 249 */ 208, 0, 248, /* Color 250 */ 252, 0, 252, /* Color 251 */ 252, 52, 252, /* Color 252 */ 252, 108, 252, /* Color 253 */ 252, 164, 252, /* Color 254 */ 252, 220, 252 /* Color 255 */ } ;  Category:palettes Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/palette/","title":""},{"contents":" Syntax INT palette_convert ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; , \u0026lt;POINTER palette_data\u0026gt; )\nDescription This function changes the colormap of an image, but does not change the color index values it self. That is, that the individual pixels will keep their color indexes, but the r,g,b values in the palette are modified. This function requires an Array of maximum 255 bytes (or integers), to store the palette values. The array is accessed with the Offset operator.\nThe previous name Convert_palette() is deprecated.\nParameters INT fileID - The handle of the file containing the graphics. INT graphID - The handle of the graphic. POINTER palette_data - Pointer to the Array with the new palette data, to be accessed with the Offset operator.\nReturns INT : Status.\n1 - Success.\nExample IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_map\u0026quot;; IMPORT \u0026quot;mod_key\u0026quot;; IMPORT \u0026quot;mod_video\u0026quot;; IMPORT \u0026quot;mod_screen\u0026quot;; IMPORT \u0026quot;mod_text\u0026quot;; GLOBAL int map_id; int clonemap_id; int palette_table[255]; int color; int status; PROCESS main(); BEGIN set_mode(320,240,16); map_id=load_map(\u0026quot;MAP.MAP\u0026quot;); clonemap_id=map_clone(0,map_id); // create a copy of the map write(0,80,30,4,\u0026quot;Original image:\u0026quot;); write(0,240,30,4,\u0026quot;Converted image (clone):\u0026quot;); write(0,160,140,4,\u0026quot;Spacebar: Change the palette of the clone...\u0026quot;); write(0,160,190,4,\u0026quot;Press ESC to quit...\u0026quot;); // palette color 0 (the transparant color) will be not changed, that's why the // count starts at 1. // values that go beyond 255 will be cut off by the MOD (%). So, 256, becomes 0, // 257 becomes 2 etc. The fist 16 colors will stay untouched. FROM color=1 TO 255; palette_table[color]=(color+16) MOD 255; say(\u0026quot;palette_table[\u0026quot;+color+\u0026quot;]\u0026quot;); END xput(0,map_id,80,70,0,25,0,0); x=240; y=70; graph=clonemap_id; size=25; REPEAT IF (key(_space)) // let's do the conversion status=palette_convert(0,clonemap_id,\u0026amp;palette_table); say(\u0026quot;status: \u0026quot;+status); END FRAME; UNTIL(key(_esc)) END  Used in example: Say(), Key(), Write(), Map_clone(), Xput()\nCategory:functions Category:palettes Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/palette_convert/","title":""},{"contents":" Syntax INT palette_roll ( \u0026lt;INT start_color\u0026gt; , \u0026lt;INT end_color\u0026gt; , \u0026lt;INT increment\u0026gt; )\nDescription Cycles the colors in the palette by rotating them. This function shifts colors between the range specified by the start color and the end color, at a given increment. This can be used to create a very old school waterfall animation effect. This technique is called color cycling. It is a very memory efficient way of doing these kinds of animations, since only one bitmap is used and the effect is achieved by cycling through a specific range of colors. Here\u0026rsquo;s a nice (web based) example of this technique in action.\nTo use this function, you have to create graphics that use a range of consecutive colors of the original palette, in a perpetual cycle (i.e., colors ranging from 0 to 15, painting something with the colors 0, 1, 2, 3, \u0026hellip; , 14, 15, 0, 1, 2, \u0026hellip;).\nAlso, make sure that these colors are not used by other graphics that are going to appear on the screen at the same time, if you do not want to apply these effects on them, or they\u0026rsquo;ll look funny.\nOne important thing, this function only works in 8 bit mode.\nThe previous name roll_palette() is deprecated.\nParameters INT start_color - The start color of the range (0-255). INT end_colors - The last color of the range (0-255). INT increment - The cycle speed (-1, 0, 1, etc).\nNotes An increment of 0 is pointless, because that will stop the cycle. The higher the number, the faster the cycle goes. Negative values will cycle in the opposite direction.\nReturns INT : Status.\n1 - Success.\nExample IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_map\u0026quot;; IMPORT \u0026quot;mod_key\u0026quot;; IMPORT \u0026quot;mod_video\u0026quot;; IMPORT \u0026quot;mod_screen\u0026quot;; IMPORT \u0026quot;mod_text\u0026quot;; GLOBAL int map; int fnt; byte color_increment=1; byte initial_color; byte num_colors=10; PROCESS main(); BEGIN set_fps(50,0); set_mode(640,480,8); // for palette_roll to work is the 8 bit mode required! map=load_map(\u0026quot;MAP.MAP\u0026quot;); put_screen(0,map); write(0,10,10,3,\u0026quot;Rolling Palette demo, +/-: change number of colors, 0, 1, 2: change increment, Press ESC to quit...\u0026quot;); REPEAT // changes the amount of colors IF (key(_plus) AND num_colors\u0026lt;255) FRAME; num_colors+=1; END IF (key(_minus) AND num_colors\u0026gt;1) FRAME; num_colors-=1; END // change the speed IF (key(_0)) FRAME; color_increment=0; END IF (key(_1)) FRAME; color_increment=1; END IF (key(_2)) FRAME; color_increment=-1; END // roll the palette palette_roll(initial_color,num_colors,color_increment); say(\u0026quot;initial color: \u0026quot;+initial_color+\u0026quot; num color: \u0026quot;+num_colors+\u0026quot; increment: \u0026quot;+color_increment); FRAME; UNTIL(key(_esc)) END  Used in example: Say(), Key(), Write()\nCategory:functions Category:palettes Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/palette_roll/","title":""},{"contents":" Description A parameter is the variable and its value inside the definition of a function or process that is received from the calling environment. The value passed on when calling the function or process is called an argument.\nIf a parameter is named like a local variable, the value passed to it will be assigned to that local variable for a process. This means that passed arguments will modify the local variable. This is commonly used for x, y and graph local variables, but can also be used for alpha, angle and others.\nNotes There currently is a limit of 15 parameters that can be used per function or process.\nExample Process Main() Private int argument = 3; Begin my_proc( argument ); End  Process my_proc( int parameter ) Begin //statements End  See also  Argument  ","permalink":"https://divhub.github.io/pixtudio-website/docs/parameter/","title":""},{"contents":" Syntax \u0026rdquo;\u0026lsquo;INT \u0026ldquo;\u0026rsquo; path_find ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; , \u0026lt;INT start_x\u0026gt; , \u0026lt;INT start_y\u0026gt; , \u0026lt;INT dest_x\u0026gt; , \u0026lt;INT dest_y\u0026gt; , \u0026lt;INT options\u0026gt;)\nDescription The pathfinding function is based on the A* algorithm with a heuristic value. It uses a logic map with a maze, a start position and an end position. The logic map is an 8 bit image (with palette), preferably with only 2 colors, black and white, wich indicates the walls and the paths.\nHere\u0026rsquo;s the bennu source code: mod_path.c, wikipedia page about pathfinding.\nParameters INT fileID - The fpg archive wich contains the map, may be 0 when the systemfile is used. INT graphID - The bitmap (either mapcode from fpg or loaded with Map_load() into the systemfile) with the maze, see notes*. INT start_x - The x coordniate of the start position. INT start_y - The y coordniate of the start position. INT dest_x - The x coordinate of the destination position. INT dest_y - The y coordinate of the destination position. INT options - The kind of pathfinding, PF_NODIAG, PF_REVERSE\nReturns INT : Status.\n0 - The path has not been found yet. 1 - The path has been found.\nExample Look at this tutorial: Tutorial:Pathfind_demo.\nNotes  This function requires the use of 8 bit indexed (256 color) bitmaps for the path map, because of the logic behind it\u0026rsquo;s design. The philosophy behind this is similair to a hardness (logic) map. It is perfectly possible to combine 8 bit images in 16 or 32 bit colormodes, provided that all 8 bit maps share the same colorpalette.  Category:functions Category:Pathfind Category:mod_path\n","permalink":"https://divhub.github.io/pixtudio-website/docs/path_find/","title":""},{"contents":" Syntax \u0026rdquo;\u0026lsquo;INT \u0026ldquo;\u0026rsquo; path_getxy ( \u0026lt;POINTER x\u0026gt;, \u0026lt;POINTER y\u0026gt; )\nDescription This function gets a node and returns a 1 when there\u0026rsquo;s still a point left, or a 0 when there are no more points. This function requires a two dimensional Array to work on. The arguments should accessed with the Offset operator. The function is typically used inside a loop. The pathfinding in bennu is based on the A* algorithm. It uses a logic map with a maze, a start position and an end position.\nHere\u0026rsquo;s the bennu source code: mod_path.c, wikipedia page about pathfinding.\nParameters POINTER x - Offset of the array with the x values. POINTER y - Offset of the array with the y values.\nReturns INT : Status.\n0 - There are no more coordinate points (nodes) in the list. 1 - There are still coordinate points (nodes) in the list.\nExample Look at this tutorial: Tutorial:Pathfind_demo.\nCategory:functions Category:Pathfind Category:mod_path\n","permalink":"https://divhub.github.io/pixtudio-website/docs/path_getxy/","title":""},{"contents":" Syntax \u0026rdquo;\u0026lsquo;INT \u0026ldquo;\u0026rsquo; path_wall ( \u0026lt;INT wall_color\u0026gt; )\nDescription This function changes the wall color. Normally, Path_find() only uses two colors, i.e. black and white. By using this function before making a call to Path_find, Path_find will use the color indiated by this function instead. The color may not be a zero, bcause that is usually black. \u0026ldquo;For more information, see the http://bennugd.svn.sourceforge.net/viewvc/bennugd/modules/mod_path/mod_path.c?revision=277\u0026amp;view=markup bennu mod_path.c sourcecode. \u0026ldquo;\nParameters INT Color - The palette color.\nReturns INT : - The color value.\nCategory:functions Category:Pathfind Category:mod_path\n","permalink":"https://divhub.github.io/pixtudio-website/docs/path_wall/","title":""},{"contents":" Definition Pathfind flags are used in path_find(), to specify optional functionality.\nList Constant - Value - Description PF_NODIAG - 1 - Prohibit the pathfinding from using diagonal paths. PF_REVERSE - 2 - Return the path found in reverse order.\nCategory:constantcategories\n","permalink":"https://divhub.github.io/pixtudio-website/docs/pathfind_flags/","title":""},{"contents":" Definition INT pause_song ( )\nPauses the currently playing song.\nNotes The song pauses immediately, but can be resumed later by calling resume_song(). For a nicer effect, you may want to fade the music out before pausing. See fade_music_off().\nReturns INT : Error.\n-1 - Error: sound inactive. 0 - No error.\nExample program music_example; global my_song; playing; paused; faded_in; v; begin set_mode(640,480,16); my_song=load_song(\u0026quot;beat.ogg\u0026quot;); write(0,320,30,4,\u0026quot;Use the keyboard to control the music playback.\u0026quot;); write(0,320,50,4,\u0026quot;Key [ENTER] starts / stops the song.\u0026quot;); write(0,320,60,4,\u0026quot;Key [SPACE] pauses / resumes the song.\u0026quot;); write(0,320,70,4,\u0026quot;Key [0] through key [9] changes the song volume.\u0026quot;); write(0,320,80,4,\u0026quot;Key [F] fades the song in or out.\u0026quot;); write(0,320,120,5,\u0026quot;Playing: \u0026quot;); write_int(0,320,120,3,\u0026amp;playing); write(0,320,140,5,\u0026quot;Paused: \u0026quot;); write_int(0,320,140,3,\u0026amp;paused); write(0,320,160,5,\u0026quot;Faded in: \u0026quot;); write_int(0,320,160,3,\u0026amp;faded_in); write(0,320,180,5,\u0026quot;Volume: \u0026quot;); write_int(0,320,180,3,\u0026amp;v); v=128; faded_in=true; repeat if(key(_enter)) if(is_playing_song()) stop_song(); playing=false; else play_song(my_song,1); playing=true; end while(key(_enter))frame;end end if(key(_space)) if(paused) paused=false; resume_song(); else paused=true; pause_song(); end while(key(_space))frame;end end if(key(_f)) if(faded_in) faded_in=false; fade_music_off(100); else faded_in=true; fade_music_in(my_song,1,100); end while(key(_f))frame;end end if(key(_0))v=0;end if(key(_1))v=14;end if(key(_2))v=28;end if(key(_3))v=43;end if(key(_4))v=57;end if(key(_5))v=71;end if(key(_6))v=85;end if(key(_7))v=100;end if(key(_8))v=114;end if(key(_9))v=128;end set_song_volume(v); frame; until(key(_esc)) exit(); end  Used in example: key(), set_mode(), load_song(), write(), write_int(), pause_song(), play_song(), stop_song(), resume_song(), fade_music_in(), fade_music_off(), set_song_volume().\nCategory:functions Category:sound Category:mod_sound\n","permalink":"https://divhub.github.io/pixtudio-website/docs/pause_song/","title":""},{"contents":" Definition INT pause_wav (INT \u0026lt; channel \u0026gt; )\nPauses the currently playing wave channel.\nNotes The sound channel pauses immediately, but can be resumed later by calling resume_wav(). For a nicer effect, you may want to fade the music out before pausing. See set_channel_volume().\nParameters INT channel - The WAV sound channel.\nReturns INT : Error.\n-1 - Error: sound channel inactive. 0 - No error.\nExample // import modules IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_proc\u0026quot;; IMPORT \u0026quot;mod_key\u0026quot;; IMPORT \u0026quot;mod_sound\u0026quot;; GLOBAL int wav; int channel; PROCESS main(); BEGIN wav=load_wav(\u0026quot;wav.wav\u0026quot;); say(\u0026quot;Test pause_wav...\u0026quot;); say(\u0026quot;ENTER = Pause Sound...\u0026quot;); say(\u0026quot;Press ESC to quit...\u0026quot;); channel=play_wav(wav,-1); REPEAT IF(key(_enter)) pause_wav(channel); FRAME(2500); resume_wav(channel); END FRAME; UNTIL(key(_esc)) END  Used in example: key(), say(), resume_wav(), play_wav(), load_wav().\nCategory:functions Category:sound Category:mod_sound\n","permalink":"https://divhub.github.io/pixtudio-website/docs/pause_wav/","title":""},{"contents":" Definition INT pcx_load ( \u0026lt;STRING filename\u0026gt;, [ \u0026lt;POINTER id\u0026gt;] )\nCreates a new graphic, using the specified pcx file as contents and puts it in the system file. Returns the graphID of the created graphic. The color depth of the created graphic will be the same as the loaded pcx file.\nThe previous name load_pcx() is deprecated.\nParameters STRING filename - The name of the pcx file to be loaded, including a possible path. POINTER id - Optional parameter, for loading a map in the background.\nReturns INT : graphID\n-2 - Waiting for the file to be loaded, see notes. -1 - There was an error loading the file. \u0026gt;=0 - The graphID of the newly created graphic.\nthe following applies for versions prior rc282:\nINT : graphID\n0 - There was an error loading the file. \u0026gt;0 - The graphID of the newly created graphic.\nNotes The optional parameter id was introduced in version rc282 and allows you to load resources in the background. It used with the Offset operator. See example below:\n load_pcx(\u0026quot;archivo_gordo.pcx\u0026quot;, \u0026amp;idpcx); while(idpcx==-2) say(\u0026quot;Big File Loading ....\u0026quot;); frame; end if(idpcx==-1) say(\u0026quot;Something went wrong!!\u0026quot;); exit(); // o return end say(\u0026quot;Big file loaded ok!!\u0026quot;);  Category:functions Category:maps Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/pcx_load/","title":""},{"contents":" Definition INT PI == 180000\nThe equivalent to the mathematical pi (3.14159265\u0026hellip;), in thousandths of a degree. It can be used to define angles, like assigning one to the local variable angle, or passing one to the function xadvance().\nExample angle = PI/2; // 90000 (90 degrees) xadvance(-PI/4,10); // -45000 (-45 degrees)  Category:constants Category:math Category:mod_math\n","permalink":"https://divhub.github.io/pixtudio-website/docs/pi/","title":""},{"contents":"A Pixel is the smallest unit that can be addressed on the screen. On Windows and Linux, a custom screen resolutions is 1024x768 pixels. This means, the entire screen is created from 1024 columns and 768 rows, summing up to 786432 single pixels.\nPixel 0,0 would be in the top left corner, Pixel 512,382 would be one of the four pixels in the center of the screen and Pixel 1023,767 would be the bottom right.\nOn a 15\u0026rdquo; Monitor, a single pixel would measure about 0.3 millimeters on the screen.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/pixel/","title":""},{"contents":" Definition INT play_song ( \u0026lt;INT songID\u0026gt; , \u0026lt;INT repeats\u0026gt; )\nPlays a song.\nParameters INT songID - SongID of the song loaded previously with load_song(). INT repeats - Number of times to repeat the song. Use -1 for an infinite loop.\nReturns INT : Error.\n-1 - Error: sound inactive; mixer error; invalid songID. 0 - No error.\nErrors Sound inactive - The sound is inactive. Invalid songID - The songID was invalid. Other - Some Mixer error.\nExample Program example; Private int song; Begin song = load_song(\u0026quot;my_song.ogg\u0026quot;); play_song(song,0); Loop frame; End End  Used in example: load_song()\nCategory:functions Category:sound Category:mod_sound\n","permalink":"https://divhub.github.io/pixtudio-website/docs/play_song/","title":""},{"contents":" Definition INT play_wav ( \u0026lt;INT waveID\u0026gt; , \u0026lt;INT repeats\u0026gt; , [\u0026lt;INT channel\u0026gt;] )\nPlays a sound effect previously loaded with load_wav().\nParameters INT waveID - The WaveID of the sound effect to be played. INT repeats - Number of times to repeat the sound effect. Use -1 for an infinite loop. [INT channel] - The sound channel the sound effect is to be played on (-1 for any, default).\nReturns INT : The sound channel the sound effect is now playing on.\n-1 - Error: sound inactive; invalid waveID \u0026gt;=0 - The sound channel the sound effect is now playing on.\nExample Program Private int wave; Begin wave = load_wav(\u0026quot;my_wav.wav\u0026quot;); play_wav(wave,0); Loop frame; End End  Used in example: load_wav()\nCategory:functions Category:sound Category:mod_sound\n","permalink":"https://divhub.github.io/pixtudio-website/docs/play_wav/","title":""},{"contents":" Definition Portable Network Graphics. A filetype to hold an image with lossless compression.\nSee also  png_load() png_save()  Category:filetypes\n","permalink":"https://divhub.github.io/pixtudio-website/docs/png/","title":""},{"contents":" Definition INT png_load ( \u0026lt;STRING filename\u0026gt;, [ \u0026lt;POINTER id\u0026gt;] )\nCreates a new graphic, using the specified PNG file as contents and puts it in the system file. Returns the graphID of the created graphic. The color depth of the created graphic will be the same as the loaded PNG file.\nThe previous name load_png() is deprecated.\nParameters STRING filename - The name of the PNG file to be loaded, including a possible path. POINTER id - Optional parameter, for loading a map in the background.\nReturns INT : graphID\n-2 - Waiting for the file to be loaded, see notes. -1 - There was an error loading the file. \u0026gt;=0 - The graphID of the newly created graphic.\nthe following applies for versions prior rc282:\nINT : graphID\n0 - There was an error loading the file. \u0026gt;0 - The graphID of the newly created graphic.\nNotes The optional parameter id was introduced in version rc282 and allows you to load resources in the background. It used with the Offset operator. See example below:\n load_png(\u0026quot;archivo_gordo.png\u0026quot;, \u0026amp;idpng); while(idpng==-2) say(\u0026quot;Big File Loading ....\u0026quot;); frame; end if(idpng==-1) say(\u0026quot;Something went wrong!!\u0026quot;); exit(); // o return end say(\u0026quot;Big file loaded ok!!\u0026quot;);  Example Checkout the PNG_LoadDirectory tutorial.\nCategory:functions Category:maps Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/png_load/","title":""},{"contents":" Definition INT png_save ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; , \u0026lt;STRING filename\u0026gt; )\nSaves the specified graphic as filename with the format PNG.\nThe previous name save_png() is deprecated.\nParameters INT fileID - The fileID of the file that holds the graphic. INT graphID - The graphID of the graphic to save. STRING filename - The name of the PNG file to be saved, including a possible path.\nReturns INT : Successrate\nfalse - Error. true - Success.\nExample //here's a cool thing to save a screenshot import \u0026quot;mod_map\u0026quot; import \u0026quot;mod_screen\u0026quot; import \u0026quot;mod_key\u0026quot; Global int takingscreenshot; End Process Main() Begin Loop If (key(_F12)) If (takingscreenshot==0) takingscreenshot=1; graph=screen_get(); // grabs the screen and sets it as the program graphic png_save(0,graph,\u0026quot;shot\u0026quot;+rand(0,9999)+\u0026quot;.png\u0026quot;); // saves the graphic as a png with a // random number in the filename to // prevent overwriting map_unload(0,graph); //frees the graphic Else takingscreenshot=0; End While(key(_F12)) Frame; End End frame; End End  Used in example: key(), screen_get(), png_save(), map_unload()\nCategory:functions Category:maps Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/png_save/","title":""},{"contents":" Definition INT get_point ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; , \u0026lt;INT controlpointID\u0026gt; , \u0026lt;INT POINTER x\u0026gt;, \u0026lt;INT POINTER y\u0026gt;)\nAllows you to obtain a control point of a particular graph.\nAny graph can contain up to 1000 control points (from 0 to 999). Control point 0 is the center of the graphic. This function allows you to know the location of any control point belonging to any graph.\nTo set a control point, use set_point() or, for only the center of a graph, set_center().\nThe previous name get_point() is deprecated.\nParameters INT fileID - Number of the FPG library. INT graphID - Number of the graph inside the library which you want to use. INT controlpointID - Number of the control point. INT POINTER x - Pointer to where the X-coordinate of the control point will be written. INT POINTER y - Pointer to where the Y-coordinate of the control point will be written.\nReturns INT : Successrate\nfalse - One of the following: specified graph is invalid, specified control point is invalid, specified control point is undefined. true - The control point was defined or the center was used.\nExample Program cpoint; Private int map; int cx,cy; Begin // Create a red graph map = new_map(100,100,8); map_clear(0,map,rgb(255,0,0)); // Set the center to a random point set_center(0,map,rand(-10,110),rand(-10,110)); // Get the center get_point(0,map,0,\u0026amp;cx,\u0026amp;cy); // Show the center say(\u0026quot;Center-X: \u0026quot; + cx); say(\u0026quot;Center-Y: \u0026quot; + cy); // Assign the map to the graph variable graph = map; // Set the location of this process to the center of the screen x = 160; y = 100; Loop frame; End End  Used in example: new_map(), map_clear(), set_center(), say(), pointer, graph\nNotice that setting the center influences the position of the graph:\nCategory:functions Category:maps Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/point_get/","title":""},{"contents":" Definition INT point_set ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; , \u0026lt;INT controlpointID\u0026gt; , \u0026lt;INT x\u0026gt;, \u0026lt;INT y\u0026gt;)\nAllows you to set a control point of a particular graphic.\nAny graph can contain up to 1000 control points (from 0 to 999). Control point 0 is the center of the graphic. This function allows you to set the location of any control point belonging to any graph. The coordinates are relative to the upper left corner of the graphic.\nTo obtain the coordinates of a control point, use point_get().\nThe previous name set_point() is deprecated.\nParameters INT fileID - FileID of the file containing the graphic. INT graphID - GraphID of the graphic of which to set a control point. INT controlpointID - Number of the control point. INT x - The new X-coordinate of the control point. INT y - The new Y-coordinate of the control point.\nReturns INT : Successrate\n-1 - One of the following: specified graph is invalid, specified control point is invalid. 1 - The control point was set successfully.\nExample import \u0026quot;mod_map\u0026quot; import \u0026quot;mod_say\u0026quot; import \u0026quot;mod_wm\u0026quot; import \u0026quot;mod_key\u0026quot; import \u0026quot;mod_grproc\u0026quot; Process Main() Private int map; int cx,cy; Begin // Create a red graph map = new_map(100,100,8); map_clear(0,map,rgb(255,0,0)); // Set the center to a random point point_set(0,map,0,rand(-10,110),rand(-10,110)); // Get the center point_get(0,map,0,\u0026amp;cx,\u0026amp;cy); // Show the center say(\u0026quot;Center-X: \u0026quot; + cx); say(\u0026quot;Center-Y: \u0026quot; + cy); // Assign the map to the graph variable graph = map; // Set the location of this process to the center of the screen x = 160; y = 100; Repeat frame; Until(exit_status||key(_ESC)) End  Used in example: new_map(), map_clear(), point_set(), point_get(), say(), pointer, graph\nNotice that setting the center influences the position of the graph:\nCategory:functions Category:maps Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/point_set/","title":""},{"contents":" Syntax Declaration of a pointer:\n{datatype} POINTER {pointername};  Assignment of a value to the location pointed to:\nPOINTER {pointername} = {value};  Concept Pointers, are used to point to a location in memory. It uses 32 bits (4 bytes) so it can map 4GB of memory into bytes. Pointers can point to any datatype: ints, shorts, strings or even usermade datatypes.\nHowever, using a struct pointer my_pointer is pointless, because the compiler has no knowledge of the elements inside the struct pointing to, since it doesn\u0026rsquo;t know which struct is meant, so this is invalid. MyStruct pointer my_pointer, where MyStruct is an existing struct, is also not valid, because MyStruct is not a datatype. The only way to have something like a struct pointer my_pointer is to use Type as seen in the example.\nExample  import \u0026quot;mod_say\u0026quot; Type _point int x; int y; End Type _person string name; int age; End Global _person Person; End Process Main() Private int my_int; int* my_int_pointer; _point myPoint; _person* personPointer; // possible, because _person is infact a datatype //Person* personPointer; // not possible, because Person is not a datatype Begin my_int_pointer = \u0026amp;my_int; my_int = 3; say(my_int); say(*my_int_pointer); *my_int_pointer = 4; say(my_int); say(*my_int_pointer); setXY(\u0026amp;myPoint); say(myPoint.x); say(myPoint.y); personPointer = \u0026amp;Person; personPointer.name = \u0026quot;Mies\u0026quot;; say(Person.name); say(personPointer.name); End Function int setXY(_point* p) Begin p.x = 3; // this is actually (*p).x = 3, but . can be used like this p.y = 5; // this is actually (*p).y = 5, but . can be used like this return 0; End  Used in example: say(), key(), Type, Global, Private, point\nThe \u0026amp; (offset) operator, when used with pointers, returns a void pointer to a variable. In the example it returns an int pointer to the variable my_int. The * (pointer) operator, when used with pointers, makes it so the pointer variable is not accessed, but the variable it\u0026rsquo;s pointing to. In the example it changes access from my_int_pointer to my_int.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/pointer/","title":""},{"contents":" This is a general guide for getting your Bennu game onto your chosen system. At the time of writing this stable ports and porting processes exist for these OS or platforms:\n Windows Linux OS X (Intel) Android iOS  Starting Out Instructions on compiling PixTudio here\n","permalink":"https://divhub.github.io/pixtudio-website/docs/porting/","title":""},{"contents":" Definition FLOAT pow ( \u0026lt;FLOAT base\u0026gt; , \u0026lt;FLOAT power\u0026gt; )\nReturns base to the power of power (base\\^power).\nParameters FLOAT base - The base. FLOAT power - The power.\nReturns FLOAT : base to the power of power (base\\^power).\nExample Program powerful; Global float value1; int value2; Begin write_float(0,0, 0,0,\u0026amp;value1); write_int (0,0,10,0,\u0026amp;value2); value1 = pow(2.3,4.6); value2 = pow(2 ,3 ); Repeat frame; Until(key(_ESC)) End  Used in example: write_float(), write_int(), pow(), key()\nCategory:functions Category:math Category:mod_math\n","permalink":"https://divhub.github.io/pixtudio-website/docs/pow/","title":""},{"contents":" category:general category:precompiler\nDefinition The precompiler is for executing commands before the actual compiling. This can be useful for many things:\n Defining words as other words or values Defining functions as a list of statements Protecting codefiles from being included multiple times Enable whole sections of code with one define  See the examples for more.\nA list of precompiler statements:\n #define #ifdef #ifndef #endif #else #if  ","permalink":"https://divhub.github.io/pixtudio-website/docs/precompiler/","title":""},{"contents":" category:precompiler\nDefinition #define []\nDefines what to define as what it will be. This means that after this line, all *what to define*s will be \u0026ldquo;replaced\u0026rdquo; by what it will be.\nYou can also create \u0026ldquo;functions\u0026rdquo; with this, even with parameters. The call to this \u0026ldquo;function\u0026rdquo;, including parameters, will be replaced by the what it will be section, with the parameters replaced by the arguments.\nExample Basic statements In the following example, we\u0026rsquo;ll show it is possible to define words as \u0026ldquo;being\u0026rdquo; basic statements.\n#define StartThisShow Program #define GimmeSomeShit Process StartThisShow example; Begin proc(); End GimmeSomeShit proc() Begin End  Used in example: Program, Process, Begin, End\nError codes Error codes are handy as well, like used in Network.DLL and LCD.DLL:\n#define NET_ERROR_INVALIDADDRESS -12  This will enable the use of NET_ERROR_INVALIDADDRESS as it it were the value -12. This makes it much more clear for the programmer what the errors are. Consider this:\n#define NET_STATUS_ESTABLISHED 2  The value 2 on itself means very little, but NET_STATUS_ESTABLISHED immediately makes it clear what it means.\nFunction In the following we define a function kill(,).\n#define kill(a,b) if(exists(a)) signal(a,s_kill); say(\u0026quot;Killed '\u0026quot; + a + \u0026quot;' for reason: \u0026quot; + b); end Program example; Private int i; Begin i = proc(); kill(i,\u0026quot;It had to be killed!\u0026quot;); // The ';' is not needed per se, but is allowed. Repeat frame; Until(key(_ESC)) End Process proc() Begin Loop frame; End End  Used in example: Program, Process, Begin, End, If, Repeat, Until, frame, signal(), say(), key()\n","permalink":"https://divhub.github.io/pixtudio-website/docs/precompiler_define/","title":""},{"contents":" category:precompiler\nDefinition #else\n#else is used in the following precompiler statements:\n #ifdef #ifndef #if  ","permalink":"https://divhub.github.io/pixtudio-website/docs/precompiler_else/","title":""},{"contents":" category:precompiler\nDefinition #endif\n#endif is used to end the following precompiler statements:\n #ifdef #ifndef #if  ","permalink":"https://divhub.github.io/pixtudio-website/docs/precompiler_endif/","title":""},{"contents":" category:precompiler\nDefinition  #if   [\u0026rdquo;\u0026rsquo;#else ]\n  #endif\nChecks if what to check is true. If it is, the code in if block will be compiled. If it isn\u0026rsquo;t, the code in else block will be compiled or when there is no else block, the compiler will continue after #endif.\nExample Consider a define to set the framepercentage in a certain process. Now for some reason you might want to just have a frame; compiled when that define is set to 100.\nLoop #ifdef FRAMEPERC #if FRAMEPERC == 100 frame; #else frame(FRAMEPERC); #endif #else frame; #endif End  Used in example: Loop, End, frame, #if, #else, #endif\n","permalink":"https://divhub.github.io/pixtudio-website/docs/precompiler_if/","title":""},{"contents":" category:precompiler\nDefinition  #ifdef   [\u0026rdquo;\u0026rsquo;#else ]\n  #endif\nChecks if what to check was previously defined in the code. If it is, the code in if block will be compiled. If it isn\u0026rsquo;t, the code in else block will be compiled or when there is no else block, the compiler will continue after #endif.\nExample Here we will be able to choose whether to support a certain function with the precompiler:\n#ifdef SOMEFUNCTIONALITY Function int SomeFunction() Begin return 0; End #endif  Used in example: Function, Begin, End, #endif\nConsider a define to set the framepercentage in a certain process. Now for some reason you might want to just have a frame; compiled when that define is set to 100.\nLoop #ifdef FRAMEPERC #if FRAMEPERC == 100 frame; #else frame(FRAMEPERC); #endif #else frame; #endif End  Used in example: Loop, End, frame, #if, #else, #endif\n","permalink":"https://divhub.github.io/pixtudio-website/docs/precompiler_ifdef/","title":""},{"contents":" category:precompiler\nDefinition  #ifndef   [\u0026rdquo;\u0026rsquo;#else ]\n  #endif\nChecks if what to check was previously defined in the code. If it isn\u0026rsquo;t, the code in if block will be compiled. If it is, the code in else block will be compiled or when there is no else block, the compiler will continue after #endif.\nIt is the opposite of #ifdef.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/precompiler_ifndef/","title":""},{"contents":" Definition Predefined graphcodes can be used as GraphID\u0026rsquo;s in some cases.\nFunctions using graphics is the most common case.\nList Constant - Value - Description BACKGROUND - 0 - The graphic of the background (local variable graph of a process won\u0026rsquo;t work with this). SCREEN - -1 - The graphic of the screen (its center is (0,0)).\nCategory:constantcategories\n","permalink":"https://divhub.github.io/pixtudio-website/docs/predefined_graphcodes/","title":""},{"contents":" Definition Bennu program file, containing main code.\nCategory:filetypes\n","permalink":"https://divhub.github.io/pixtudio-website/docs/prg/","title":""},{"contents":" category:variables category:predefined category:local variables category:internal\nUp to Local Variables\nDefinition INT priority = 0\npriority is a predefined local variable, holding the priority of the process; default is 0.\nUsing this priority, the order of process-execution can be influenced, because processes with a higher priority are executed before processes with a lower priority.\nExample import \u0026quot;mod_say\u0026quot; import \u0026quot;mod_proc\u0026quot; import \u0026quot;mod_timers\u0026quot; Process A() Begin priority = 0; // Default Loop say(\u0026quot;[\u0026quot; + timer[0] + \u0026quot;] \u0026quot; + \u0026quot;A\u0026quot;); frame(100000000); // This is very high because Bennu runs without limiter here End End Process main() Private int f=0; Begin priority = 1; // Set to higher priority than A A(); Repeat f++; say(\u0026quot;[\u0026quot; + timer[0] + \u0026quot;] \u0026quot; + \u0026quot;Main\u0026quot;); frame(100000000); // This is very high because Bennu runs without limiter here Until(f==5) OnExit let_me_alone(); End  Used in example: say(), let_me_alone(), timer, priority, frame\nPossible output:\n[0] A [0] Main [26] Main [26] A [50] Main [50] A [74] Main [74] A [98] Main [98] A  It can be seen here that regardless of priority, A is first executed, because A is called by Main. As soon as A reaches its frame statement, Main continues until its frame statement and this concludes the first frame. The second frame it is shown that the priority has effect: Main is executed before A.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/priority/","title":""},{"contents":" Syntax Private {private variables} End  Description Private is a reserved word used to initiate the declaration of private variables. Terminating the declaration block with an End is not necessary, but is possible. Parameters of a function or process will be considered a private variable with the initiated value of the passed argument.\nExample  Process My_Process(); Public Private // Declare private variables here Begin End  ","permalink":"https://divhub.github.io/pixtudio-website/docs/private/","title":""},{"contents":" category:variablecategories category:general\nDefinition A private variable is a variable that is specific to a process or function. Unlike a public variable, it can only be accessed from the process or function it was declared for.\nTo start the declaration of private variables, use Private.\nExample Function int SomeFunction() Private int i,j; // declare private ints i and j String strtemp; // declare private string strtemp Begin // ... return 0; End  Used in example: Function, Private, Begin, End\nThe private variables i and j could be variables used for counting and the string probably would have some use as well.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/private_variable/","title":""},{"contents":" Syntax Process \u0026lt;name\u0026gt; ( [ \u0026lt;parameters\u0026gt; ] ) [ Public [ \u0026lt;public variables\u0026gt; ] ] [ Private [ \u0026lt;private variables\u0026gt; ] ] Begin [ \u0026lt;main code\u0026gt; ] [OnExit [ \u0026lt;OnExit code\u0026gt; ] ] End  Description Process is a reserved word used to start the code of a process. If name is Main, that process will be started at the start of the program.\nA process is a subroutine to which one or more of the following apply:\n it receives parameters it acts on the parameters it processes data located elsewhere  In addition to these possibilities, a process always has a frame; statement. The difference between a function and a process is a process is treated as a separate thread. This means one can\u0026rsquo;t let a process return a value like a function, as the father process continues its code as well, as soon as the process hits a frame; statement or when the code is done. When that happens, the process \u0026lsquo;returns\u0026rsquo; its ProcessID and continues the code (in the next frame).\nWhen the frame; statement is reached in the code, a number of other local variables are defined or updated not only of the new process, but also of related processes. These are:\n The father variable of the new process. The son variable of the father process (updated). The bigbro variable of the new process. The smallbro variable of the processes called by the father immediately before the new process was called (updated). The son and smallbro variables are also defined of the new process, but do not yet carry values.  When there are no more processes alive, the program ends.\nLocal variables as parameters When a process is declared with parameters that are actually local variables, arguments for these parameters will initialise those local variables. This may sound strange, but an example will clear things up.\nFor example, consider the local variables x, y, z, file and graph. To create a process to move a game sprite around, you can declare it as follows:\nprocess Ship (x,y,z,file,graph) begin // move left 1 pixel per frame repeat x -= 1; // move 1 pixel to the left frame; // this process is done for this frame, wait for the next until (x\u0026lt;0); end  Calling the process with e.g. Ship(300,100,5,0,1); will have the Ship appear at the coordinates (300,100) on Z-Level 5 with the Sprite No.1 in the file number 0. The ship will move left until it leaves the screen. You can change movement by changing the x/y value of the process and animate the ship by changing the graph value.\nExample Process SpaceShip( int x, int y, int angle, int maxspeed, int maxturnspeed) Public // Declare public variables here Private // Declare private variables here int speed; Begin // Start the main processcode graph = new_map(20,20,8); map_clear(0,graph,rgb(0,255,255)); Loop speed+=key(_up)*(speed\u0026lt;maxspeed)-key(_down)*(speed\u0026gt;-maxspeed); angle+=(key(_left)-key(_right))*maxturnspeed; advance(speed); frame; End OnExit // Start the exit code unload_map(0,graph); End // End the main processcode  Now one can call this process for example by doing the following.\nProcess Main() Begin SpaceShip(100, 100, 0, 20, 5000); Repeat frame; Until(key(_ESC)) let_me_alone(); End  And when the SpaceShip process ends -because the code reaches the End or some other process sent an s_kill signal- the OnExit code starts.\nIn this example it will unload the memory used for the created graphic. If there is no OnExit code, the process will just end without performing any special action.\nThis will make a SpaceShip with a cyan coloured block, able to move around the screen.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/process/","title":""},{"contents":" Definition Process statuscodes are status codes used for the local variable Reserved.status, to specify the current status of a process.\nList Constant - Value - Description STATUS_DEAD - 0 - The process is dead. STATUS_KILLED - 1 - The process is killed. STATUS_RUNNING - 2 - The process is running. STATUS_SLEEPING - 3 - The process is sleeping. STATUS_FROZEN - 4 - The process is frozen. STATUS_WAITING - 7 - The process is waiting.\nCategory:constantcategories\n","permalink":"https://divhub.github.io/pixtudio-website/docs/process_statuscodes/","title":""},{"contents":" Definition A ProcessTypeID is a unique identification code, for a processType. A ProcessTypeID is smaller than 65536 (2\\^16).\nExample Kill all SpaceShip()s (see process):\nBegin signal(type SpaceShip,s_kill); End  signal() signals all processes of processType SpaceShip the signal to die. This is done by using the constant s_kill as the signal.\nCategory:general\n","permalink":"https://divhub.github.io/pixtudio-website/docs/processtypeid/","title":""},{"contents":" Syntax Program {programname};  Description Program is a reserved word used to begin your program. It\u0026rsquo;s not needed to start a program with it.\nIt should be noted that this is for backwards compatibility only, because it doesn\u0026rsquo;t actually do anything.\nExample  Program example; // Name this program \u0026quot;example\u0026quot;, which doesn't really matter Process Main() // This process is started when the program is started Begin End  When the End of the main code is reached, the program exits, if there are no processes alive anymore, which is logical, as PixTudio quits when there are no processes running and Main is a process as well. This process is just like any other process with the addition it gets called when the program starts. This means that you can also call the process using main().\n","permalink":"https://divhub.github.io/pixtudio-website/docs/program/","title":""},{"contents":" Syntax Public {public variables} End  Description Public is a reserved word used to initiate the declaration of public variables. Terminating the declaration block with an End is not necessary, but is possible.\nExample  Process My_Process(); Public // Declare public variables here Private Begin End  ","permalink":"https://divhub.github.io/pixtudio-website/docs/public/","title":""},{"contents":" category:variablecategories category:general\nDefinition A public variable is a variable that is specific to a process or function in the same way as a private variable. Unlike a private variable, however, a public variable can be accessed from the rest of the program, by use of the ProcessID of that process. This ProcessID must be stored in a variable of type ProcessName. It is like a local variable, but just for one ProcessType instead of for all.\nBecause of the way the compiler works, public variables are only accessible for processes and functions below the declaration (which in fact is pretty normal). To assist in this matter, the statement Declare was created.\nTo start the declaration of public variables, use Public.\nExample import \u0026quot;mod_say\u0026quot; import \u0026quot;mod_proc\u0026quot; Declare Process SpaceShip() Public int speed = 50; String name = \u0026quot;Galactica\u0026quot;; End End Global SpaceShip ship; End Process Main() Begin ship = SpaceShip(); say(ship.name + \u0026quot;: \u0026quot; + ship.speed); signal(ship,S_KILL); End Process SpaceShip() Begin Loop frame; End End  Used in example: say(), key(), signal(), Program, Declare, Public, Global, Begin, Repeat, Loop, frame\nThis is for example when a ship is needed, of which the speed and name want to be accessible from the rest of the program. This way, one can easily have multiple instances of the same ProcessType, but still have the appropriate variables easily accessible.\nNotice the use of Declare. If we wouldn\u0026rsquo;t use it, we could just move the process SpaceShip above the main process. This will have the same result.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/public_variable/","title":""},{"contents":" Definition INT put ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; , \u0026lt;INT x\u0026gt; , \u0026lt;INT y\u0026gt; )\nDraws (blits) a graph onto the background.\nFor more advanced blitting, see:\n xput() map_put() map_xput() map_xputnp()  Parameters INT fileID - The file that holds the graph. INT graphID - The graph to draw with. INT x - Where on the background\u0026rsquo;s x-axis to put the graph. INT y - Where on the background\u0026rsquo;s y-axis to put the graph.\nReturns INT : true\nNotes The x and y parameters denote where to draw the graph, that is, where the center of the to be drawn graph will be.\nErrors Unsupported color depth - The origin graph\u0026rsquo;s color depth is greater than the destination graph\u0026rsquo;s.\nExample import \u0026quot;mod_map\u0026quot; import \u0026quot;mod_screen\u0026quot; import \u0026quot;mod_key\u0026quot; Process Main() Private int map; Begin // Create a new graph of size 100x100 and color depth of 8bit map = map_new(100,100,8); // Clear the map red map_clear(0,map,rgb(255,0,0)); // Put it in the center of the screen put(0,map,160,100); Repeat frame; Until(key(_ESC)) End  Used in example: map_new(), map_clear(), put(), key()\nThis will result in something like:\nCategory:functions Category:screen Category:mod_screen\n","permalink":"https://divhub.github.io/pixtudio-website/docs/put/","title":""},{"contents":" Definition INT put_pixel ( \u0026lt;INT x\u0026gt; , \u0026lt;INT y\u0026gt; , \u0026lt;INT color\u0026gt; )\nDraws a single colored pixel on the background. Is equivalent to map_put_pixel ( 0, 0, x, y, color ).\nParameters INT x - Where on the background\u0026rsquo;s x-axis to put the pixel. INT y - Where on the background\u0026rsquo;s y-axis to put the pixel. INT color - What color to draw.\nReturns INT : true\nExample import \u0026quot;mod_video\u0026quot; import \u0026quot;mod_map\u0026quot; import \u0026quot;mod_wm\u0026quot; import \u0026quot;mod_draw\u0026quot; import \u0026quot;mod_rand\u0026quot;; Process Main() Private int i; int direction; end Begin // Set the mode to 16bit and some res set_mode(320,200,16); // Create a blue-ish square map graph = new_map(20,20,16); map_clear(0,graph,rgb(50,100,150)); y=100; x=10; // Puts 100 yellow-ish pixels in random places in the background for(i=0; i\u0026lt;100; i++) put_pixel(rand(0,320),rand(0,200),rgb(255,255,55)); end Repeat x=x+direction; if (x\u0026gt;=310) direction=-3; end if (x\u0026lt;=10) direction=3; end frame; Until(exit_status) End  Used in example: set_mode(), new_map(), map_clear(), rand(), put_pixel()\nCategory:functions Category:maps Category:mod_draw Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/put_pixel/","title":""},{"contents":" Definition INT quicksort ( \u0026lt;VOID POINTER array\u0026gt; , \u0026lt;INT elementsize\u0026gt; , \u0026lt;INT elements\u0026gt; , \u0026lt;INT dataoffset\u0026gt; , \u0026lt;BYTE datasize\u0026gt; , \u0026lt;BYTE datatype\u0026gt; )\nSorts an array by the Quicksort ordering algorithm.\nThis function is very handy for user defined types for elements in which a sort-variable is present. For simple arrays or arrays in which the first variable is the sort-variable, sort() can be used. For arrays in which the sort-variable is a String, ksort() can be used.\nParameters VOID POINTER array - Pointer to the first element of the array to be sorted. INT elementsize - The size of an element in the array in bytes. INT elements - The number of elements in the array. INT dataoffset - The number of bytes the sort-variable in each element is relative to the start of that element. BYTE datasize - The size of the sort-variable in bytes. BYTE datatype - The datatype of the sort-variable. (0:integer, 1:float)\nReturns INT: true\nExample Program sorting; Type _player String name; int score; End Const maxplayers = 5; Global _player player[maxplayers-1]; Begin // Insert some values player[0].name = \u0026quot;That one bad looking dude\u0026quot;; player[1].name = \u0026quot;Ah pretty lame guy\u0026quot;; player[2].name = \u0026quot;Some cool dude\u0026quot;; player[3].name = \u0026quot;OMG ZOMG guy\u0026quot;; player[4].name = \u0026quot;This person is ok\u0026quot;; player[0].score = 70; player[1].score = 30; player[2].score = 80; player[3].score = 90; player[4].score = 50; // Show array say(\u0026quot;-------------------- unsorted\u0026quot;); for(x=0; x\u0026lt;maxplayers; x++) say(player[x].name + \u0026quot; - \u0026quot; + player[x].score); end /* Sort by name ( quicksort() can't be used to sort Strings, as a String in Fenix is a pointer to the actual String, so it would sort the pointer addresses */ // sort() sort(player); // sorts by name because name is the first variable in each element // Show array say(\u0026quot;-------------------- name - sort()\u0026quot;); for(x=0; x\u0026lt;maxplayers; x++) say(player[x].name + \u0026quot; - \u0026quot; + player[x].score); end // ksort() ksort(player,player[0].name,maxplayers); // Show array say(\u0026quot;-------------------- name - ksort()\u0026quot;); for(x=0; x\u0026lt;maxplayers; x++) say(player[x].name + \u0026quot; - \u0026quot; + player[x].score); end /* Sort by score (sort() cannot be used here, because score is not the first variable) */ // ksort() ksort(player,player[0].score,maxplayers); // Show array say(\u0026quot;-------------------- score - ksort()\u0026quot;); for(x=0; x\u0026lt;maxplayers; x++) say(player[x].name + \u0026quot; - \u0026quot; + player[x].score); end // quicksort() quicksort(\u0026amp;player[0],sizeof(_player),maxplayers,sizeof(String),sizeof(int),0); // Show array say(\u0026quot;-------------------- score - quicksort()\u0026quot;); for(x=0; x\u0026lt;maxplayers; x++) say(player[x].name + \u0026quot; - \u0026quot; + player[x].score); end // Wait until ESC is pressed Repeat frame; Until(key(_esc)) End  Used in example: say(), sort(), ksort(), quicksort(), type, array, pointer\nCategory:functions Category:sorting Category:mod_sort\n","permalink":"https://divhub.github.io/pixtudio-website/docs/quicksort/","title":""},{"contents":" Definition INT rand ( \u0026lt;INT lowerlimit\u0026gt; , \u0026lt;INT upperlimit\u0026gt; )\nReturns a random number, ranging from a certain lower limit to a certain upper limit. The limits are within the range.\nMake sure the difference between lowerlimit and upperlimit does not exceed 32767 (2\\^15-1). If that is needed, the function rand2() below can be used.\nParameters INT lowerlimit - The lower limit for the random value. INT upperlimit - The upper limit for the random value.\nReturns INT : A random value: lowerlimit \u0026lt;= result \u0026lt;= upperlimit\nNotes To synchronize rand() on different computers, the function rand_seed() can be used.\nRand() is not a very good function on itself. To counter this, the following rand2() can be used:\n#define RAND_MAX 32767 #define DRAND_RANGE (1.0/((RAND_MAX + 1)*(RAND_MAX + 1))) #define irand(x) ((unsigned int) ((x) * drand ())) Function float drand () Private float f; Begin Repeat f = (rand (0,RAND_MAX) * (RAND_MAX + 1.0) + rand (0,RAND_MAX)) * DRAND_RANGE; Until (f \u0026lt; 1); /* Round off */ return f; End Function int rand2(int lowerlimit, int upperlimit) Begin return (lowerlimit+irand(upperlimit-lowerlimit+1)); End  To understand this code, one can read its source.\nCategory:functions Category:math Category:mod_rand\n","permalink":"https://divhub.github.io/pixtudio-website/docs/rand/","title":""},{"contents":" Definition INT rand_seed ( \u0026lt;INT seed\u0026gt; )\nSeeds the random generator, used in rand().\nThis is useful for synchronizing the random generator on multiple machines, as when the same seed is used, calls to rand() with the same limits will return values in the same order on all the machines.\nTo reset the seeding to its original state, meaning the state before any call to rand() or rand_seed(), set seed to 1.\nParameters INT seed - The seed for the random generator used in rand(); 1 to reset.\nReturns INT : true\nExample import \u0026quot;mod_rand\u0026quot; import \u0026quot;mod_say\u0026quot; import \u0026quot;mod_time\u0026quot; Process Main() Begin say(\u0026quot;First number: \u0026quot; + (rand(0,1000)%100)); rand_seed(time()); say(\u0026quot;Random number: \u0026quot; + (rand(0,1000)%100)); rand_seed(1); say(\u0026quot;Again the first number: \u0026quot; + (rand(0,1000)%100)); End  Used in example: say(), rand(), rand_seed()\nCategory:functions Category:math Category:mod_rand\n","permalink":"https://divhub.github.io/pixtudio-website/docs/rand_seed/","title":""},{"contents":" Description Readwrite modes are used to specify the mode of reading/writing of a file, by passing one of them to the function fopen() as the parameter flags.\nList Constant - Value - Description O_READ - 0 - Read only. O_READWRITE - 1 - Read and write. Also called O_RDWR. O_WRITE - 2 - Write only. O_ZREAD - 3 - Read using Z compression. O_ZWRITE - 4 - Write using Z compression.\nCategory:constantcategories\n","permalink":"https://divhub.github.io/pixtudio-website/docs/readwrite_modes/","title":""},{"contents":" Syntax VOID POINTER realloc ( \u0026lt;VOID POINTER data\u0026gt; , \u0026lt;INT size\u0026gt; )\nDescription Resizes the given block of memory.\nIt allocates a new block of memory, copying the old data. If the new size is smaller than the old size, the last part of the data is lost. If the new size of the block of memory requires movement of the block, the old memory block is freed.\nAlso called mem_realloc().\nParameters VOID POINTER data - Pointer to the block of memory to be resized. INT size - The new size of the block of memory in bytes.\nReturns VOID POINTER : Pointer to (the first element of) the newly allocated memory block.\nNULL - There was are an error allocating the memory, like insufficient memory available. - Pointer to (the first element of) the newly allocated memory block.\nExample import \u0026quot;mod_mem\u0026quot; import \u0026quot;mod_say\u0026quot; Process Main() Private byte pointer pbyte; byte pointer pbyte2; int elements = 10; int newelements = 15; int i; Begin // Allocate memory pbyte = alloc(elements); // Set them to 13 memset(pbyte,13,elements); // Relocate it to a larger, newly made memory block pbyte2 = realloc(pbyte,newelements); // Set the added part's elements to 16 (newelements \u0026gt; elements) memset(pbyte+elements,16,newelements-elements); // Show numbers for(i=0; i\u0026lt;newelements; i++) say(\u0026quot;byte2[\u0026quot;+i+\u0026quot;] = \u0026quot; + pbyte2[i]); end OnExit // Free the used memory free(pbyte2); End  Example 2 // Alloc, calloc and realloc tutorial, by handsource-dyko. // This sample program demonstrates how create integer array's with alloc, and calloc, // and how to resize them with realloc. // Some general remarks with manual memory managment, ALWAYS free data after use, and test if an // allocation was successfull with IF (p_test_array2==NULL). When one of these memory allocation // functions returns a NULL, the allocation was NOT sucessfull, and any kind of unpredicatable things // can happen. With manual memory managment, you'll have to really know what you're doing, as the slightest // mistake can cause crashes and unpredicatable behaviour, wich is one of the dangers with using pointers. // import modules IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_mem\u0026quot;; /* alloc(int size); returns: void pointer purpose: create a block of memory, of a certain size, the returned pointer indicates the start adress of this block. */ /* calloc(int size,type); returns: void pointer purpose: create a block of memory, of a certain size, the returned pointer indicates the start adress of this block. is used for creating arrays. */ /* realloc (void pointer data, int size); returns: void pointer purpose: resizes the given block of memory, it allocates a new block of memory, copying the old data. if the new size is smaller than the old size, the last part of the data is lost. if the new size of the block of memory requires movement of the block, the old memory block is freed. */ GLOBAL int pointer p_first_array; // 10 elments, created with alloc() int pointer p_third_array; // 10 elments, created with calloc() int pointer p_second_array; // resized copy of p_first_array, 15 elements, created with realloc() int pointer p_fourth_array; // resized copy of p_second_array, 15 elements, created with realloc() int test[9]; // simple array with 10 elements int pointer p_test_array; // will be used for storing the pointer to test[0] int pointer p_test_array2; // will be the resized array, created with realloc, is now 15 elements int elements=10; // initial array size int new_elements=15; // new array size int count; // general purpose loop counter PROCESS main(); BEGIN // standard array say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); // print the array FOR (count=0; count\u0026lt;elements; count+=1) say(\u0026quot;test[\u0026quot;+count+\u0026quot;]=\u0026quot;+test[count]); END say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;the size of the array 'test' is \u0026quot;+sizeof(test)+\u0026quot; bytes\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); // Allocate memory (10 integers), this way we create an array of integers from (0-9, so 10 elements) // The alloc() function works with bytes. It is always good practice to use the sizeof() operator, because // you'd have to know exactly how many bytes make up a particulair data. An integer is 4 bytes in bennu, // so for an array of 10 elements, you need to allocate 40 bytes. If you do \u0026quot;alloc(elements)\u0026quot;,like in the // wiki, you only get 10 bytes! so that is totally too small for you array! always use this syntax: // // alloc(sizeof(\u0026lt;data_type\u0026gt;)), or for arrays: alloc(elements*sizeof(\u0026lt;data_type\u0026gt;)). Note that \u0026lt;data_type\u0026gt; can // also be a user-defined type. p_first_array=alloc(elements*sizeof(int)); //p_first_array=calloc(elements,sizeof(int)); // check if the allocation succeeded IF (p_first_array==NULL) // allocation failed say(\u0026quot;allocation failed!! p_first_array=\u0026quot;+p_first_array); ELSE // allocation succeeded // set the value's to zero memseti(p_first_array ,0,elements); say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); // print the array FOR (count=0; count\u0026lt;elements; count+=1) say(\u0026quot;p_first_array[\u0026quot;+count+\u0026quot;]=\u0026quot;+p_first_array[count]); END say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;the size of the array is \u0026quot;+(elements*sizeof(int))+\u0026quot; bytes\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); END // Now let's use calloc to create the same array, but calloc is a bit smarter. It's more suited to array's and // it even initializes all the data to 0 for you, so that you can omit the memset() function. In this case I // kept memseti() in there, but you can omit it when using calloc(). But with alloc() you need to use it! // Note the small difference between alloc() and calloc(). //p_second_array=alloc(elements*sizeof(int)); p_second_array=calloc(elements,sizeof(int)); // check if the allocation succeeded IF (p_second_array==NULL) // allocation failed say(\u0026quot;allocation failed!! p_second_array=\u0026quot;+p_second_array); ELSE // allocation succeeded // set the value's to zero memseti(p_second_array ,0,elements); say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); // print the array FOR (count=0; count\u0026lt;elements; count+=1) say(\u0026quot;p_second_array[\u0026quot;+count+\u0026quot;]=\u0026quot;+p_second_array[count]); END say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;the size of the array is \u0026quot;+(elements*sizeof(int))+\u0026quot; bytes\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); END // Let's resize p_first_array to a bigger size (15). This is where realloc() is used for. Also, just as with // alloc(), it is important to remember that it works with bytes! So we use this (new_elements*sizeof(int)) again. p_third_array=realloc(p_first_array,(new_elements*sizeof(int))); // check if the allocation succeeded IF (p_third_array==NULL) // allocation failed say(\u0026quot;allocation failed!! p_third_array=\u0026quot;+p_third_array); ELSE // allocation succeeded // set the value's to zero memseti(p_third_array ,0,new_elements); say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); // print the array FOR (count=0; count\u0026lt;new_elements; count+=1) say(\u0026quot;p_third_array[\u0026quot;+count+\u0026quot;]=\u0026quot;+p_third_array[count]); END say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;the size of the array is \u0026quot;+(new_elements*sizeof(int))+\u0026quot; bytes\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); END // Let's resize p_second_array to a bigger size (15). p_fourth_array=realloc(p_second_array,(new_elements*sizeof(int))); // check if the allocation succeeded IF (p_fourth_array==NULL) // allocation failed say(\u0026quot;allocation failed!! p_fourth_array=\u0026quot;+p_fourth_array); ELSE // allocation succeeded // set the value's to zero memseti(p_fourth_array ,0,new_elements); say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); // print the array FOR (count=0; count\u0026lt;new_elements; count+=1) say(\u0026quot;p_fourth_array[\u0026quot;+count+\u0026quot;]=\u0026quot;+p_fourth_array[count]); END say(\u0026quot;\u0026quot;); say(\u0026quot;the size of the array is \u0026quot;+(new_elements*sizeof(int))+\u0026quot; bytes\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); END // Let's try to resize an standard array (the array test[9]) to 15 p_test_array=test[0]; // \u0026lt;-- p_test_array is a pointer, we store the ADRESS of the first element (wich is 0) in it. // test[0] is actually a pointer itself, it represents the start adress of the array. // The whole concept of array indexing is actuallty a concealed form of pointer artihmatic, // consult any good C book about the details of this. p_test_array2=realloc(p_test_array,(new_elements*sizeof(int))); // check if the allocation succeeded IF (p_test_array2==NULL) // allocation failed say(\u0026quot;allocation failed!! p_test_array2=\u0026quot;+p_test_array2); ELSE // allocation succeeded // set the value's to zero memseti(p_test_array2 ,0,new_elements); say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); // print the array FOR (count=0; count\u0026lt;new_elements; count+=1) say(\u0026quot;p_test_array2[\u0026quot;+count+\u0026quot;]=\u0026quot;+p_test_array2[count]); END say(\u0026quot;\u0026quot;); say(\u0026quot;the size of the array is \u0026quot;+(new_elements*sizeof(int))+\u0026quot; bytes\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); END ONEXIT // Free the used memory say(\u0026quot;freeing old memory........\u0026quot;); say(\u0026quot;p_first_array...\u0026quot;); free(p_first_array); say(\u0026quot;ok\u0026quot;); say(\u0026quot;p_second_array...\u0026quot;); free(p_second_array); say(\u0026quot;ok\u0026quot;); say(\u0026quot;p_third_array...\u0026quot;); free(p_third_array); say(\u0026quot;ok\u0026quot;); say(\u0026quot;p_fourth_array...\u0026quot;); free(p_fourth_array); say(\u0026quot;ok\u0026quot;); say(\u0026quot;p_test_array...\u0026quot;); free(p_test_array); say(\u0026quot;ok\u0026quot;); say(\u0026quot;p_test_array2...\u0026quot;); free(p_test_array2); say(\u0026quot;ok\u0026quot;); END  Used in example: alloc(), memset(), realloc(), say(), free(), pointer\nCategory:functions Category:memory Category:mod_mem\n","permalink":"https://divhub.github.io/pixtudio-website/docs/realloc/","title":""},{"contents":" Syntax INT regex ( \u0026lt;STRING pattern\u0026gt; , \u0026lt;STRING string\u0026gt; )\nDescription Match a regular expresion to the given string. Regular expressions are very powerfull, and allow to do complex pattern searches in texts. You can read about the wealth of posibilities here. Please note that regular expresion synthax is quite cryptic and difficult in general. Some things can be achieved in easier way with string functions like Find(), Len(), Substr() and glob(). It is unknown to wich extend bennu supports certain expressions.\nMatches are stored into the predefined global array Regex_reg.\nParameters STRING pattern - The desired search pattern. STRING string - The string to search in.\nReturns INT : status/match position\n\u0026gt;0 - The character position where the match has been found. -1 - There is no match found.\nExample // import modules IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_regex\u0026quot;; GLOBAL string sourcetext=\u0026quot;It's raining cat's and dogs\u0026quot;; string searchtext=\u0026quot;cat\u0026quot;; // the search pattern int status; PROCESS main(); BEGIN // print the joined string say(\u0026quot;\u0026quot;); // looking for the position of the word \u0026quot;cat\u0026quot; status=regex(searchtext,sourcetext); say(\u0026quot;match found at: \u0026quot;+status); say(\u0026quot;\u0026quot;); // the last character of a line. status=regex(\u0026quot;$\u0026quot;,\u0026quot;99 bottles of beer on the wall.\u0026quot;); say(status+\u0026quot; is the last character position in 99 bottles of beer on the wall.\u0026quot;); say(\u0026quot;\u0026quot;); END  This program will print as result:\nmatch found at: 13 31 is the last character position in 99 bottles of beer on the wall.  Used in example: say() See also: regular expresion examples\nCategory:functions Category:mod_regex\n","permalink":"https://divhub.github.io/pixtudio-website/docs/regex/","title":""},{"contents":" category:variables category:predefined category:global variables category:regular expression category:mod_regex\nUp to Global Variables\nDefinition STRING[15] regex_reg\nRegex_reg is a global variable, holding 16 strings. It holds matches when the functions Regex() and Regex_replace() are used.\nExamples // import modules IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_regex\u0026quot;; GLOBAL string sourcetext=\u0026quot;It's raining cat's and dogs\u0026quot;; string searchtext=\u0026quot;cat\u0026quot;; // the search pattern int status; PROCESS main(); BEGIN // print the joined string say(\u0026quot;\u0026quot;); // looking for the position of the word \u0026quot;cat\u0026quot; status=regex(searchtext,sourcetext); say(\u0026quot;match found at: \u0026quot;+status); say(\u0026quot;\u0026quot;); // the last character of a line. status=regex(\u0026quot;$\u0026quot;,\u0026quot;99 bottles of beer on the wall.\u0026quot;); say(status+\u0026quot; is the last character position in 99 bottles of beer on the wall.\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;regex_reg[0]=\u0026quot;+regex_reg[0]); say(\u0026quot;regex_reg[1]=\u0026quot;+regex_reg[1]); say(\u0026quot;regex_reg[2]=\u0026quot;+regex_reg[2]); say(\u0026quot;regex_reg[3]=\u0026quot;+regex_reg[3]); say(\u0026quot;regex_reg[4]=\u0026quot;+regex_reg[4]); say(\u0026quot;regex_reg[5]=\u0026quot;+regex_reg[5]); say(\u0026quot;regex_reg[6]=\u0026quot;+regex_reg[6]); say(\u0026quot;regex_reg[7]=\u0026quot;+regex_reg[7]); say(\u0026quot;regex_reg[8]=\u0026quot;+regex_reg[8]); say(\u0026quot;regex_reg[9]=\u0026quot;+regex_reg[9]); say(\u0026quot;regex_reg[10]=\u0026quot;+regex_reg[10]); say(\u0026quot;regex_reg[11]=\u0026quot;+regex_reg[11]); say(\u0026quot;regex_reg[12]=\u0026quot;+regex_reg[12]); say(\u0026quot;regex_reg[13]=\u0026quot;+regex_reg[13]); say(\u0026quot;regex_reg[14]=\u0026quot;+regex_reg[14]); say(\u0026quot;regex_reg[16]=\u0026quot;+regex_reg[15]); END  ","permalink":"https://divhub.github.io/pixtudio-website/docs/regex_reg/","title":""},{"contents":" Syntax STRING regex_replace ( \u0026lt;STRING pattern\u0026gt; , \u0026lt;STRING string\u0026gt; , \u0026lt;STRING replacement\u0026gt; )\nDescription Match a regular expresion to the given string. For each match, substitute it with the given replacement. \\0 - \\9 escape sequences are accepted in the replacement. Regular expressions are very powerfull, and allow to do complex pattern searches in texts. You can read about the wealth of posibilities here.\nMatches are stored into the predefined global array Regex_reg.\nParameters STRING pattern - The desired search pattern (i.e. the word or pattern that should change). STRING string - The string with the replacement pattern. STRING replacement - The replacement string (this is the source string), see example\nReturns STRING : the resulting replacement string.\nExample // import modules IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_regex\u0026quot;; GLOBAL string sourcetext=\u0026quot;It's raining cat's and dogs.\u0026quot;; // the orginal sentence string searchtext=\u0026quot;cat\u0026quot;; // the search string string replacetext=\u0026quot;bird\u0026quot;; // the replacement string string replace_result; int result; PROCESS main(); BEGIN // first, look for \u0026quot;cat\u0026quot;. result=regex(searchtext,sourcetext); say(\u0026quot;\u0026quot;); say(searchtext+\u0026quot; found at position: \u0026quot;+result); say(\u0026quot;\u0026quot;); say(\u0026quot;orginal text: \u0026quot;+sourcetext); // replace \u0026quot;cat\u0026quot; with \u0026quot;bird\u0026quot;. replace_result=regex_replace(searchtext,replacetext,sourcetext); say(\u0026quot;\u0026quot;); say(\u0026quot;replace_result: \u0026quot;+replace_result); END  This program will print as result:\ncat found at position: 13 orginal text: It's raining cat's and dogs. replace_result: It's raining bird's and dogs  In this example one word was replaced, but it\u0026rsquo;s possible to do more advanced matching patterns, similair to what most text editors do.\nUsed in example: regex(), say() See also: regular expresion examples\nCategory:functions Category:mod_regex\n","permalink":"https://divhub.github.io/pixtudio-website/docs/regex_replace/","title":""},{"contents":" category:General category:variables category:predefined category:local variables category:librender\nUp to Local Variables\nDefinition Local variable INT region = 0\nRegion is a predefined local variable. Region holds the RegionID of the region in which the process\u0026lsquo; graphic should only be displayed in. By default this is region 0, the whole screen.\nThe graphic of the process is only displayed in its region, even if the x and y coordinates are outside of the region, the part inside the region will still be displayed.\nConcept A region is a rectangular field inside the screen. It can be defined with define_region() and can be useful for displaying graphics in only certain parts of the screen and for the function region_out(). There are 32 regions (0..31) and region 0 is the whole screen.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/region/","title":""},{"contents":" Definition INT region_define ( \u0026lt;INT regionID\u0026gt; , \u0026lt;INT x\u0026gt; , \u0026lt;INT y\u0026gt; , \u0026lt;INT width\u0026gt; , \u0026lt;INT height\u0026gt; )\nDefines the boundaries of a region.\nThere are 32 regions, range 0..31. Region 0 is always the whole screen and cannot be changed. Defining regions can be useful for the function out_region(), the local variable region and using them with scrolls.\nAlso called define_region().\nParameters INT regionID - The regionID of the region to define. INT x - The x coordinate of the top left corner of the region. INT y - The y coordinate of the top left corner of the region. INT width - The width of the region. INT height - The height of the region.\nReturns INT : The regionID specified.\nCategory:functions Category:Regions Category:mod_screen\n","permalink":"https://divhub.github.io/pixtudio-website/docs/region_define/","title":""},{"contents":" Definition INT out_region ( \u0026lt;INT processID\u0026gt; , \u0026lt;INT regionID\u0026gt; )\nChecks if the specified process is completely outside of the specified region.\nThe check is not pixel perfect, but uses the bounding box of the process.\nAlso called out_region().\nParameters INT processID - The processID of the process to check. INT regionID - The regionID of the region to check with.\nReturns INT : true/false: whether the process is completely outside the region.\ntrue - The process is completely outside the region. false - The process is (partly) inside the region or invalid region or process specified.\nCategory:functions Category:Regions Category:mod_screen\n","permalink":"https://divhub.github.io/pixtudio-website/docs/region_out/","title":""},{"contents":" Definition RegionID\nA RegionID is an identifier associated with a certain region.\nCategory:general\n","permalink":"https://divhub.github.io/pixtudio-website/docs/regionid/","title":""},{"contents":"Regular expressions can be used for a lot of text processing things, like finding matches, replacing texts, splitting and joining strings. The syntax is quite complex, but it packs a lot of sophistication in just 4 functions.\nBennu has 4 functions anvailible: Split(), Join(), Regex() and Regex_replace(). They are very usefull in combination with the file and string functions, such as glob(), fgets(), fputs(), find() and Len(). With some creativity you can create text based spreadsheet formats or search and replace texts.\nYou can find more information about regular expressions here.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/regular_expression/","title":""},{"contents":" Definition Render flags are bit flags used to specify the mode of rendering, by passing them to the function set_mode() as the flags parameter. Multiple render flags can be specified using \u0026ldquo;|\u0026rdquo; (pipe character) for separation.\nSee also graph_modes.\nList Constant - Value - Description MODE_WINDOW - 0 - Enables window view. MODE_2XSCALE - 256 - Doubles the resolution. Edges get smoothed using the scale2x algorithm. MODE_FULLSCREEN - 512 - Enables fullscreen view. MODE_DOUBLEBUFFER - 1024 - Enables using a double buffer for display. Also called DOUBLE_BUFFER. MODE_HARDWARE - 2048 - Enables writing directly to Video RAM instead of main RAM. Also called HW_SURFACE. MODE_MODAL - 4096 - Makes the main window a Modal window. MODE_FRAMELESS - 8192 - Makes the main window borderless. MODE_WAITVSYNC - 16384 - Synchronize with vertical retrace. Also called WAITVSYNC.\nMore info  MODE_HARDWARE can cause some operations to speed up and some to slow down.   MODE_DOUBLEBUFFER can cause frame transitions to be smoother. However, compatibility with restore_type = partial_restore is lost!   MODE_MODAL causes the main window to stay focused and hold the mouse.  Category:constantcategories\n","permalink":"https://divhub.github.io/pixtudio-website/docs/render_flags/","title":""},{"contents":" Definition INT reserve_channels ( \u0026lt;INT num_channels\u0026gt; )\nThis functions reserves the indicated number of sound channels from the default sound mixing setup. This is usefull if you want to create groups of sound channels, so that you can devide them for different tasks. When you indicate a 0, all reservations are removed. The channels are reserved starting from channel 0 to num_channels -1. Normally SDL_mixer starts without any channels reserved.\nParameters INT num_channels - The number of channels to reserve.\nReturns INT : Status.\n\u0026gt;0 - The number of reserved channels. -1 - Error: sound inactive.\nCategory:functions Category:sound Category:mod_sound\n","permalink":"https://divhub.github.io/pixtudio-website/docs/reserve_channels/","title":""},{"contents":" category:variables category:predefined category:local variables category:internal\nUp to Local Variables\nDefinition Struct Reserved\nReserved is a local variable struct, containing information that is reserved for Bennu\u0026rsquo;s internals. However, sometimes you may wish to use certain members of it. Using in the sense of reading only, do not under any circumstances alter their values, unless you know what you are doing.\nIf it\u0026rsquo;s not documented what these members do, their use is reasonably limited. If you want to know what these members do, your programming goals are of a level, where you can also look in the sourcecode. This is because most of these members would require a lengthy explanation about what they do and why.\nMembers Member name - Description INT ID_scan - Internal use only (formerly got processID from within the process). INT process_type - The ProcessTypeID of the process. INT type_scan - Internal use only (formerly got processTypeID from within the process). INT status - The status of the process, containing a status code. INT changed - Internal use only. INT xgraph_flags - Internal use only (blit flags for xgraph). INT saved_status - Internal use only (for signals). INT prev_z - Previous z value. INT distance1 - Not used. INT distance2 - Not used. INT frame_percent - Internal use only. INT box_x0 - The x-coordinate of the topleft corner of the process\u0026rsquo; graphic (process.x-graphic.width/2). INT box_y0 - The y-coordinate of the topleft corner of the process\u0026rsquo; graphic (process.y-graphic.height/2). INT box_x1 - The x-coordinate of the bottomright corner of the process\u0026rsquo; graphic (process.x+graphic.width/2). INT box_y1 - The y-coordinate of the bottomright corner of the process\u0026rsquo; graphic (process.y+graphic.height/2).\n","permalink":"https://divhub.github.io/pixtudio-website/docs/reserved/","title":""},{"contents":" category:variables category:predefined category:librender\nUp to Local Variables\nDefinition Local variable INT resolution = 0\nResolution is used to alter the precision of the position of processes on screen; the level of precision is defined by the value of resolution.\nThis simulating of fractions in positions is useful for calculations or animations in need of a high precision in order to work properly. It causes the coordinates of all processes to be interpreted as being multiplied by the value of the local variable resolution, associated with that process. So when a process\u0026rsquo; graphic is displayed, it will appear as if the process\u0026rsquo; x and y values were divided by the value of resolution. A resolution of 0 is interpreted as if it were 1.\nThe default value of resolution is 0, so set it to 1 if the correct value is needed.\nScreen Resolution The resolution of a screen is the dimensions of the screen in pixels. Bennu\u0026rsquo;s default screen resolution is 320×200 pixels. This can be altered by use of set_mode().\nExample import \u0026quot;mod_grproc\u0026quot; import \u0026quot;mod_time\u0026quot; import \u0026quot;mod_key\u0026quot; import \u0026quot;mod_video\u0026quot; import \u0026quot;mod_map\u0026quot; import \u0026quot;mod_draw\u0026quot; import \u0026quot;mod_proc\u0026quot; import \u0026quot;mod_wm\u0026quot; Process Main() Begin // Set screen resolution to 320x200 with a color depth of 8bit set_mode(320,200,8); // Set the FPS to 60 set_fps(60,0); // Set resolution for this process (try changing it to see the effect) resolution = 100; // Create a 200x200 cyan circle and assign its graphID to the local variable graph graph = map_new(200,200,8); drawing_map(0,graph); drawing_color(rgb(0,255,255)); draw_fcircle(100,100,99); // Set size size = 10; // Set the coordinates at screen position (160,180). x = 160 * resolution; y = 180 * resolution; // Move around in circles while leaving a trail behind Repeat trail(x,y,graph,(int)(0.2*size),get_timer()+1000); // create a mini reflection of this process, // lasting one second advance(3*resolution); // advance (3 * resolution) units (= 3 pixels) angle+=2000; // turn 2 degrees left frame; Until(key(_ESC)||exit_status) OnExit let_me_alone(); map_unload(0,graph); End Process trail(x,y,graph,size,endtime) Begin // Get the resolution of the process calling this one resolution = father.resolution; // Remain existent until the specified endtime was reached Repeat frame; Until(get_timer()\u0026gt;=endtime) End  Used in example: set_mode(), set_fps(), map_new(), drawing_map(), drawing_color(), draw_fcircle(), get_timer(), key(), let_me_alone(), map_unload(), advance(), resolution, graph, size, x, y, angle, exit_status\nHere are a few screenshots with different resolutions to display the effect it can have.\nThe effect is clearly visible, so when you are moving processes with graphics around the screen, you might want to consider using a resolution of at least 10 in those processes.\nCategory:general Category:local variables\n","permalink":"https://divhub.github.io/pixtudio-website/docs/resolution/","title":""},{"contents":" Definition Resolution modes are used to specify the resolution, by passing one of them to the global variable scale_resolution or the outdated version of the function set_mode() as the mode parameter.\nList Constant - Value - Resolution M320X200 - 3200200 - 320 x 200 M320X240 - 3200240 - 320 x 240 M320X400 - 3200400 - 320 x 400 M360X240 - 3600240 - 360 x 240 M376X282 - 3760282 - 376 x 282 M400X300 - 4000300 - 400 x 300 M512X384 - 5120384 - 512 x 384 M640X400 - 6400400 - 640 x 400 M640X480 - 6400480 - 640 x 480 M800X600 - 8000600 - 800 x 600 M1024X768 - 10240768 - 1024 x 768 M1280X1024 - 12801024 - 1280 x 1024\nCategory:constantcategories\n","permalink":"https://divhub.github.io/pixtudio-website/docs/resolution_modes/","title":""},{"contents":" Definition Restore modes are used to define the type of restoration, needed to be applied to the screen background, by assigning them to the global variable restore_type. This influences if and how the background is restored after each frame.\nList Constant - Value - Description NO_RESTORE - -1 - The background won\u0026rsquo;t be restored (i.e. redrawn). PARTIAL_RESTORE - 0 - The background will be restored in areas where graphics have been painted or text written (default). COMPLETE_RESTORE - 1 - The background will be completely restored.\nNotes It is clear that completely restoring the background every frame is more expensive than updating only parts of it. However, detecting what parts need updating is no small thing either. So cost-wise both have their situations in which they are good.\nPARTIAL_RESTORE is useful if there is relatively not much changing to the background. COMPLETE_RESTORE is useful if many parts of the background need restoration, like in the case of screen-wide partially transparent scrolls.\nBe certain dump_type is compatible with the restore_type set, because some combinations can cause probably unwanted effects.\nSee also  restore_type dump_type dump_modes  Category:constantcategories\n","permalink":"https://divhub.github.io/pixtudio-website/docs/restore_modes/","title":""},{"contents":" category:variables category:predefined category:global variables category:librender\nUp to Global Variables\nDefinition INT restore_type = PARTIAL_RESTORE\nRestore_type is a global variable, holding the current restore_mode. The mode can be changed by assigning a different mode to the variable. Default is PARTIAL_RESTORE.\nSee also dump_type.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/restore_type/","title":""},{"contents":" Definition INT resume_song ( )\nResumes a song, after it has been paused with the function pause_song().\nReturns INT : Error.\n-1 - Error: sound inactive. 0 - No error.\nNotes The song will instantly start playing again with this function. For a nicer effect, you may want to fade the music in as you resume it. See fade_music_in().\nExample program music_example; global my_song; playing; paused; faded_in; v; begin set_mode(640,480,16); my_song=load_song(\u0026quot;beat.ogg\u0026quot;); write(0,320,30,4,\u0026quot;Use the keyboard to control the music playback.\u0026quot;); write(0,320,50,4,\u0026quot;Key [ENTER] starts / stops the song.\u0026quot;); write(0,320,60,4,\u0026quot;Key [SPACE] pauses / resumes the song.\u0026quot;); write(0,320,70,4,\u0026quot;Key [0] through key [9] changes the song volume.\u0026quot;); write(0,320,80,4,\u0026quot;Key [F] fades the song in or out.\u0026quot;); write(0,320,120,5,\u0026quot;Playing: \u0026quot;); write_int(0,320,120,3,\u0026amp;playing); write(0,320,140,5,\u0026quot;Paused: \u0026quot;); write_int(0,320,140,3,\u0026amp;paused); write(0,320,160,5,\u0026quot;Faded in: \u0026quot;); write_int(0,320,160,3,\u0026amp;faded_in); write(0,320,180,5,\u0026quot;Volume: \u0026quot;); write_int(0,320,180,3,\u0026amp;v); v=128; faded_in=true; repeat if(key(_enter)) if(is_playing_song()) stop_song(); playing=false; else play_song(my_song,1); playing=true; end while(key(_enter))frame;end end if(key(_space)) if(paused) paused=false; resume_song(); else paused=true; pause_song(); end while(key(_space))frame;end end if(key(_f)) if(faded_in) faded_in=false; fade_music_off(100); else faded_in=true; fade_music_in(my_song,1,100); end while(key(_f))frame;end end if(key(_0))v=0;end if(key(_1))v=14;end if(key(_2))v=28;end if(key(_3))v=43;end if(key(_4))v=57;end if(key(_5))v=71;end if(key(_6))v=85;end if(key(_7))v=100;end if(key(_8))v=114;end if(key(_9))v=128;end set_song_volume(v); frame; until(key(_esc)) exit(); end  Used in example: key(), set_mode(), load_song(), write(), write_int(), pause_song(), play_song(), stop_song(), resume_song(), fade_music_in(), fade_music_off(), set_song_volume().\nCategory:functions Category:sound Category:mod_sound\n","permalink":"https://divhub.github.io/pixtudio-website/docs/resume_song/","title":""},{"contents":" Definition INT resume_wav (INT \u0026lt; channel \u0026gt; )\nResumes the currently paused wave channel, that was paused by Pause_wav().\nParameters INT channel - The WAV sound channel.\nReturns INT : Error.\n-1 - Error: sound inactive. 0 - No error.\nExample // import modules IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_proc\u0026quot;; IMPORT \u0026quot;mod_key\u0026quot;; IMPORT \u0026quot;mod_sound\u0026quot;; GLOBAL int wav; int channel; PROCESS main(); BEGIN wav=load_wav(\u0026quot;wav.wav\u0026quot;); say(\u0026quot;Test pause_wav...\u0026quot;); say(\u0026quot;ENTER = Pause Sound...\u0026quot;); say(\u0026quot;Press ESC to quit...\u0026quot;); channel=play_wav(wav,-1); REPEAT IF(key(_enter)) pause_wav(channel); FRAME(2500); resume_wav(channel); END FRAME; UNTIL(key(_esc)) END  Used in example: key(), say(), pause_wav(), play_wav(), load_wav().\nCategory:functions Category:sound Category:mod_sound\n","permalink":"https://divhub.github.io/pixtudio-website/docs/resume_wav/","title":""},{"contents":" Definition Return {value};  Return is a reserved word used to return a value in a function. The returned value must be of the datatype specified as the returndatatype (see Function). By default, the returntype of a process or function is an int. When this statement is reached, the function in which it resides will stop execution and return the specified value. If a value was not specified, the ProcessID will be returned.\nExample  Function string example_function() Private string s; Begin s = \u0026quot;Some string\u0026quot;; return s; End  Used in example: Function, Private, Begin, End, Return, String\n","permalink":"https://divhub.github.io/pixtudio-website/docs/return/","title":""},{"contents":" Definition INT reverse_stero ( \u0026lt;INT channel\u0026gt; , \u0026lt;INT flip\u0026gt;)\nThis function swaps the stereo of the indicated sound channel.\nParameters INT channels - The channel of wich it\u0026rsquo;s stereo is to be reversed. INT flip - The flip, (0 = normal , 1 = reverse).\nReturns INT : Status.\n0 - Ok. -1 - There is an error.\nCategory:functions Category:sound Category:mod_sound\n","permalink":"https://divhub.github.io/pixtudio-website/docs/reverse_stereo/","title":""},{"contents":" Syntax DWORD rgb ( \u0026lt;BYTE red\u0026gt; , \u0026lt;BYTE green\u0026gt; , \u0026lt;BYTE blue\u0026gt; , [\u0026lt;INT depth\u0026gt;] )\nDescription Finds the single color in the current color mode closest to the combined red, green, and blue values specified. In 32bit mode, the alpha is set to 255.\nEqual to [[rgba]](''red'',''green'',''blue'',255)\nParameters BYTE red - Level of red in the desired color from 0 to 255. BYTE green - Level of green in the desired color from 0 to 255. BYTE blue - Level of blue in the desired color from 0 to 255. INT depth - Depth (optional paramter that may be omitted, only in 16 and 32 bit mode). When this parameter is used, the function returns the correct color code for the indicated depth.\nReturns DWORD : Returns the best matched color code.\nNotes Different color depths have different color codes, this is why rgb() is useful: it returns the appropriate code, based on the current color depth. When in 8bit mode, this code is 0..255 and when in 16bit mode 0..65535. In 32bit mode the code is 0xRRGGBBAA, two letters meaning one byte.\nUsing this function in different color depths can be tricky. This is because rgb() will return a different color code under different color depths. For example, when at 8bit, we do:\nmy_color = rgb(100,100,100);  my_color will most likely have the value 6 at this time. Suppose we change the color depth to 16bit now, using set_mode(). Now, my_color holds a totally different color than before, as 6 is nowhere near rgb(100,100,100) in 16bit mode. To counter this effect, my_color needs to be reinitialized:\nmy_color = rgb(100,100,100);  The same code, but rgb() now returns the proper code, as it always returns the code belonging to the current color depth. my_color will now be about 25388.\nExample import \u0026quot;mod_map\u0026quot; import \u0026quot;mod_text\u0026quot; import \u0026quot;mod_key\u0026quot; import \u0026quot;mod_wm\u0026quot; Process Main() Private byte red=0; byte green=255; byte blue=0; Begin set_text_color(rgb(red,green,blue)); // rgb finds the color closest to pure green and // passes it to set_text_color write(0,1,1,0,\u0026quot;Green text for everybody!\u0026quot;); //this text will be green Repeat frame; Until(key(_ESC)||exit_status) End  Used in example: set_text_color(), rgb(), write(), key(), exit_status\nCategory:functions Category:palettes Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/rgb/","title":""},{"contents":" Syntax INT rgb_get ( \u0026lt;INT pixel_color \u0026gt; , \u0026lt;POINTER red\u0026gt; , \u0026lt;POINTER green\u0026gt; , \u0026lt;POINTER blue\u0026gt; , [\u0026lt;INT depth\u0026gt;] )\nDescription Get access to the memory sections of the color components, these can be accessed with the Offset operator.\nThe previous get_rgb() is deprecated.\nParameters INT pixel_color - The color value of a pixel . POINTER red - Pointer to the level of red in the desired color from 0 to 255. POINTER green - Pointer to the level of green in the desired color from 0 to 255. POINTER blue - Pointer to the level of blue in the desired color from 0 to 255. INT depth - Depth (optional paramter that may be omitted, only in 16 and 32 bit mode). When this parameter is used, the function returns the correct color code for the indicated depth.\nReturns 1 : This function always returns a 1.\nNotes The color value\u0026rsquo;s have to be obtained with the Offset operator, and the pixel color value can be obtained with Map_get_pixel().\nExample IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_key\u0026quot;; IMPORT \u0026quot;mod_map\u0026quot;; IMPORT \u0026quot;mod_video\u0026quot;; IMPORT \u0026quot;mod_wm\u0026quot;; IMPORT \u0026quot;mod_draw\u0026quot;; IMPORT \u0026quot;mod_screen\u0026quot;; IMPORT \u0026quot;mod_mem\u0026quot;; IMPORT \u0026quot;mod_text\u0026quot;; GLOBAL int map_id; // id code of the map to load int status; // status for debugging // color components int my_r; int my_g; int my_b; PROCESS main(); BEGIN set_mode(320,200,32); // load the map map_id=load_map(\u0026quot;3COCHE.MAP\u0026quot;); // first, we're going to check the r,g,b values of 5 pixels, with the optional // depth parameter. status=get_rgb(map_get_pixel(0,map_id,0,0), \u0026amp;my_r, \u0026amp;my_g, \u0026amp;my_b ,32); say(\u0026quot;my_r: \u0026quot;+my_r+\u0026quot; my_g: \u0026quot;+my_g+\u0026quot; my_b: \u0026quot;+my_b); say(\u0026quot;status: \u0026quot;+status); status=get_rgb(map_get_pixel(0,map_id,4,0), \u0026amp;my_r, \u0026amp;my_g, \u0026amp;my_b ,32); say(\u0026quot;my_r: \u0026quot;+my_r+\u0026quot; my_g: \u0026quot;+my_g+\u0026quot; my_b: \u0026quot;+my_b); say(\u0026quot;status: \u0026quot;+status); status=get_rgb(map_get_pixel(0,map_id,50,1), \u0026amp;my_r, \u0026amp;my_g, \u0026amp;my_b ,32); say(\u0026quot;my_r: \u0026quot;+my_r+\u0026quot; my_g: \u0026quot;+my_g+\u0026quot; my_b: \u0026quot;+my_b); say(\u0026quot;status: \u0026quot;+status); status=get_rgb(map_get_pixel(0,map_id,13,24), \u0026amp;my_r, \u0026amp;my_g, \u0026amp;my_b, 32); say(\u0026quot;my_r: \u0026quot;+my_r+\u0026quot; my_g: \u0026quot;+my_g+\u0026quot; my_b: \u0026quot;+my_b); say(\u0026quot;status: \u0026quot;+status); status=get_rgb(map_get_pixel(0,map_id,84,40), \u0026amp;my_r, \u0026amp;my_g, \u0026amp;my_b, 32); say(\u0026quot;my_r: \u0026quot;+my_r+\u0026quot; my_g: \u0026quot;+my_g+\u0026quot; my_b: \u0026quot;+my_b); say(\u0026quot;status: \u0026quot;+status); // second, we use the simpler way, that is valid for a bit maps say(\u0026quot;\u0026quot;); say(\u0026quot;8 bit color codes\u0026quot;); say(map_get_pixel(0,map_id,0,0)); say(map_get_pixel(0,map_id,4,0)); say(map_get_pixel(0,map_id,50,1)); say(map_get_pixel(0,map_id,13,24)); say(map_get_pixel(0,map_id,84,40)); LOOP IF (key(_esc)) BREAK; END FRAME; END END  See also The articles about the functions, Rgb() and Rgba() for more information, since this function is related to some extend.\nCategory:functions Category:palettes Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/rgb_get/","title":""},{"contents":" Syntax DWORD rgba ( \u0026lt;BYTE red\u0026gt; , \u0026lt;BYTE green\u0026gt; , \u0026lt;BYTE blue\u0026gt;, \u0026lt;BYTE alpha\u0026gt; , [\u0026lt;INT depth\u0026gt;] )\nDescription Finds the single color in the current color mode closest to the combined red, green, blue and alpha values specified. This function is useful in 32 bpp modes.\nParameters BYTE red - Level of red in the desired color from 0 to 255. BYTE green - Level of green in the desired color from 0 to 255. BYTE blue - Level of blue in the desired color from 0 to 255. BYTE alpha - Level of alpha in the desired color from 0 to 255, 0 being completely transparent and 255 completely opaque. INT depth - Optional parameter, wich may be omitted. Only usefull in 16 and 32 bit modes, ensures that the function returns a colorcode that is valid for the specified mode.\nReturns DWORD : Returns the best matched color code.\nNotes Different color depths have different color codes, this is why rgba() is useful: it returns the appropriate code, based on the current color depth. When in 8bit mode, this code is 0..255 and when in 16bit mode 0..65535. In 32bit mode the code is 0xRRGGBBAA, two letters meaning one byte.\nUsing this function in different color depths can be tricky. This is because rgba() will return a different color code under different color depths. For example, when at 8bit, we do:\nmy_color = rgba(100,100,100,255);  my_color will most likely have the value 6 at this time. Suppose we change the color depth to 16bit now, using set_mode(). Now, my_color holds a totally different color value than before, as 6 is nowhere near rgba(100,100,100,255) in 16bit mode. To counter this effect, my_color needs to be reinitialized:\nmy_color = rgba(100,100,100,255);  The same code, but rgba() now returns the proper code, as it always returns the code belonging to the current color depth. my_color will now be about 25388.\nExample import \u0026quot;mod_text\u0026quot; import \u0026quot;mod_map\u0026quot; import \u0026quot;mod_key\u0026quot; import \u0026quot;mod_video\u0026quot; import \u0026quot;mod_wm\u0026quot; Const SCREEN_WIDTH = 320; SCREEN_HEIGHT = 200; SCREEN_DEPTH = 16; End Process Main() Private int r=0; int g=255; int b=0; int a=0; int da=10; Begin set_mode(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_DEPTH); graph = map_new(100,100,SCREEN_DEPTH); map_clear(0,graph,rgba(r,g,b,a)); x = y = 100; Repeat a += da; if(a\u0026lt;0) da = -da; a = 0; elseif(a\u0026gt;255) da = -da; a = 255; end map_clear(0,graph,rgba(r,g,b,a)); frame; Until(key(_ESC)||exit_status) End  Used in example: set_mode(), map_new(), map_clear(), key(), rgba(), graph, exit_status\nCategory:functions Category:palettes Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/rgba/","title":""},{"contents":" Syntax DWORD rgba_get ( \u0026lt;INT pixel_color \u0026gt; , \u0026lt;POINTER red\u0026gt; , \u0026lt;POINTER green\u0026gt; , \u0026lt;POINTER blue\u0026gt; , \u0026lt;POINTER alpha\u0026gt; , [\u0026lt;INT depth\u0026gt;] )\nDescription Get access to the memory sections of the color components, these can be accessed with the Offset operator.\nThe previous name Get_rgba() is deprecated.\nParameters INT pixel_color - The color value of a pixel . POINTER red - Pointer to the level of red in the desired color from 0 to 255. POINTER green - Pointer to the level of green in the desired color from 0 to 255. POINTER blue - Pointer to the level of blue in the desired color from 0 to 255. POINTER alpha - Pointer to the alpha channel in the from 0 to 255. INT depth - Depth (optional paramter that may be omitted, only in 16 and 32 bit mode). When this parameter is used, the function returns the correct color code for the indicated depth.\nReturns 1 : This function always returns a 1.\nNotes The color value\u0026rsquo;s have to be obtained with the Offset operator, and the pixel color value can be obtained with Map_get_pixel().\nExample IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_key\u0026quot;; IMPORT \u0026quot;mod_map\u0026quot;; IMPORT \u0026quot;mod_video\u0026quot;; IMPORT \u0026quot;mod_wm\u0026quot;; IMPORT \u0026quot;mod_draw\u0026quot;; IMPORT \u0026quot;mod_screen\u0026quot;; IMPORT \u0026quot;mod_mem\u0026quot;; IMPORT \u0026quot;mod_text\u0026quot;; GLOBAL int map_id; // id code of the map to load int status; // status for debugging // color components int my_r; int my_g; int my_b; int my_a; PROCESS main(); BEGIN set_mode(320,200,32); // load the map map_id=load_map(\u0026quot;3COCHE.MAP\u0026quot;); // first, we're going to check the r,g,b,a values of 5 pixels, with the optional // depth parameter. status=get_rgba(map_get_pixel(0,map_id,0,0), \u0026amp;my_r, \u0026amp;my_g, \u0026amp;my_b, \u0026amp;my_a,32); say(\u0026quot;my_r: \u0026quot;+my_r+\u0026quot; my_g: \u0026quot;+my_g+\u0026quot; my_b: \u0026quot;+my_b+\u0026quot; my_a: \u0026quot;+my_a); say(\u0026quot;status: \u0026quot;+status); status=get_rgba(map_get_pixel(0,map_id,4,0), \u0026amp;my_r, \u0026amp;my_g, \u0026amp;my_b, \u0026amp;my_a,32); say(\u0026quot;my_r: \u0026quot;+my_r+\u0026quot; my_g: \u0026quot;+my_g+\u0026quot; my_b: \u0026quot;+my_b+\u0026quot; my_a: \u0026quot;+my_a); say(\u0026quot;status: \u0026quot;+status); status=get_rgba(map_get_pixel(0,map_id,50,1), \u0026amp;my_r, \u0026amp;my_g, \u0026amp;my_b, \u0026amp;my_a,32); say(\u0026quot;my_r: \u0026quot;+my_r+\u0026quot; my_g: \u0026quot;+my_g+\u0026quot; my_b: \u0026quot;+my_b+\u0026quot; my_a: \u0026quot;+my_a); say(\u0026quot;status: \u0026quot;+status); status=get_rgba(map_get_pixel(0,map_id,13,24), \u0026amp;my_r, \u0026amp;my_g, \u0026amp;my_b, \u0026amp;my_a,32); say(\u0026quot;my_r: \u0026quot;+my_r+\u0026quot; my_g: \u0026quot;+my_g+\u0026quot; my_b: \u0026quot;+my_b+\u0026quot; my_a: \u0026quot;+my_a); say(\u0026quot;status: \u0026quot;+status); status=get_rgba(map_get_pixel(0,map_id,84,40), \u0026amp;my_r, \u0026amp;my_g, \u0026amp;my_b, \u0026amp;my_a,32); say(\u0026quot;my_r: \u0026quot;+my_r+\u0026quot; my_g: \u0026quot;+my_g+\u0026quot; my_b: \u0026quot;+my_b+\u0026quot; my_a: \u0026quot;+my_a); say(\u0026quot;status: \u0026quot;+status); // second, we use the simpler way, that is valid for a bit maps say(\u0026quot;\u0026quot;); say(\u0026quot;8 bit color codes\u0026quot;); say(map_get_pixel(0,map_id,0,0)); say(map_get_pixel(0,map_id,4,0)); say(map_get_pixel(0,map_id,50,1)); say(map_get_pixel(0,map_id,13,24)); say(map_get_pixel(0,map_id,84,40)); LOOP IF (key(_esc)) BREAK; END FRAME; END END  See also The articles about the functions, Rgb() and Rgba() for more information, since this function is related to some extend.\nCategory:functions Category:palettes Category:mod_map\n","permalink":"https://divhub.github.io/pixtudio-website/docs/rgba_get/","title":""},{"contents":" Definition INT rgbscale ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; , \u0026lt;FLOAT r\u0026gt; , \u0026lt;FLOAT g\u0026gt; , \u0026lt;FLOAT b\u0026gt; )\nThis will convert the specified graphic by using the specified color as a reference. The converted graphic will have only the specified color and lighter/darker colors; see notes for the details.\nParameters INT fileID - The fileID of the file that holds the graphics. INT graphID - The graphID of the graphic to convert. FLOAT r - The red component of the color to be used for reference. FLOAT g - The green component of the color to be used for reference. FLOAT b - The blue component of the color to be used for reference.\nReturns INT\n-1 - Invalid graphic. 1 - Success.\nNotes The exact formula is:\nfor every pixel: c = 0.3 * oldpixel_r + 0.59 * oldpixel_g + 0.11 * oldpixel_b newpixel_r = r * c; newpixel_g = g * c; newpixel_b = b * c;  where r,g,b are the specified r,g,b.\nNote that [[rgbscale]](0,map,1,1,1) = [[grayscale]](0,map,0), for a valid graphic (0,map).\nCategory:functions Category:graphical effects Category:mod_effects\n","permalink":"https://divhub.github.io/pixtudio-website/docs/rgbscale/","title":""},{"contents":" Definition INT rm ( \u0026lt;STRING filename\u0026gt; )\nRemoves (deletes) the file specified with filename.\nParameters STRING filename - The name of the file to be removed (deleted).\nReturns INT : Success\n0 (false) - Removing the file with the specified name failed. !0 (true) - Removing the file with the specified name succeeded.\nCategory:functions Category:files Category:mod_dir\n","permalink":"https://divhub.github.io/pixtudio-website/docs/rm/","title":""},{"contents":" Definition INT rmdir ( \u0026lt;STRING directoryname\u0026gt; )\nRemoves (deletes) the directory in the current path of execution with a certain name.\nParameters STRING directoryname - The name of the directory to be removed (deleted).\nReturns INT : Success\n0 (false) - Removing the directory with the specified name failed. !0 (true) - Removing the directory with the specified name succeeded.\nCategory:functions Category:files Category:mod_dir\n","permalink":"https://divhub.github.io/pixtudio-website/docs/rmdir/","title":""},{"contents":" Definition STRING rpad( \u0026lt;STRING str\u0026gt; , \u0026lt;INT length\u0026gt; )\nReturns the string str, padding (adding spaces to) the back of the string if needed to make str of length length. The original string will remain unchanged.\nIf length is smaller or equal to the length of str, the returned string is str.\nParameters STRING str - The string to pad (add spaces to). INT length - The minimal length of the returned string.\nReturns STRING: padded string\nExample import \u0026quot;mod_string\u0026quot; import \u0026quot;mod_say\u0026quot; Process Main() Private string ABC = \u0026quot;ABC\u0026quot;; string _ABC; string ABC__; Begin ABC = lpad(ABC,2); _ABC = lpad(ABC,4); ABC__ = rpad(ABC,5); say('ABC = \u0026quot;' + ABC + '\u0026quot;'); say('_ABC = \u0026quot;' + _ABC + '\u0026quot;'); say('ABC__ = \u0026quot;' + ABC__ + '\u0026quot;'); End  Used in example: say(), lpad(), rpad()\nResult:\nABC = \u0026quot;ABC\u0026quot; _ABC = \u0026quot; ABC\u0026quot; ABC__ = \u0026quot;ABC \u0026quot;  Category:functions Category:strings Category:mod_string\n","permalink":"https://divhub.github.io/pixtudio-website/docs/rpad/","title":""},{"contents":" Definition INT save ( \u0026lt;STRING filename\u0026gt; , \u0026lt;VARSPACE data\u0026gt; )\nSaves the data from the specified variable to the specified file.\nParameters STRING filename - The name of the file that will be saved. VARSPACE data - The variable (of any datatype) that will be saved in a file.\nReturns INT : The number of bytes written to the file.\nNotes Attempting to use \u0026ldquo;?\u0026rdquo;,\u0026rdquo;*\u0026rdquo;,\u0026rdquo;\u0026lt;\u0026rdquo;,\u0026rdquo;\u0026gt;\u0026rdquo; or \u0026ldquo;|\u0026rdquo; in a filename will result in no file at all on Windows, while using \u0026ldquo;:\u0026rdquo; in a filename results in everything from the \u0026ldquo;:\u0026rdquo; and beyond being cut off from the file name and the resulting file will be of size 0.\nUsing the characters \u0026ldquo;/\u0026rdquo; or \u0026ldquo;\\\u0026rdquo; in the filename (without directories that can be accessed that way) results in everything from this character and before being cut off from the filename. The file will be saved successfully nonetheless.\nExample Program test; Global struct My_struct Level_number=\u0026quot;99\u0026quot;; string Map_name=\u0026quot;Amazing map\u0026quot;; End Begin Save(\u0026quot;myfile.sav\u0026quot;,My_struct); // The content of My_struct is saved in myfile.sav Write(0,10,10,0,\u0026quot;Data saved!\u0026quot;); While (!key(_ESC)) Frame; End End  Used in example: save(), write(), key()\nCategory:functions Category:files Category:mod_file\n","permalink":"https://divhub.github.io/pixtudio-website/docs/save/","title":""},{"contents":" Definition INT say ( \u0026lt;STRING message\u0026gt; )\nPrints message to stdout (console).\n Similar to System.out.println(message) in Java. Similar to printf(\u0026quot;%s\\n\u0026quot;,message) in C  Parameters STRING message - The message to print to stdout\nReturns INT - true\nExample import \u0026quot;mod_say\u0026quot; Process Main() Begin Say(\u0026quot;Hello World!\u0026quot;); End  This will result in the output on console:\nHello World!  Category:functions Category:debug Category:mod_say\n","permalink":"https://divhub.github.io/pixtudio-website/docs/say/","title":""},{"contents":" Definition INT say_fast ( \u0026lt;STRING message\u0026gt; )\nPrints message to stdout (console). This function is the same as the Say() function, but with the difference that the debugging information isn\u0026rsquo;t flushed (buffered) into the standard output. As you can see in the bennu source code mod_say.c, the difference is only 1 instruction, so it\u0026rsquo;s slightly faster.\n Similar to System.out.println(message) in Java. Similar to printf(\u0026quot;%s\\n\u0026quot;,message) in C  Parameters STRING message - The message to print on to the console\nReturns INT - true\nExample // import modules IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_debug\u0026quot;; GLOBAL int count; PROCESS main(); BEGIN say(\u0026quot;hello world.\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); FOR (count=0; count\u0026lt;5000; count+=1) say_fast(\u0026quot;count: \u0026quot;+count); END END  This will result in the output on console:\nHello World!  Category:functions Category:debug Category:mod_say\n","permalink":"https://divhub.github.io/pixtudio-website/docs/say_fast/","title":""},{"contents":" category:variables category:predefined category:global variables category:libvideo\nUp to Global Variables\nINT scale_mode = SCALE_NONE\nDescription Scale_mode is a global variable, holding the current or to be scale mode. The mode can be changed by assigning a different mode to the variable and then calling set_mode(). Default is SCALE_NONE.\nSee also  sound_mode graph_mode  ","permalink":"https://divhub.github.io/pixtudio-website/docs/scale_mode/","title":""},{"contents":" Definition Scale modes are used to set the mode of scaling, by assigning one of them to the global variable scale_mode.\nList Constant - Value - Description SCALE_NONE - 0 - No scale. SCALE_SCALE2X - 1 - Scale two times; use some filter. Looks like MODE_2XSCALE. SCALE_HQ2X - 2 - Scale two times; use HQ filter. Looks nice, runs slower. SCALE_SCANLINE2X - 3 - Scale two times; use scanline filter. SCALE_NORMAL2X - 4 - Scale two times; no extra filter. Also called SCALE_NOFILTER.\nCategory:constantcategories\n","permalink":"https://divhub.github.io/pixtudio-website/docs/scale_modes/","title":""},{"contents":" category:variables category:predefined category:global variables category:libvideo\nUp to Global Variables\nINT scale_resolution = WWWWHHHH\nWhere WWWW is the Width and HHHH the Height. Resolution_modes can be used.\nDescription Scale_resolution is a global variable used to resize the screen without changing the real resolution. That means the game still uses the resolution indicated by set_mode() but it\u0026rsquo;s displayed on the screen at the one assigned to scale_resolution. Unlike scale_mode can work with 32bits but doesn\u0026rsquo;t use any filter.\nScale_resolution takes effect after set_mode() only and cannot be used togheter with scale_mode. Assigning NULL will cancel the use of scale_resolution.\nExample //This example is a modification of an example taken from Oscar's Manual Import \u0026quot;mod_video\u0026quot;; Import \u0026quot;mod_text\u0026quot;; Import \u0026quot;mod_key\u0026quot;; Import \u0026quot;mod_map\u0026quot;; Import \u0026quot;mod_proc\u0026quot;; Import \u0026quot;mod_draw\u0026quot;; Process Main() begin set_mode(800,600,32); write(0,100,80,0,\u0026quot;SCALE_RESOLUTION's value:\u0026quot;); write_var(0,300,80,0,scale_resolution); proceso(); repeat if(key(_a)) scale_resolution=03200240;end if(key(_s)) scale_resolution=06400480;end if(key(_d)) scale_resolution=08000600;end if(key(_f)) scale_resolution=10240768;end if(key(_c)) scale_resolution=NULL;end set_mode(800,600,32); frame; until(key(_esc)) let_me_alone(); end Process proceso() begin x=180;y=150; graph=map_new(60,60,32); drawing_map(0,graph); drawing_color(rgb(255,255,0)); draw_fcircle(25,25,25); loop frame; end end  Used in example: set_mode(), write(), write_var(), map_new(), drawing_map(), drawing_color(), draw_fcircle().\nSee also scale_resolution_orientation, scale_resolution_aspectratio.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/scale_resolution/","title":""},{"contents":" category:variables category:predefined category:global variables category:libvideo\nUp to Global Variables\nINT scale_resolution_aspectratio = Scale_resolution_aspectratio_modes.\nDescription Scale_resolution_aspectratio is a global variable used to choose between stretching a screen resized by scale_resolution to fill the screen or keeping his aspect ratio.\nExample Import \u0026quot;mod_video\u0026quot;; Import \u0026quot;mod_text\u0026quot;; Import \u0026quot;mod_key\u0026quot;; Import \u0026quot;mod_map\u0026quot;; Import \u0026quot;mod_proc\u0026quot;; Import \u0026quot;mod_screen\u0026quot;; Process Main() begin set_mode(800,600,32); write(0,20,20,0,\u0026quot;SCALE_RESOLUTION:\u0026quot;); write_var(0,160,20,0,scale_resolution); write(0,20,30,0,\u0026quot;( Press R) \u0026quot;); write(0,20,50,0,\u0026quot;SCALE_RESOLUTION_ORIENTATION:\u0026quot;); write_var(0,255,50,0,scale_resolution_orientation); write(0,20,60,0,\u0026quot;( Press 0, 1, 2 or ) \u0026quot;); write(0,20,90,0,\u0026quot;SCALE_RESOLUTION_ASPECTRATIO:\u0026quot;); write_var(0,255,90,0,scale_resolution_aspectratio); write(0,20,100,0,\u0026quot;( Press A ) \u0026quot;); Screen_put(0,png_load(\u0026quot;mz800x600.png\u0026quot;)); repeat //Activates/deactivates scale_resolution. if(key(_r)) while(key(_r)) frame; end //Wait until the key is released if (scale_resolution==0); //If scale_resolution is not active... scale_resolution=08000480; //...then resize the screen else //If scale_resolution is already working... scale_resolution=NULL; //...then stop it. end end //This rotates the screen. Only works when SCALE_RESOLUTION is being used. if(key(_0)) scale_resolution_orientation=SRO_NORMAL;end if(key(_1)) scale_resolution_orientation=SRO_LEFT;end if(key(_2)) scale_resolution_orientation=SRO_DOWN;end if(key(_3)) scale_resolution_orientation=SRO_RIGHT;end //This activates/deactivates the ASPECT RATIO. Only works when SCALE_RESOLUTION is being used. if(key(_a)) while(key(_a)) frame; end if (scale_resolution_aspectratio==0); scale_resolution_aspectratio=SRA_PRESERVE; else scale_resolution_aspectratio=SRA_STRETCH; end end set_mode(800,600,32); frame; until(key(_esc)) let_me_alone(); end  Used in example: write(), write_var(), Screen_put()\nFile used in example: Mz800x600.png by MZ.\nSee also scale_resolution, scale_resolution_orientation\n","permalink":"https://divhub.github.io/pixtudio-website/docs/scale_resolution_aspectratio/","title":""},{"contents":" Description When assigned to to the global variable scale_resolution_aspectratio allows to choose between stretching a screen resized by screen_resolution to fill the screen or keeping his aspect ratio.\nList Constant - Value Description SRA_STRETCH - 0 Stretches the screen. SRA_PRESERVE - 1 Keeps the aspect ratio.\nCategory:constantcategories\n","permalink":"https://divhub.github.io/pixtudio-website/docs/scale_resolution_aspectratio_modes/","title":""},{"contents":" category:variables category:predefined category:global variables category:libvideo\nUp to Global Variables\nINT scale_resolution_orientation = Scale_resolution_orientation_modes.\nDescription Scale_resolution_orientation is a global variable used to rotate a screen resized by scale_resolution without changing the real orientation.\nExample Import \u0026quot;mod_video\u0026quot;; Import \u0026quot;mod_text\u0026quot;; Import \u0026quot;mod_key\u0026quot;; Import \u0026quot;mod_map\u0026quot;; Import \u0026quot;mod_proc\u0026quot;; Import \u0026quot;mod_screen\u0026quot;; Process Main() begin set_mode(800,600,32); write(0,20,20,0,\u0026quot;SCALE_RESOLUTION:\u0026quot;); write_var(0,160,20,0,scale_resolution); write(0,20,30,0,\u0026quot;( Press R) \u0026quot;); write(0,20,50,0,\u0026quot;SCALE_RESOLUTION_ORIENTATION:\u0026quot;); write_var(0,255,50,0,scale_resolution_orientation); write(0,20,60,0,\u0026quot;( Press 0, 1, 2 or ) \u0026quot;); write(0,20,90,0,\u0026quot;SCALE_RESOLUTION_ASPECTRATIO:\u0026quot;); write_var(0,255,90,0,scale_resolution_aspectratio); write(0,20,100,0,\u0026quot;( Press A ) \u0026quot;); Screen_put(0,png_load(\u0026quot;mz800x600.png\u0026quot;)); repeat //Activates/deactivates scale_resolution. if(key(_r)) while(key(_r)) frame; end //Wait until the key is released if (scale_resolution==0); //If scale_resolution is not active... scale_resolution=08000480; //...then resize the screen else //If scale_resolution is already working... scale_resolution=NULL; //...then stop it. end end //This rotates the screen. Only works when SCALE_RESOLUTION is being used. if(key(_0)) scale_resolution_orientation=SRO_NORMAL;end if(key(_1)) scale_resolution_orientation=SRO_LEFT;end if(key(_2)) scale_resolution_orientation=SRO_DOWN;end if(key(_3)) scale_resolution_orientation=SRO_RIGHT;end //This activates/deactivates the ASPECT RATIO. Only works when SCALE_RESOLUTION is being used. if(key(_a)) while(key(_a)) frame; end if (scale_resolution_aspectratio==0); scale_resolution_aspectratio=SRA_PRESERVE; else scale_resolution_aspectratio=SRA_STRETCH; end end set_mode(800,600,32); frame; until(key(_esc)) let_me_alone(); end  Used in example: write(), write_var(), Screen_put()\nFile used in example: Mz800x600.png by MZ.\nSee also scale_resolution, scale_resolution_aspectratio\n","permalink":"https://divhub.github.io/pixtudio-website/docs/scale_resolution_orientation/","title":""},{"contents":" Description When assigned to to the global variable scale_resolution_orientation allows to rotate a screen resized by screen_resolution without changing the real orientation.\nList Constant - Value Description SRO_NORMAL - 0 No changes. SRO_LEFT - 1 Rotates the screen 90 degrees anti-clockwise. SRO_DOWN - 2 Rotates the screen 180 degrees. SRO_RIGHT - 3 Rotates the screen 90 degrees clockwise.\nCategory:constantcategories\n","permalink":"https://divhub.github.io/pixtudio-website/docs/scale_resolution_orientation_modes/","title":""},{"contents":" category:variables category:predefined category:global variables category:mod_key\nUp to Global Variables\nDefinition INT scan_code\nScan_code is defined in the module mod_key and, in contrast to ascii, it contains the last key pressed, not the last character. That means “A” and “a” will have the same scan_code, but different ascii value.\nNotes Take a look at the scancodes for a complete list.\nExample import \u0026quot;mod_text\u0026quot; import \u0026quot;mod_key\u0026quot; import \u0026quot;mod_video\u0026quot; process main() begin set_mode(640,320); write( 0, 60, 10, 0, \u0026quot;Use lower and upper case characters to see the difference\u0026quot;); write( 0, 60, 20, 0, \u0026quot;between ascii and scan_code. (ESC to exit) \u0026quot;); write( 0, 60, 40, 0, \u0026quot;ascii: \u0026quot;); write_var( 0, 110, 40, 0, ascii); write( 0, 26, 50, 0, \u0026quot;scan_code: \u0026quot;); write_var( 0, 110, 50, 0, scan_code); while ( !key(_esc)) frame; end end  ","permalink":"https://divhub.github.io/pixtudio-website/docs/scan_code/","title":""},{"contents":" Definition Scancodes are used to identify keys. This is used in the function key() and the global variable scan_code. Note that the global variable ascii is very different from this.\nList | Constant | Value | | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- | \u0026mdash;\u0026mdash;- | | _ESC | 1 | | _1 | 2 | | _2 | 3 | | _3 | 4 | | _4 | 5 | | _5 | 6 | | _6 | 7 | | _7 | 8 | | _8 | 9 | | _9 | 10 | | _0 | 11 | | _MINUS | 12 | | _PLUS | 13 | | _BACKSPACE | 14 | | _TAB | 15 | | _Q | 16 | | _W | 17 | | _E | 18 | | _R | 19 | | _T | 20 | | _Y | 21 | | _U | 22 | | _I | 23 | | _O | 24 | | _P | 25 | | _L_BRACHET | 26 | | _R_BRACHET | 27 | | _ENTER | 28 | | _C_ENTER | 28 | | _CONTROL | 29 | | _A | 30 | | _S | 31 | | _D | 32 | | _F | 33 | | _G | 34 | | _H | 35 | | _J | 36 | | _K | 37 | | _L | 38 | | _SEMICOLON | 39 | | _APOSTROPHE | 40 | | _WAVE | 41 | | _L_SHIFT | 42 | | _BACKSLASH | 43 | | _Z | 44 | | _X | 45 | | _C | 46 | | _V | 47 | | _B | 48 | | _N | 49 | | _M | 50 | | _COMMA | 51 | | _POINT | 52 | | _SLASH | 53 | | _C_BACKSLASH | 53 | | _R_SHIFT | 54 | | _C_ASTERISK | 55 | | _PRN_SCR | 55 | | _ALT | 56 | | _SPACE | 57 | | _CAPS_LOCK | 58 | | _F1 | 59 | | _F2 | 60 | | _F3 | 61 | | _F4 | 62 | | _F5 | 63 | | _F6 | 64 | | _F7 | 65 | | _F8 | 66 | | _F9 | 67 | | _F10 | 68 | | _NUM_LOCK | 69 | | _SCROLL_LOCK | 70 | | _HOME | 71 | | _C_HOME | 71 | | _UP | 72 | | _C_UP | 72 | | _PGUP | 73 | | _C_PGUP | 73 | | _C_MINUS | 74 | | _LEFT | 75 | | _C_LEFT | 75 | | _C_CENTER | 76 | | _RIGHT | 77 | | _C_RIGHT | 77 | | _C_PLUS | 78 | | _END | 79 | | _C_END | 79 | | _DOWN | 80 | | _C_DOWN | 80 | | _PGDN | 81 | | _C_PGDN | 81 | | _INS | 82 | | _C_INS | 82 | | _DEL | 83 | | _C_DEL | 83 | | _F11 | 87 | | _F12 | 88 | | _LESS | 89 | | _EQUALS | 90 | | _GREATER | 91 | | _ASTERISK | 92 | | _R_ALT | 93 | | _R_CONTROL | 94 | | _L_ALT | 95 | | _L_CONTROL | 96 | | _MENU | 97 | | _L_WINDOWS | 98 | | _R_WINDOWS | 99 |\n","permalink":"https://divhub.github.io/pixtudio-website/docs/scancodes/","title":""},{"contents":" Definition INT screen_clear ( )\nClears the background of the screen, making it completely black.\nAlso called clear_screen().\nReturns INT : true\nNotes This is the same as '''[[map_clear]]'''(0,[[BACKGROUND]]). When the background is cleared in either way, Bennu knows the background is empty and will take advantage of this knowledge.\nErrors Unsupported color depth - The specified graph has a not supported color depth.\nCategory:functions Category:screen Category:mod_screen\n","permalink":"https://divhub.github.io/pixtudio-website/docs/screen_clear/","title":""},{"contents":" Definition INT screen_get ( )\nCreates a new graphic containing a copy of the lastly rendered frame.\nThe map will contain everything, including background, processes, drawings and text. Just like map_new(), the newly created graphic will be located in the System file (fileID of 0); the graphID will be returned. After the use of this graphic, it should be freed using map_unload().\nAlso called get_screen().\nReturns INT : GraphID\n0 - Some error. \u0026gt;0 - The GraphID of the graphic created.\nExample import \u0026quot;mod_key\u0026quot; import \u0026quot;mod_screen\u0026quot; import \u0026quot;mod_map\u0026quot; Global int my_map; End Process Main() Begin Repeat if(key(_F5)) my_map = screen_get(); png_save(0,my_map,\u0026quot;snapshot.PNG\u0026quot;); map_unload(0,my_map); while(key(_F5)) frame; end end frame; Until(key(_ESC)) End  Used in example: key(), screen_get(), png_save(), map_unload()\nCategory:functions Category:screen Category:mod_screen\n","permalink":"https://divhub.github.io/pixtudio-website/docs/screen_get/","title":""},{"contents":" Definition INT screen_put ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; )\nClears and draws (blits) a graph onto the background in the center.\nFor more advanced blitting, see:\n put() xput()  Also called put_screen().\nParameters INT fileID - The file that holds the graph. INT graphID - The graph to draw with.\nReturns INT\n0 - Invalid map. 1 - Success.\nNotes The center of the specified graph influences its placement.\nThe following codes are equivalent:\nscreen_put(f,g); screen_clear(); put(f,g,graphic_info(0,BACKGROUND,G_WIDTH)/2,graphic_info(0,BACKGROUND,G_HEIGHT)/2);  See screen_clear(), put() and map_info().\nErrors Invalid map - The specified map is invalid. Unsupported color depth - The origin graph\u0026rsquo;s color depth is greater than the destination graph\u0026rsquo;s.\nCategory:functions Category:screen Category:mod_screen\n","permalink":"https://divhub.github.io/pixtudio-website/docs/screen_put/","title":""},{"contents":" Definition STRUCT[9] Scroll\nScroll is a global variable struct array, containing information about the current state of the ten available scrolls (0..9). It is used to influence the settings of a scroll window, initiated by start_scroll().\nMembers of the scroll struct    Member name Description     INT x0 The X-coordinate of the foreground graphic.*   INT y0 The Y-coordinate of the foreground graphic.*   INT x1 The X-coordinate of the the background graphic.*   INT y1 The Y-coordinate of the the background graphic.*   INT z The Z-coordinate of the scroll window (default: 512).**   INT camera The processID of the process to be followed (default: 0).***   INT ratio The ratio in percent the foreground will move related to the background (default: 200).***,****   INT speed The maximum speed of the foreground, 0 for no limit (default: 0).***   INT region1 The region in which the scroll won\u0026rsquo;t move, -1 for none (default: -1).***   INT region2 The region in which the maximum speed is ignored, -1 for none (default: -1).***   INT flags1 The bit flags for the foreground graphic.   INT flags2 The bit flags for the background graphic.   INT follow The scrollID of the scroll window to follow, -1 means none (default: -1).   INT[6] reserved Seven reserved integers.             * These fields become read only when the scroll window is in automatic mode (see notes).   ** Processes on the scroll use this z value (see notes).   *** These fields only make sense when the scroll window is in automatic mode (see notes).   **** The ratio is in percent: 200 means the background moves twice as slow.    Notes There are two main methods of controlling a scroll window. One is the manual way, thus changing the values of the x0,y0,x1 and y1 manually. This mode is used when the camera field is not set (is 0). When it is set with a processID, the scroll window is in automatic mode and will follow that process\u0026rsquo; coordinates and will try to keep it centered. This can be influenced by other members of the scroll struct.\nThe foreground is the plane to be controlled and the background moves relative to the foreground. If you want to move the background manually, you first need to set the scroll ratio to 0.\nProcesses in a scroll take over the z value of that scroll\u0026rsquo;s z. Between processes on the same scroll the local variable z of that process does have the expected effect.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/scroll/","title":""},{"contents":" category:general category:scroll\nDefinition A scroll window is a region in which a scroll has been started by start_scroll() and setup with the global variable scroll. This scroll window provides a view window into the scroll that has been setup there, with certain background and foreground graphics. The view window can be \u0026lsquo;scrolled\u0026rsquo; over the scroll (and the graphics).\nThe use of scrolls can be various, but mostly they are used for scrolling games, like sidescrollers.\nProcesses can also be added to a scroll (see the global variable ctype), in which case a lot of things related to that process change.\n The graphic of the process is not drawn to the screen, but to the scroll window, using the region of the scroll. The z of an added process only has a meaning to the scroll window and compared to other processes added to the same scroll, meaning from a user perspective, the process is drawn at the z value of the scroll. If two processes are added to the same scroll, the one with the lower z value will be drawn over the other one. The x- and y-coordinates are not relative to the upper left corner of the screen, but relative to the upper left corner of the scroll.  You can control scrolls in multiple ways.\n Change the scroll coordinates directly using x0, y0, x1, y1 in the global variable scroll. Be sure to alter the correct scroll. Tell the scroll to \u0026lsquo;follow\u0026rsquo; another scroll, by using [[scroll]].follow. Use a \u0026lsquo;camera\u0026rsquo; process, which the scroll try to follow, by using [[scroll]].camera.  More about scrolls:\n A scroll with a lower z value will be drawn over a scroll with a lower z value. The foreground is the plane to be controlled and the background moves relative to the foreground.  Example Const SCREEN_WIDTH = 320; SCREEN_HEIGHT = 200; SCREEN_DEPTH = 8; MAP_WIDTH = 500; MAP_HEIGHT = 400; SHIP_WIDTH = 30; SHIP_HEIGHT = 30; SHIP_SPEED = 6; End Declare Process playership(int x, int y) End Declare Function int makeMap(int width, int height, int depth) End Declare Function int makeShipGfx(int width, int height, int depth) End Process Main() Private int map; Begin // Setup the screen set_mode(SCREEN_WIDTH,SCREEN_HEIGHT,SCREEN_DEPTH); // Create the background graphic map = makeMap(MAP_WIDTH,MAP_HEIGHT,SCREEN_DEPTH); // Start a new scroll // scrollNumber = 0 // fileID = 0 // foregroundGraphID = map // backgroundGraphID = 0: no background // region = 0: use entire screen // lockindicator = 0: don't repeat graphics start_scroll(0,0,map,0,0,0); // Start a controllable object on the scroll playership(320,200); // Wait till the key ESC is pressed Repeat frame; Until(key(_esc)) OnExit // Kill all other processes let_me_alone(); // Clean up memory used for map unload_map(0,map); End Process playership(int x, int y) Private int sp = SHIP_SPEED; int halfWidth; int halfHeight; Begin // This process should be displayed on a scroll only ctype = c_scroll; // This process should be tracked by the scroll Scroll.camera = id; // Create a graph for this process graph = makeShipGfx(SHIP_WIDTH,SHIP_HEIGHT,SCREEN_DEPTH); // Obtain the value of half the width of the graphic halfWidth = graphic_info(0,graph,G_WIDTH )/2; halfHeight = graphic_info(0,graph,G_HEIGHT)/2; // React on keys LEFT and RIGHT Loop // Adjust x,y on input x+=(key(_right)-key(_left))*sp; y+=(key(_down)-key(_up))*sp; // Make sure the ship stays on the scroll if(x \u0026gt; MAP_WIDTH-halfWidth) x = MAP_WIDTH-halfWidth; elseif(x \u0026lt; halfWidth) x = halfWidth; end if(y \u0026gt; MAP_HEIGHT-halfHeight) y = MAP_HEIGHT-halfHeight; elseif(y \u0026lt; halfHeight) y = halfHeight; end frame; End OnExit // Clean up used memory for graph unload_map(0,graph); End Function int makeMap(int width, int height, int depth) Private int n; int x1,y1; int m; Begin // New map m = new_map(width,height,depth); // Put on some pretty stars rand_seed(100); for(n=0;n\u0026lt;1000;n++) map_put_pixel(0,m,rand(0,width),rand(0,height),rgb(150,170,200)); end // Return it return m; End Function int makeShipGfx(int width, int height, int depth) Private int g; Begin // Return a map of one color (RGB(150,200,170)) g=new_map(width,height,depth); map_clear(0,g,rgb(200,100,170)); return g; End  Used in example: set_mode(), start_scroll(), key(), let_me_alone(), unload_map(), graphic_info(), new_map(), rand_seed(), rand(), rgb(), map_put_pixel(), map_clear(), ctype, scroll\n","permalink":"https://divhub.github.io/pixtudio-website/docs/scroll_window/","title":""},{"contents":" Definition Seek modes are used to specify the mode of seeking in a file, by passing one of them to the function fseek() as the parameter relativeness. The mode of seeking means to what position the seeking will be related to.\nList Constant - Value - Relative to SEEK_SET - 0 - The beginning of the file. This means just setting the position. SEEK_CUR - 1 - The current position. SEEK_END - 2 - The end of the file.\nCategory:constantcategories\n","permalink":"https://divhub.github.io/pixtudio-website/docs/seek_modes/","title":""},{"contents":" Definition INT set_channel_volume ( \u0026lt;INT channel\u0026gt; , \u0026lt;INT volume\u0026gt; )\nChange the reproduction volume of the wave sound channel. With this function, it is possible to set the channels to different volumes.\nParameters INT channel - The sound channel. INT volume - New volume. (0..128).\nReturns INT : Error.\n-1 - Error: sound inactive. 0 - No error.\nNotes This function changes the reproduction volume of the sound channel. The volume level can be set between 0 (silence) and 128 (original 100% volume of the track. The default volume is 128.\nCategory:functions Category:sound Category:mod_sound\n","permalink":"https://divhub.github.io/pixtudio-website/docs/set_channel_volume/","title":""},{"contents":" Definition INT set_distance ( \u0026lt;INT channel\u0026gt; , \u0026lt;INT distance\u0026gt; )\nSet the \u0026ldquo;distance\u0026rdquo; of a sound channel. the distance specifies the location of the sound in relation to the listener. If you want also want to have control over the angle, see Set_position().\nParameters INT channel - The sound channel to change the position of. INT distance - The distance (0-255).\nReturns INT : Status.\n0 - Ok. -1 - Error: sound inactive.\nNotes Distance value\u0026rsquo;s\n0 - The sound is near (or at it\u0026rsquo;s loudest). 255 - The sound is far away (very quite).\nCategory:functions Category:sound Category:mod_sound\n","permalink":"https://divhub.github.io/pixtudio-website/docs/set_distance/","title":""},{"contents":" Definition INT set_fps ( \u0026lt;INT fps\u0026gt; , \u0026lt;INT skip\u0026gt; )\nSets the frames per second (framerate) your program aims to display. The more frames per second, the faster your program runs. Some computers might not be able to display the amount of frames you specified, and will show a lower fps. Therefore, it is important you choose a fps that is reasonable and can also be displayed by the somewhat slower computers. If you don\u0026rsquo;t use this function then the default fps will be used (25 fps).\nParameters INT fps - Frames per second to use. The default is 25. INT skip - Frames the program is allowed to skip to keep up with the specified framerate if it\u0026rsquo;s running low on processor time. The default is 0.\nReturns INT : The FPS entered.\nNotes If you use Set_fps(0,0), then your program will run at the maximum speed your computer can possibly handle.\nThe current FPS can be read from the global variable fps.\nErrors None.\nExample Program test; Begin Set_fps(60,0); Loop Frame; End End  Category:functions Category:programinteraction Category:mod_video\n","permalink":"https://divhub.github.io/pixtudio-website/docs/set_fps/","title":""},{"contents":" Definition INT set_icon ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; )\nSet the window icon to a certain graph.\nThe icon will only be updated after set_mode() is called, so call set_icon() before set_mode(). The map used for the icon must be 32x32 large, but it can have different depths. After set_icon() and set_mode() have been called, the map used for the icon can be freed from memory using unload_map().\nParameters INT fileID - The fileID of the file containing the graph. INT graphID - The graphID of the graph to be used as an icon.\nReturns INT : true\nExample import \u0026quot;mod_key\u0026quot; import \u0026quot;mod_map\u0026quot; import \u0026quot;mod_wm\u0026quot; import \u0026quot;mod_video\u0026quot; Const screen_width = 320; screen_height = 200; screen_depth = 16; End Process Main() Private int map; int iconsize = 32; Begin set_mode(screen_width,screen_height,screen_depth); map = new_map(iconsize,iconsize,screen_depth); map_clear(0,map,rgb(0,255,255)); set_title(\u0026quot;\u0026lt;-- Look at the cyan block!\u0026quot;); set_icon(0,map); unload_map(0,map); Repeat frame; Until(key(_ESC)||exit_status) End  Used in example: set_mode(), new_map(), map_clear(), rgb(), set_title(), set_icon(), unload_map(), key(), exit_status\nCategory:functions Category:programinteraction Category:mod_wm\n","permalink":"https://divhub.github.io/pixtudio-website/docs/set_icon/","title":""},{"contents":" Syntax INT set_mode ( \u0026lt;INT width\u0026gt; , \u0026lt;INT height\u0026gt; , [\u0026lt;INT depth\u0026gt;] , [\u0026lt;INT flags\u0026gt;] )\nDescription Sets the screen resolution of your program, and optionally the colordepth of the screen and any render flags for extra options. If this command is not used, the default settings will take effect (320x240 at 32 bpp).\nSome much used resolutions are: 320x240, 640x480, 800x600, 1024x768 and 1280x1024.\nParameters INT width - Width of the screen in pixels. INT height - Height of the screen in pixels. INT [depth] - Color depth of the screen. See color_depths. INT [flags] - Mode of rendering. See render flags.\nReturns INT : -1: error, setting the mode has failed INT : 0: sucess\nINT : true (in versions prior rc282)\nNotes Any fpg files you load must have the same or a lower colordepth as you set for the screen.\nUncommon resolutions can also be used, for example 399x10, which will be the actual size of the window if you run in windowed mode. At full screen black edges might appear.\nThere is another method of calling set_mode(): with one parameter. In this parameter you must use the 4 right digits for the height and the rest fot the width. For example to set a 320x200 mode you can use set_mode(3200200). The maximum height that allow this method is 9999 pixels. This method is deprecated and its use is disadvised.\nExample import \u0026quot;mod_video\u0026quot; import \u0026quot;mod_key\u0026quot; import \u0026quot;mod_wm\u0026quot; Process Main() Begin set_mode(640,480,16); Repeat frame; Until(key(_ESC)||exit_status) End  Used in example: set_mode(), key(), exit_status\nCategory:functions Category:programinteraction Category:mod_video\n","permalink":"https://divhub.github.io/pixtudio-website/docs/set_mode/","title":""},{"contents":" Definition INT set_music_position ( \u0026lt;FLOAT position\u0026gt; )\nSet the position of the currently playing music, loaded with Load_song() and played with Play_song() It only works with the formats supported by those functions. It does not apply to wave files.\nParameters FLOAT position - Jumps to position seconds from the beginning of the song.\nReturns INT : Status.\nposition - The position in the music. -1 - Error: sound inactive.\nCategory:functions Category:sound Category:mod_sound\n","permalink":"https://divhub.github.io/pixtudio-website/docs/set_music_position/","title":""},{"contents":" Definition INT set_panning ( \u0026lt;INT channel\u0026gt; , \u0026lt;INT left\u0026gt; , \u0026lt;INT right\u0026gt; )\nSets the stereo panning of a sound channel, i.e. set the volumes of the left and right speakers individually.\nParameters INT channel - The sound channel to change the panning of. INT left - The volume of the left speaker (0-255). INT right - The volume of the right speaker (0-255).\nReturns INT : Status.\n0 - Ok. -1 - Error: sound inactive.\nCategory:functions Category:sound Category:mod_sound\n","permalink":"https://divhub.github.io/pixtudio-website/docs/set_panning/","title":""},{"contents":" Definition INT set_position ( \u0026lt;INT channel\u0026gt; , \u0026lt;INT angle\u0026gt; , \u0026lt;INT distance\u0026gt; )\nSets the position of a sound channel. With this function you can \u0026ldquo;emulate\u0026rdquo; a simple 3d audio effect. If you only want to control the distance, you can use Set_distance().\nParameters INT channel - The sound channel to change the position of. INT angle - The angle (0-360). INT distance - The distance (0-255).\nReturns INT : Status.\n0 - Ok. -1 - Error: sound inactive.\nNotes Angle value\u0026rsquo;s\n0 degrees - Sound is directly in front. 90 degrees - Sound is directly to the right. 180 degrees - Sound is directly behind. 270 degrees - Sound is directly to the left.\nDistance value\u0026rsquo;s\n0 - The sound is near (or at it\u0026rsquo;s loudest). 255 - The sound is far away (very quite).\nCategory:functions Category:sound Category:mod_sound\n","permalink":"https://divhub.github.io/pixtudio-website/docs/set_position/","title":""},{"contents":" Definition INT set_song_volume ( \u0026lt;INT volume\u0026gt; )\nChange the reproduction volume of the music track.\nWith this function, it is possible to set the background music to a different volume than the sound effects, etc.\nParameters INT volume - New volume. (0..128).\nReturns INT : Error.\n-1 - Error: sound inactive. 0 - No error.\nNotes This function changes the reproduction volume of the music track. The volume level can be set between 0 (silence) and 128 (original 100% volume of the track. The default volume is 128.\nExample program music_example; global my_song; playing; paused; faded_in; v; begin set_mode(640,480,16); my_song=load_song(\u0026quot;beat.ogg\u0026quot;); write(0,320,30,4,\u0026quot;Use the keyboard to control the music playback.\u0026quot;); write(0,320,50,4,\u0026quot;Key [ENTER] starts / stops the song.\u0026quot;); write(0,320,60,4,\u0026quot;Key [SPACE] pauses / resumes the song.\u0026quot;); write(0,320,70,4,\u0026quot;Key [0] through key [9] changes the song volume.\u0026quot;); write(0,320,80,4,\u0026quot;Key [F] fades the song in or out.\u0026quot;); write(0,320,120,5,\u0026quot;Playing: \u0026quot;); write_int(0,320,120,3,\u0026amp;playing); write(0,320,140,5,\u0026quot;Paused: \u0026quot;); write_int(0,320,140,3,\u0026amp;paused); write(0,320,160,5,\u0026quot;Faded in: \u0026quot;); write_int(0,320,160,3,\u0026amp;faded_in); write(0,320,180,5,\u0026quot;Volume: \u0026quot;); write_int(0,320,180,3,\u0026amp;v); v=128; faded_in=true; repeat if(key(_enter)) if(is_playing_song()) stop_song(); playing=false; else play_song(my_song,1); playing=true; end while(key(_enter))frame;end end if(key(_space)) if(paused) paused=false; resume_song(); else paused=true; pause_song(); end while(key(_space))frame;end end if(key(_f)) if(faded_in) faded_in=false; fade_music_off(100); else faded_in=true; fade_music_in(my_song,1,100); end while(key(_f))frame;end end if(key(_0))v=0;end if(key(_1))v=14;end if(key(_2))v=28;end if(key(_3))v=43;end if(key(_4))v=57;end if(key(_5))v=71;end if(key(_6))v=85;end if(key(_7))v=100;end if(key(_8))v=114;end if(key(_9))v=128;end set_song_volume(v); frame; until(key(_esc)) exit(); end  Used in example: key(), set_mode(), load_song(), write(), write_int(), pause_song(), play_song(), stop_song(), resume_song(), fade_music_in(), fade_music_off(), set_song_volume().\nCategory:functions Category:sound Category:mod_sound\n","permalink":"https://divhub.github.io/pixtudio-website/docs/set_song_volume/","title":""},{"contents":" Definition INT set_text_color ( [INT \u0026lt; textID\u0026gt;] , \u0026lt;WORD color\u0026gt; )\nSets the current text color (the color where texts will be written in). This only affects 1 bit (2 color) fonts, which can be loaded with load_font() or load_bdf(). 8 bit and 16 bit fonts already contain color information themselves and thus aren\u0026rsquo;t affected.\nParameters INT textID - The identification code of the text (optional). WORD color - The color to use for text.\nReturns INT : true if successful and false if failed. (Needs confirmation.)\nVOID: in version rc282 this function returns nothing.\nNotes Be warned that values returned by the Rgb() function differ with the video card. So, directly filling out color numbers as color parameter in 16 bit color mode without using Rgb() is a bad idea, as RGB returns the correct color code for every video card\nThe optional argument textID is fairly new. It is introduced in version rc282.\nErrors None.\nExample Program awesome; Global byte red=0; byte green=255; byte blue=0; Begin set_text_color(rgb(red,green,blue)); write(0,1,1,0,\u0026quot;Mijn potlood is bruin\u0026quot;); //this text will be green as an Irishman's ejecta set_text_color(rgb(255,0,0)); write(0,1,11,0,\u0026quot;Je moeder\u0026quot;); //this text will be red Loop frame; End End  Used in example: write(), rgb()\nThis results in something like this:\nExample 2 import \u0026quot;mod_text\u0026quot;; import \u0026quot;mod_mouse\u0026quot;; import \u0026quot;mod_key\u0026quot;; import \u0026quot;mod_video\u0026quot;; import \u0026quot;mod_rand\u0026quot;; import \u0026quot;mod_map\u0026quot;; private txt[10]; counter; tz; begin set_mode(640,480,32); txt[0]=write_int(0,10,10,10,0,\u0026amp;counter); txt[1]=write_int(0,10,20,-5,0,\u0026amp;tz); txt[2]=write(0,10,10,0,0,\u0026quot;hello world\u0026quot;); set_text_color(txt[1], rgb(255,0,0)); while(!key(_ESC)) counter++; move_text(txt[2], mouse.x, mouse.y, tz ); set_text_color(txt[0], rand(0101010h, 0ffffffh)); if ( key( _DOWN ) ) tz--; end if ( key( _UP ) ) tz++; end frame; end end  Used in example: write(), write_int(), rgb(), key(), set_mode(), move_text()\nCategory:functions Category:texts Category:mod_text\n","permalink":"https://divhub.github.io/pixtudio-website/docs/set_text_color/","title":""},{"contents":" Definition INT set_title ( \u0026lt;STRING title\u0026gt; )\nSets the title of the program\u0026rsquo;s window.\nThe title will only be updated after set_mode() is called, so call set_title() before set_mode().\nParameters STRING title - The new title for the program\u0026rsquo;s window.\nReturns INT : true\nExample Program icon; Private int map; int screen_width = 320; int screen_height = 200; int screen_depth = 8; int iconsize = 32; Begin map = new_map(iconsize,iconsize,screen_depth); map_clear(0,map,rgb(0,255,255)); set_icon(0,map); set_title(\u0026quot;\u0026lt;-- Look at the cyan block!\u0026quot;); set_mode(screen_width,screen_height,screen_depth); unload_map(0,map); Repeat frame; Until(key(_esc)) End  Used in example: new_map(), map_clear(), set_icon(), set_mode, unload_map(), key()\nCategory:functions Category:programinteraction Category:mod_wm\n","permalink":"https://divhub.github.io/pixtudio-website/docs/set_title/","title":""},{"contents":" Syntax INT set_wav_volume ( \u0026lt;INT waveID\u0026gt; , \u0026lt;INT volume\u0026gt; )\nDescription Change the reproduction volume of the wav track.\nWith this function, it is possible to set the volume of the sound effects, etc.\nParameters INT waveID - waveID as returned by load_wav(). INT volume - New volume. (0..128)\nReturns (assumed) INT : Error.\n-1 - Error: sound inactive. 0 - No error.\nNotes This function changes the reproduction volume of the wav track. The volume level can be set between 0 (silence) and 128 (original 100% volume of the track. The default volume is 128.\nExample global int my_wav; int v; end process main() begin set_mode(640,480,16); my_wav = load_wav(\u0026quot;beat.wav\u0026quot;); write(0,320,30,4,\u0026quot;Use the keyboard to control the music playback.\u0026quot;); write(0,320,50,4,\u0026quot;Key [ENTER] starts the wav.\u0026quot;); write(0,320,60,4,\u0026quot;Key [0] through key [9] changes the song volume.\u0026quot;); write(0,320,180,5,\u0026quot;Volume: \u0026quot;); write_int(0,320,180,3,\u0026amp;v); v = 128; repeat if(key(_ENTER)) play_wav(my_wav,50); while(key(_ENTER)) frame; end end if(key(_0)) v = 0; end if(key(_1)) v = 14; end if(key(_2)) v = 28; end if(key(_3)) v = 43; end if(key(_4)) v = 57; end if(key(_5)) v = 71; end if(key(_6)) v = 85; end if(key(_7)) v = 100; end if(key(_8)) v = 114; end if(key(_9)) v = 128; end set_wav_volume(v); frame; until(key(_ESC)) end  Used in example: key(), set_mode(), load_wav(), write(), write_int(), play_wav().\nThis example uses media: beat.wav\nCategory:functions Category:sound Category:mod_sound\n","permalink":"https://divhub.github.io/pixtudio-website/docs/set_wav_volume/","title":""},{"contents":"Up to Tutorialcategories\nSetting up Bennu.\n category=setting up Bennu resultsfooter = \\n%PAGES% articles about setting up Bennu mode=userformat listseparators = ,\\n* %TITLE%,, redirects = include noresultsfooter = No pages about setting up Bennu here yet. \n(If you require an editor it is recommended to follow instructions for Setting up Bennu with ConTEXT)\nCategory:tutorialcategories Category:setting up Bennu\n","permalink":"https://divhub.github.io/pixtudio-website/docs/setting_up_bennu/","title":""},{"contents":"","permalink":"https://divhub.github.io/pixtudio-website/docs/setting_up_bennu_on_windows/","title":""},{"contents":" category:variables category:predefined category:global variables category:mod_key\nUp to Global Variables\nDefinition INT shift_status\nShift_status is defined in the module mod_key and indicates whether a modifier key is being pressed. If more than a modifier key is pressed at the same time shift_status will return the sum.\nList Key - Value Right Control - 20 * Left Control - 36 Right Alt - 72 * Left Alt - 136 NUM LOCK - 256 CAPS LOCK - 512 Right Shift - 1025 Left Shift - 1026\n* At the time of the writing of this article, right alt and right control didn't return anything. It is unknown whether it is a bug or just deprecated.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/shift_status/","title":""},{"contents":" Definition SHORT or WORD\nShorts or Words are whole numbers ranging from 0 to 2\\^16-1 ( 0 to 65535 ). This is because a short or word uses 16 bits (2 bytes) to denote its value.\nCategory:language Category:datatypes\n","permalink":"https://divhub.github.io/pixtudio-website/docs/short/","title":""},{"contents":" Definition INT signal ( \u0026lt;INT processID|processTypeID\u0026gt; , \u0026lt;INT signal\u0026gt; )\nAllows a process/function or a range of processes/functions of certain processType to be controlled in a limited number of ways, by sending signals.\nParameters INT processID|processTypeID - The ProcessID of the process or the ProcessTypeID of the type of processes to send the signal to. INT signal - The signal that is to be sent to the target process(es).\nReturns INT :\nfalse - The specified processID|processTypeID was ALL_PROCESS or a processTypeID. true - The specified processID|processTypeID was a processID.\nErrors Invalid signal - The specified signal is invalid.\nNotes To obtain the processType of a function, the operator Type can be used. For a process to send a signal to itself, the local variable id can be used. The parameter signal is passed by way of a set of signals which denote the signal to be sent. The parameter signal is one of the listed signals. To kill all processes at once, except the calling one, use let_me_alone().\nTo send a signal to all processes at once, except the calling one, use signal([[ALL_PROCESS]],signal).\nTo specify how a process reacts on an incoming signal, use signal_action().\nA signal is carried out immediately, but this does not mean execution of processes is switched to the process, if you just woke it up. This can be achieved by using [[frame]](0); after the signal. A frame will cause Bennu to continue execution with the process having the lowest frame-percentage done and it will only continue execution with the current process after all other processes have had their turn. Moreover, using a frame-percentage of 0 will make sure there is nothing added to the done frame-percentage of the process, meaning it doesn\u0026rsquo;t affect the framerate of the process.\nExample signal( get_id(type enemy) , s_kill ); // Kills a process of type enemy. // Becareful! If there is no enemy process alive, // get_id() will return 0, which means signal() // will signal all processes. signal( id , s_kill_tree ); // Kills the process that calls it, and all of its descendants signal( Type player , s_freeze ); // Freezes all processes of type player so that they are // still displayed, but do not execute any code. signal(ALL_PROCESS,s_freeze); // Freezes all processes except the one that called it. // Can be used to pause a game. signal( someID , S_WAKEUP ); frame(0); // Wake up the process someID and let it execute once // (if not done this frame) before continuing.  Category:functions Category:processinteraction Category:mod_proc\n","permalink":"https://divhub.github.io/pixtudio-website/docs/signal/","title":""},{"contents":" Definition INT signal_action ( [\u0026lt;INT processID|processTypeID\u0026gt; , ] INT signal , INT action )\nSets the reaction of one or more processes when they receive a certain nonforceful-signal. Only existing processes are affected, processes created afterwards are not.\nParameters INT processID|processTypeID - A ProcessID,ProcessTypeID or ALL_PROCESS. INT signal - The code of a nonforceful-signal for which a reaction is to be specified. INT action - The reaction of the process when it receives a signal. (S_DFL/S_IGN)\nReturns INT : true\nNotes The reaction to an incoming forced signal (S_KILL_FORCE, S_SLEEP_FORCE, etc) cannot be changed and is S_DFL by default.\nExample // The current process ignores the kill signal from now on signal_action(S_KILL,S_IGN); // All currently existing processes ignore the kill signal from now on signal_action(ALL_PROCESS,S_KILL,S_IGN); // All currently existing processes of type 'Player' ignore the freeze signal from now on signal_action(type Player,S_FREEZE,S_IGN);  Category:functions Category:processinteraction Category:mod_proc\n","permalink":"https://divhub.github.io/pixtudio-website/docs/signal_action/","title":""},{"contents":" Definition Signal actions are modes which indicate how a process should react to a signal.\nSee signal_action().\nList Constant - Value - Meaning S_DFL - 0 - Signal is received and will be reacted upon (default). S_IGN - 1 - Signal is ignored.\nCategory:constantcategories\n","permalink":"https://divhub.github.io/pixtudio-website/docs/signal_actions/","title":""},{"contents":" Description Signals are used to specify the signal to be sent to a process or all processes of a processType, by passing one of them to the function signal() as the signal parameter. The reaction a process has on an incoming signal can be influenced by signal_action().\nList Constant - Value - Description S_KILL - 0 - Kill the process. S_WAKEUP - 1 - Wakeup the process. S_SLEEP - 2 - Put the process to sleep. S_FREEZE - 3 - Freeze the process. S_KILL_FORCE - 50 - Kill the process forcefully. S_WAKEUP_FORCE - 51 - Wakeup the process forcefully. S_SLEEP_FORCE - 52 - Put the process to sleep forcefully. S_FREEZE_FORCE - 53 - Freeze the process forcefully. S_KILL_TREE - 100 - Kill the process and all its connected descendants. S_WAKEUP_TREE - 101 - Wakeup the process and all its connected descendants. S_SLEEP_TREE - 102 - Put the process and all its connected descendants to sleep. S_FREEZE_TREE - 103 - Freeze the process and all its connected descendants. S_KILL_TREE_FORCE - 150 - Kill the process and all its connected descendants forcefully. S_WAKEUP_TREE_FORCE - 151 - Wakeup the process and all its connected descendants forcefully. S_SLEEP_TREE_FORCE - 152 - Put the process and all its connected descendants to sleep forcefully. S_FREEZE_TREE_FORCE - 153 - Freeze the process and all its connected descendants forcefully.\nA descendant is connected when all its ascendants up until the process are still alive.\nNote: The constants S_FORCE, S_TREE and ALL_PROCESS are for internal use only.\nMore info General  S_KILL - Order to kill the process. The process will not appear in the following frames of the game any longer. If the process has an onexit part, it is executed in the same frame as the process was killed. S_WAKEUP - Order to wake up the process. It returns a slept or frozen process to its normal state. The process will be executed and displayed again from the moment that it recieves theis signal normally. A process that has been killed cannot be returned to its normal state by this method (or at all). S_SLEEP - Order to make the process dormant. The process will remain paralyzed, without executing its code and without being displayed on screen (nor being detected by other processes), as if it had been killed. But the process will continue to exist in the computer\u0026rsquo;s memory. S_FREEZE - Order to freeze the process. The process will remain motionless without running its code. But it will continue to be displayed on screen and it will be possible to detect it (in the collisions) by the rest of the processes. The process will continue to exist in the computers memory even if its code is not executed.  Tree In addition to these there are the following signals that have the same effect, but affect a range of processes, not just a single process:\n S_KILL_TREE S_WAKEUP_TREE S_SLEEP_TREE S_FREEZE_TREE  These will have the effect of their non-tree counterparts, but will affect the process indicated by the processID|processTypeID parameter and all of the processes created by those processes, either directly, or indirectly. So if an S_KILL_TREE signal is sent to a process, that process will die, all of the processes that it created will die, and all of the processes that they created will die, and so on. The exception to this is where there is an orphan process, that is a process to whose father is already dead, because the grandfather process of the orphaned process cannot know the orphaned process is a descendant of his.\nForcefully All normal (=non forced) signals have a forceful equivalent, meaning they get carried out whether the target process ignores it or not:\n S_KILL_FORCE S_WAKEUP_FORCE S_SLEEP_FORCE S_FREEZE_FORCE S_KILL_TREE_FORCE S_WAKEUP_TREE_FORCE S_SLEEP_TREE_FORCE S_FREEZE_TREE_FORCE  Normal incoming signals can be influenced by signal_action(), but these signals cannot be influenced. This means that sending a process S_KILL_FORCE it will be killed.\nCategory:constantcategories\n","permalink":"https://divhub.github.io/pixtudio-website/docs/signals/","title":""},{"contents":"This applies to variables holding integer values (int, word, byte, etc).\nSignedness is a property of variables representing integer numbers. A signed variable can represent both negative values and positive values (and zero of course). An unsigned variable can only represent zero and positive values.\nWhile signed numbers can represent negative numbers, they lose a range of larger numbers which can only be represented with unsigned numbers of the same size (in bits). This is because in signed variables, roughly half the possible values are negative values. Unsigned variables can dedicate all the possible values to the positive number range.\nE.g. the [[int]] in Bennu is a signed datatype, which can range from -2147483648 to 2147483647. Its unsigned counterpart is the unsigned datatype [[dword]] (or unsigned int). This datatype ranges from 0 to 4294967295.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/signedness/","title":""},{"contents":" Definition FLOAT sin ( \u0026lt;FLOAT angle\u0026gt; )\nReturns the sine of the specified angle.\nThis function performs a sine calculation on a certain angle and returns a value between -1 and 1.\nParameters FLOAT angle - Angle, in thousandths of degrees. i.e. 75000 = 75º\nReturns FLOAT : The sine result of the specified angle.\nNotes The angle value used in this function should be in thousandths of degrees, as most angles within Bennu are.\nTo read about all aspects of trigonometry, you can click on Wikipedia\u0026rsquo;s Trigonometric function page.\nExample Const screen_width = 320; screen_height = 200; screen_border = 15; End Global float value; End Process Main() Begin // Modes set_title(\u0026quot;Sine Graph\u0026quot;); set_mode(screen_width,screen_height); // X axis for(x=1;x\u0026lt;=8;x++) write( 0, screen_border+x*(screen_width-screen_border)/8+3, screen_height-1, 8, itoa(x*360/8 )+\u0026quot;^\u0026quot; ); end draw_line(1,screen_height-screen_border,screen_width,screen_height-screen_border); // Y axis write(0,screen_border-1,20,5,\u0026quot;1\u0026quot;); write(0,screen_border-1,screen_height/2,5,\u0026quot;0\u0026quot;); write(0,screen_border-1,screen_height-20,5,\u0026quot;-1\u0026quot;); draw_line(screen_border,1,screen_border,screen_height-1); // Draw tangent for(angle=0;angle\u0026lt;360;angle++) value=sin(angle*1000)*(screen_height/2-20); put_pixel( screen_border+angle*(screen_width-screen_border)/360, screen_height/2-value, rgb(255,255,255) ); // screen_height/2-value because the screen's origin (0,0) is topleft instead of downleft. end Repeat frame; Until(key(_ESC)) End  Used in example: set_title(), set_mode(), write(), draw_line(), sin(), put_pixel(), key()\nThis will result in something like:\nCategory:functions Category:math Category:mod_math\n","permalink":"https://divhub.github.io/pixtudio-website/docs/sin/","title":""},{"contents":" category:variables category:predefined category:local variables category:librender\nUp to Local Variables\nDefinition INT size = 100\nSize is a predefined local variable that can be used to stretch or compress a graphic, equally along the horizontal axis and vertical axis. It is defined as a percentage of the original graphic size. The graphics\u0026rsquo;s center will remain at the drawing coordinates when the graphic is drawn.\nThis variable only has effect for the appearance of a process\u0026rsquo; graphic when its local variables size_x and size_y are both 100. When either is not equal to 100, size doesn\u0026rsquo;t affect the appearance of the graphic.\nExample To make the graphic of a process continually stretch:\nProcess Main() Begin graph = new_map(50,50,8); // Create a new graphic x = 100; // Position the graphic 100 pixels y = 100; // from the top and left of the screen Loop size += 1; // Increase the height and width of the graphic by 1 percent each frame. frame; End OnExit unload_map(0,graph); End  Used in example: new_map(), x, y, size, unload_map()\nSee also  size_x size_y  ","permalink":"https://divhub.github.io/pixtudio-website/docs/size/","title":""},{"contents":" category:variables category:predefined category:local variables category:librender\nUp to Local Variables\nDefinition INT size_x = 100\nSize_x is a predefined local variable that can be used to stretch or compress a graphic along its horizontal axis. It is defined as a percentage of the original graphic size. The graphics\u0026rsquo;s center will remain at the drawing coordinates when the graphic is drawn.\nWhen either size_x or size_y of a process are unequal to [code]100[/code], that process\u0026rsquo; size has no effect.\nExample To make the graphic of a process continually stretch horizontally:\nProcess Main() Begin graph = new_map(50,50,8); // Create a new graphic x = 100; // Position the graphic 100 pixels y = 100; // from the top and left of the screen Loop size_x += 1; // Increase the width of the graphic by 1 percent each frame. frame; End OnExit unload_map(0,graph); End  Used in example: new_map(), [[x], y, size_x, unload_map()\nSee also  size size_y  ","permalink":"https://divhub.github.io/pixtudio-website/docs/size_x/","title":""},{"contents":" category:variables category:predefined category:local variables category:librender\nUp to Local Variables\nDefinition INT size_y = 100\nSize_y is a predefined local variable that can be used to stretch or compress a graphic along its vertical axis. It is defined as a percentage of the original graphic size. The graphics\u0026rsquo;s center will remain at the drawing coordinates when the graphic is drawn.\nWhen either size_x or size_y of a process are unequal to [code]100[/code], that process\u0026rsquo; size has no effect.\nExample To make the graphic of a process continually stretch vertically:\nProcess Main() Begin graph = new_map(50,50,8); // Create a new graphic x = 100; // Position the graphic 100 pixels y = 100; // from the top and left of the screen Loop size_y += 1; // Increase the height of the graphic by 1 pixel each frame. frame; End OnExit unload_map(0,graph); End  Used in example: new_map(), [[x], y, size_y, unload_map()\nSee also  size size_x  ","permalink":"https://divhub.github.io/pixtudio-website/docs/size_y/","title":""},{"contents":" Syntax INT sizeof ( {datatype} )  Description Calculates the size of a block of memory. Returns the size in bytes.\nParameters  {datatype} - The type, i.e. any valid bennu datatypes. Can also be a user defined types or structs.  Returns INT : The size of the data type, in bytes.\nDefinition The sizeof() operator is used to calculate the size of datatypes. This is important for creating dynamic data structures wich are created with the functions alloc(), calloc() and realloc(). These three functions allocate space in bytes. For instance, an int in bennu is 4 bytes long. When dealing with data structures of self-defined types, it can be tedious to calculate the exact size manually. But this is not the only reason, for instance, when a linked list is created, the struct may be changed by the programmer, and in that case the size changes. By using sizeof(), you can avoid the problems of allocating too few or too much space.\nFurther reading General article about the use of sizeof\nExample  // import modules IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_mem\u0026quot;; // user defined data type, should be 29 bytes in size. TYPE custom_datatype; int cat; int dog; byte kind; char name[19]; END GLOBAL STRUCT custom_datatype2; char name[19]; STRUCT animal[9]; char remarks[255]; int age; int speed; byte kind; byte fur_color; byte sound; byte num_legs; bool can_fly; bool has_horns; END END int var1; // 4 bytes byte var2; // 1 byte float var3; // 4 bytes char text1[4]=\u0026quot;hello\u0026quot;; // 5 bytes string text2=\u0026quot;world\u0026quot;; // 4 bytes, is sort of pointer thingy int integer_array[255]; // (0-255), 256 x 4 bytes = 1024 bytes PROCESS main(); BEGIN say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;sizeof() demonstration\u0026quot;); say(\u0026quot;\u0026quot;); say(\u0026quot;\u0026quot;); say (\u0026quot;the size of custom_datatype: \u0026quot;+sizeof(custom_datatype)+\u0026quot; is bytes\u0026quot;); say (\u0026quot;the size of custom_datatype2: \u0026quot;+sizeof(custom_datatype2)+\u0026quot; is bytes\u0026quot;); say (\u0026quot;the size of var1: \u0026quot;+sizeof(var1)+\u0026quot; is bytes\u0026quot;); say (\u0026quot;the size of var2: \u0026quot;+sizeof(var2)+\u0026quot; is bytes\u0026quot;); say (\u0026quot;the size of var3: \u0026quot;+sizeof(var3)+\u0026quot; is bytes\u0026quot;); say (\u0026quot;the size of text1: \u0026quot;+sizeof(text1)+\u0026quot; is bytes\u0026quot;); say (\u0026quot;the size of text2: \u0026quot;+sizeof(text2)+\u0026quot; is bytes\u0026quot;); say (\u0026quot;the size of int_array: \u0026quot;+sizeof(integer_array)+\u0026quot; is bytes\u0026quot;); END  Used in example: alloc(), calloc(), realloc(), struct, type, say(), Global\n","permalink":"https://divhub.github.io/pixtudio-website/docs/sizeof/","title":""},{"contents":" category:variables category:predefined category:local variables category:internal\nUp to Local Variables\nDefinition INT smallbro\nSmallbro is a predefined local variable. Smallbro holds the ProcessID of the process/function that was immediately called after by the father of the current process/function. There are several other local variables which refer to the ProcessID of a related process:\n Father Son Bigbro  ","permalink":"https://divhub.github.io/pixtudio-website/docs/smallbro/","title":""},{"contents":" category:variables category:predefined category:local variables category:internal\nUp to Local Variables\nDefinition INT son\nSon is a predefined local variable. Son holds the ProcessID of the process/function that was last called by the current process/function. There are several other local variables which refer to the ProcessID of a related process:\n Father Bigbro Smallbro  ","permalink":"https://divhub.github.io/pixtudio-website/docs/son/","title":""},{"contents":" Definition SongID\nA SongID is an identifier associated with a certain song loaded by load_song(). The identifier can be used in various other functions, like unload_song() to unload the song.\nCategory:general\n","permalink":"https://divhub.github.io/pixtudio-website/docs/songid/","title":""},{"contents":" Syntax INT sort ( \u0026lt;VARSPACE array\u0026gt; , [\u0026lt;INT datacount\u0026gt;] )\nDescription Sorts an array by sorting a certain number of elements, by using the first variable in each element. By default the whole array is sorted.\nIf the elements contain multiple variables, ksort() can be used to select the variable to be used for sorting. For more advanced sorting, look at quicksort().\nParameters VARSPACE array - The array to be sorted. [INT datacount] - Number of elements to sort.\nReturns INT: Successrate\ntrue - Sorting succeeded. false - Sorting failed. Look in the output for the error.\nExample import \u0026quot;mod_sort\u0026quot;; import \u0026quot;mod_key\u0026quot;; import \u0026quot;mod_say\u0026quot;; Type _player String name; int score; End Const maxplayers = 5; End; Process main() Private _player player[maxplayers-1]; int i=0; Begin // Insert some values player[0].name = \u0026quot;That one bad looking dude\u0026quot;; player[1].name = \u0026quot;Ah pretty lame guy\u0026quot;; player[2].name = \u0026quot;Some cool dude\u0026quot;; player[3].name = \u0026quot;OMG ZOMG guy\u0026quot;; player[4].name = \u0026quot;This person is ok\u0026quot;; player[0].score = 70; player[1].score = 30; player[2].score = 80; player[3].score = 90; player[4].score = 50; // Show array say(\u0026quot;-------------------- unsorted\u0026quot;); for(i=0; i\u0026lt;maxplayers; i++) say(player[i].name + \u0026quot; - \u0026quot; + player[i].score); end /* Sort by name ( quicksort() can't be used to sort Strings, as a String in Bennu is a pointer to the actual String, so it would sort the pointer addresses */ // sort() sort(player); // sorts by name because name is the first variable in each element // Show array say(\u0026quot;-------------------- name - sort()\u0026quot;); for(i=0; i\u0026lt;maxplayers; i++) say(player[i].name + \u0026quot; - \u0026quot; + player[i].score); end // ksort() ksort(player,player[0].name,maxplayers); // Show array say(\u0026quot;-------------------- name - ksort()\u0026quot;); for(i=0; i\u0026lt;maxplayers; i++) say(player[i].name + \u0026quot; - \u0026quot; + player[i].score); end /* Sort by score (sort() cannot be used here, because score is not the first variable) */ // ksort() ksort(player,player[0].score,maxplayers); // Show array say(\u0026quot;-------------------- score - ksort()\u0026quot;); for(i=0; i\u0026lt;maxplayers; i++) say(player[i].name + \u0026quot; - \u0026quot; + player[i].score); end // quicksort() quicksort(\u0026amp;player[0],sizeof(_player),maxplayers,sizeof(String),sizeof(int),0); // Show array say(\u0026quot;-------------------- score - quicksort()\u0026quot;); for(i=0; i\u0026lt;maxplayers; i++) say(player[i].name + \u0026quot; - \u0026quot; + player[i].score); end End  Used in example: say(), sort(), ksort(), quicksort(), type, array, pointer\nCategory:functions Category:sorting Category:mod_sort\n","permalink":"https://divhub.github.io/pixtudio-website/docs/sort/","title":""},{"contents":" category:variables category:predefined category:global variables category:mod_sound\nUp to Global Variables\nDefinition INT sound_channels = 8\nSound_channels is a global variable, holding the number of sound channels, which is set when sound is used for the first time, meaning altering the value of this variable will have no effect after sound has been initialized. This number can range from 1 to 32 and the default is 8.\nSee also  sound_mode sound_freq  ","permalink":"https://divhub.github.io/pixtudio-website/docs/sound_channels/","title":""},{"contents":" Definition VOID sound_init ( )\nManually Closes the audio system. This is normally not needed, but may be necessary on some systems with SDL mixer issues. It is used in combination with Sound_init(). (verification needed)\nParameters This function has no parameters.\nReturns VOID : This function does not return anything.\nSee also Sound_init()\nCategory:functions Category:sound Category:mod_sound\n","permalink":"https://divhub.github.io/pixtudio-website/docs/sound_close/","title":""},{"contents":" category:variables category:predefined category:global variables category:mod_sound\nUp to Global Variables\nDefinition INT sound_freq = 22050\nSound_freq is a global variable, holding the set sound frequency, which is set when sound is used for the first time, meaning altering the value of this variable will have no effect after sound has been initialized. The higher the frequency, the higher the quality is. Accepted frequencies are:\n 44100: high quality (recommended) 22050: medium quality (default) 11025: low quality (not recommended)  See also  sound_mode sound_channels  ","permalink":"https://divhub.github.io/pixtudio-website/docs/sound_freq/","title":""},{"contents":" Definition INT sound_init ( )\nManually Initializes the audio system. This is normally not needed, but may be necessary on some systems with SDL mixer issues. (verification needed)\nParameters This function has no parameters.\nReturns INT : Status/error.\n0 - The audio device is opened. -1 - There\u0026rsquo;s an error, failed to initialize the audio system.\nSee also Sound_close()\nCategory:functions Category:sound Category:mod_sound\n","permalink":"https://divhub.github.io/pixtudio-website/docs/sound_init/","title":""},{"contents":" category:variables category:predefined category:global variables category:mod_sound\nUp to Global Variables\nDefinition INT sound_mode = MODE_STEREO\nSound_mode is a global variable, holding the set sound mode, which is set when sound is used for the first time, meaning altering the value of this variable will have no effect after sound has been initialized. The mode can be changed by assigning a different mode to the variable. Default is MODE_STEREO.\nSee also  graph_mode sound_freq sound_channels  ","permalink":"https://divhub.github.io/pixtudio-website/docs/sound_mode/","title":""},{"contents":" Definition Sound modes are used to set the sound mode, by assigning one of them to the global variable sound_mode. Currently the choice is between monotone sound and stereo sound.\nList Constant - Value - Description MODE_MONO - 0 - Use monotone sound. MODE_STEREO - 1 - Use stereo sound.\nCategory:constantcategories\n","permalink":"https://divhub.github.io/pixtudio-website/docs/sound_modes/","title":""},{"contents":" Syntax INT split ( \u0026lt;STRING delimiter\u0026gt; , \u0026lt;STRING str\u0026gt; , \u0026lt;STRING POINTER array\u0026gt; , \u0026lt;INT max_number\u0026gt; )\nDescription Splits a string in several strings using a regular expression as delimiter.\nThe first piece will go to array[0], the second to array[1], and so forth, until either there are no more pieces left or max_number pieces are returned into the array. The number of pieces returned this way is returned by the function.\nParameters STRING delimiter - The regular expression used as delimiter to split. STRING str - The input string to split into multiple string. STRING POINTER array - Pointer to the string array where the pieces will be returned to. INT max_number - The maximum number of strings to return.\nReturns INT : The number of pieces returned into the array.\nExample import \u0026quot;mod_say\u0026quot; import \u0026quot;mod_regex\u0026quot; Process Main() Private string str = \u0026quot;A,B,C,D,E\u0026quot;; string a[9]; int n; int i; Begin // Split n = split(\u0026quot;,\u0026quot;,str,\u0026amp;a,10); // Display result say(\u0026quot;Number of pieces: \u0026quot; + n); for(i=0; i\u0026lt;n; i++) say(\u0026quot;[\u0026quot; + i + \u0026quot;] = \u0026quot; + a[i]); end End  Used in example: split(), say()\nCategory:functions Category:mod_regex\n","permalink":"https://divhub.github.io/pixtudio-website/docs/split/","title":""},{"contents":" Definition FLOAT sqrt ( \u0026lt;FLOAT value\u0026gt; )\nReturns the square root of a certain value.\nParameters FLOAT value - The value of which the square root will be returned.\nReturns FLOAT : The square root of value.\nCategory:functions Category:math Category:mod_math\n","permalink":"https://divhub.github.io/pixtudio-website/docs/sqrt/","title":""},{"contents":" You do not have to feel obligated, but please try to keep your article according to following standards, so that we can get a homogenic look. The standards are quite natural and will appear logical when followed. Different sections contain different information; below are three general section which are mostly used.\nAlso look at these:\n Standards:function Standards:variable Standards:names  Note that in practice you don\u0026rsquo;t need to look at these standards. Just copy the wikicode of the function example or variable_example and edit its content. When you are unsure about something, you can always refer to it.\nDefinition This is the name of the function, process, variable, \u0026hellip; , and also, probably, the name of the article. Before the name is the datatype of the variable or of what the function returns.\nHere is some general information such as what the function\u0026rsquo;s or variable\u0026rsquo;s purpose, or a specific dll you need. Notice the white line, indicating a sort of separate section.\nNotes Some more in depth information about the subject, if needed. The kind of information not needed for normal use, but more like \u0026ldquo;doing it like so is bad or doing it like that is good\u0026rdquo;.\nExample A simple example using the function (between \u0026lt;pre\u0026gt; tags). Please do not use links in your code, but refer to the keywords beneath the code in a list, if needed. Only include relevant keywords, i.e. do not link to every possible reserved word. The example doesn\u0026rsquo;t have to be advanced or big, on the contrary, simple examples are better.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/standards/","title":""},{"contents":" REDIRECT Standards:function  ","permalink":"https://divhub.github.io/pixtudio-website/docs/standards_function/","title":""},{"contents":" Up to Standards\nClick here to get the template for this standard.\nClick here to get an example of this standard.\nDon't forget to add it to a category, like \u0026quot;local variables\u0026quot;, or \u0026quot;predefined variables\u0026quot;, or combinations. Always add it to the category \u0026quot;variables\u0026quot;: [[category:variables]] When internally linking to variables, just put \u0026quot;[[]]\u0026quot; around the name, like: [[father]]  Definition VariableType VariableName\nVariableName is for yadayada.\nThe main usage and functionality of the variable.  Notes Don\u0026rsquo;t set it to blablabla.\nWarnings, tips, etc.  Example VariableName = 100; An example showing the usage of the variable.  Category:Standards\n","permalink":"https://divhub.github.io/pixtudio-website/docs/standards_variable/","title":""},{"contents":" Definition INT Start_scroll ( \u0026lt;INT scrollnumber\u0026gt; , \u0026lt;INT fileID\u0026gt; , \u0026lt;INT graphID\u0026gt; , \u0026lt;INT backgroundgraphID\u0026gt; , \u0026lt;INT regionnumber\u0026gt; , \u0026lt;INT lockindicator\u0026gt; , [ \u0026lt;INT destination fileID \u0026gt;, \u0026lt;INT destination graphID \u0026gt; ] )\nThis creates a scroll window in which it will perform a view against a background graphic. That is, by using a graphic bigger than the display window, a part of this graphic can be shown and shifted in any direction. After this function, the use of the struct scroll makes sense.\nThe parameters destination fileID and destination graphID are optional and may be omitted.\nAlso called scroll_start().\nParameters INT scrollnumber - The ID for the new scroll window, so it can be referenced to later INT fileID - The fileID of the file containing the scroll graphics INT graphID - The graphID of the graphic of the main graphic to be scrolled INT backgroundgraphID - The graphID of the graphic for the background of the scroll window INT regionnumber - The region in which to put the scroll window INT lockindicator - A bit flag defining whether each of the two scroll planes is horizontally/vertically cyclical INT destination flileID - The fileID of the file containing the destination graphics used in the scroll window, i.e. the systemfile. (optional) INT destination graphID - The graphID of the graphic of the destination graphic where the scroll window will be drawn on. (optional)\nReturns INT : true\nNotes The locking indicator can be combinations of the following flags:\n1 - The foreground will be displayed horizontally cyclical 2 - The foreground will be displayed vertically cyclical 4 - The background will be displayed horizontally cyclical 8 - The background will be displayed vertically cyclical\nCombine them using the bitwise OR operator.\nUsing Scrolling For each process that you want to be part of a scroll window, you must set the local variable ctype to value C_SCROLL. It should also be noted that the local variable c_number is used for selecting in which scroll a process should be displayed. Additionally, you must set the camera property of the scroll structure to the processID of the process you wish to be followed.\nExample (scroll drawn on map) In this example, a scroll is drawn on a map, so the advanced version with the parameters destination fileID and destination graphID are used.\n// import modules IMPORT \u0026quot;mod_say\u0026quot;; IMPORT \u0026quot;mod_debug\u0026quot;; IMPORT \u0026quot;mod_proc\u0026quot;; IMPORT \u0026quot;mod_grproc\u0026quot;; IMPORT \u0026quot;mod_map\u0026quot;; IMPORT \u0026quot;mod_text\u0026quot;; IMPORT \u0026quot;mod_key\u0026quot;; IMPORT \u0026quot;mod_video\u0026quot;; IMPORT \u0026quot;mod_screen\u0026quot;; IMPORT \u0026quot;mod_draw\u0026quot;; IMPORT \u0026quot;mod_scroll\u0026quot;; GLOBAL int graphics_lib; int object1_id; int scroll_window; int scroll_blit_graph; PROCESS int main(); PRIVATE BEGIN set_mode(640,480,8); set_fps(50,0); // load the fpg file with the graphics graphics_lib=load_fpg(\u0026quot;graf2.fpg\u0026quot;); // create a map to blit the scroll window on scroll_blit_graph=new_map(640,480,8); // display the \u0026quot;scroll_blit_graph\u0026quot;. blit_graph(); // (standard version) // int start_scroll (int scrollnumber, // int file, // int graph, // int backgroundgraph, // int regionnumber, // int lockindicator); // (advanced, extended version) // int start_scroll (int scrollnumber, // int file, // int graph, // int backgroundgraph, // int regionnumber, // int lockindicator, // int destination file, // int destination graph); // create an extended scroll, drawn on the \u0026quot;scroll_blit_graph\u0026quot;. scroll_window=start_scroll(0,graphics_lib,1,0,0,3,0,scroll_blit_graph); say(\u0026quot;scroll_window status: \u0026quot;+scroll_window); // create the two objct processes. object1_id=object1(graphics_lib); // write instructions write(0 ,20,30,ALIGN_CENTER_LEFT,\u0026quot;Scroll extended (with destination map) test demo, instructions\u0026quot;); write(0 ,20,40,ALIGN_CENTER_LEFT,\u0026quot;F3 and F4: decrease/increase size of destination map\u0026quot;); write(0 ,20,50,ALIGN_CENTER_LEFT,\u0026quot;F5 and F6: decrease/increase angle of destination map\u0026quot;); write(0 ,20,60,ALIGN_CENTER_LEFT,\u0026quot;F7 and F8: decrease/increase x of destination map\u0026quot;); write(0 ,20,70,ALIGN_CENTER_LEFT,\u0026quot;F9 and F10: decrease/increase y of destination map\u0026quot;); WHILE (NOT key(_esc)) FRAME; END // stop scroll window. stop_scroll(0); // kill all processes, execpt the \u0026quot;main\u0026quot; process. let_me_alone(); END PROCESS int object1 (int file); PRIVATE BEGIN graph=3; ctype=c_scroll; cnumber=c_0; // make this process visible in window 0 scroll[0].camera=id; x=100; y=100; LOOP // move main object IF (key(_up) AND y \u0026gt;0) y-=5; END IF (key(_down) AND y \u0026lt;800) y+=5; END IF (key(_left) AND x \u0026gt;0) x-=5; END IF (key(_right) AND x \u0026lt;2000) x+=5; END FRAME; END END // Process for handling the \u0026quot;destination graph\u0026quot; feature, i.e. the map on wich // the mode7 windows are drawn. PROCESS int blit_graph(); PRIVATE BEGIN x=320; y=240; ctype=c_screen; file=0; graph=scroll_blit_graph; // set the graph to the map created in memory. LOOP // the controls for the \u0026quot;fancy stuff\u0026quot;. IF (key(_f3) AND size \u0026gt;20) size-=10; END IF (key(_f4) AND size \u0026lt;1000) size+=10; END IF (key(_f5) AND angle \u0026gt;0) angle-=100; END IF (key(_f6) AND angle \u0026lt;360000) angle+=100; END IF (key(_f7) AND x \u0026gt;0) x-=10; END IF (key(_f8) AND x \u0026lt;1000) x+=10; END IF (key(_f9) AND y \u0026gt;0) y-=10; END IF (key(_f10) AND y \u0026lt;1000) y+=10; END FRAME; END END  Category:functions Category:scrolls Category:mod_scroll\n","permalink":"https://divhub.github.io/pixtudio-website/docs/start_scroll/","title":""},{"contents":" Definition INT Stop_scroll ( \u0026lt;INT scrollnumber\u0026gt;)\nThis functions stops an active scroll window. There can be up to 10 (0-9) scroll windows active. When the scroll is stopped, all the processes in it will no longer be displayed. This function is usefull for switching the game\u0026rsquo;s state from active gameplay to a loading screen state or similair situations. Another use is, when there are multiple scroll regions active, and the game changes from split screen to single screen. This way you can have individual control over the display of the scroll.\nAlso called scroll_stop().\nParameters INT scrollnumber - The ID for the scroll window to be stopped\nReturns INT : true\nExample IMPORT \u0026quot;mod_video\u0026quot;; IMPORT \u0026quot;mod_map\u0026quot;; IMPORT \u0026quot;mod_scroll\u0026quot;; IMPORT \u0026quot;mod_screen\u0026quot;; IMPORT \u0026quot;mod_key\u0026quot;; IMPORT \u0026quot;mod_proc\u0026quot;; GLOBAL int graphics; PROCESS main(); BEGIN graphics=load_fpg(\u0026quot;help.fpg\u0026quot;); say(\u0026quot;Press [ENTER] to activate the scroll window.\u0026quot;); say(\u0026quot;Press [SPACE] to stop the scroll.\u0026quot;); LOOP IF (scan_code==_space) stop_scroll(0); // The scroll is stopped. END IF (scan_code==_enter) start_scroll(0, 0, 103, 102, 0, 15); END FRAME; END END  Using Scrolling For each process that you want to be part of a scroll window, you must set the local variable ctype to value C_SCROLL. It should also be noted that the local variable c_number is used for selecting in which scroll a process should be displayed. Additionally, you must set the camera property of the scroll structure to the processID of the process you wish to be followed.\nCategory:functions Category:scrolls Category:mod_scroll\n","permalink":"https://divhub.github.io/pixtudio-website/docs/stop_scroll/","title":""},{"contents":" Definition INT stop_song ( )\nStops a song loaded with load_song() and played with play_song().\nParameters This function has no parameters.\nReturns INT : Status\n0 - The song is stopped.\nCategory:functions Category:sound Category:mod_sound\n","permalink":"https://divhub.github.io/pixtudio-website/docs/stop_song/","title":""},{"contents":" Definition INT stop_wav ( INT )\nStops a the playback of sound of the indicated wave sound channel.\nParameters \u0026rsquo; INT\u0026rsquo; channel: the sound channel.\nReturns INT : Status\n-1 - There is an error.\nCategory:functions Category:sound Category:mod_sound\n","permalink":"https://divhub.github.io/pixtudio-website/docs/stop_wav/","title":""},{"contents":" Definition INT strcasecmp( \u0026lt;STRING str1\u0026gt; , \u0026lt;STRING str2\u0026gt; )\nCompares two strings case-insensitive and returns the result.\nParameters STRING str1 - The first string. STRING str2 - The second string, to compare with the first string.\nReturns INT: difference\n0 - The strings are equal. \u0026gt;0 - The ASCII value of the first differing characters is higher for str1. \u0026lt;0 - The ASCII value of the first differing characters is higher for str2.\nNotes If the strings differ, the ASCII difference between the first differing characters of the strings is actually returned. Let i be the index of the differing characters, then what is returned: ''str1''[''i'']-''str2''[''i''].\nExample import \u0026quot;mod_string\u0026quot; import \u0026quot;mod_say\u0026quot; Const AB = \u0026quot;AB\u0026quot;; ABC = \u0026quot;ABC\u0026quot;; CD = \u0026quot;CD\u0026quot;; CD2 = \u0026quot;CD\u0026quot;; End Process Main() Begin say(\u0026quot;strcasecmp(AB,ABC) = \u0026quot; + strcasecmp(AB,ABC)); say(\u0026quot;strcasecmp(AB,CD) = \u0026quot; + strcasecmp(AB,CD)); say(\u0026quot;strcasecmp(CD,AB) = \u0026quot; + strcasecmp(CD,AB)); say(\u0026quot;strcasecmp(CD,CD2) = \u0026quot; + strcasecmp(CD,CD2)); End  Used in example: say(), strcasecmp()\nResult:\nstrcasecmp(AB,ABC) = -67 strcasecmp(AB,CD) = -2 strcasecmp(CD,AB) = 2 strcasecmp(CD,CD2) = 0  Category:functions Category:strings Category:mod_string\n","permalink":"https://divhub.github.io/pixtudio-website/docs/strcasecmp/","title":""},{"contents":" Definition STRING\nStrings are a sort of character array, combining characters to form text. Because the length of a string is dynamic, adding them is done easily. Single and double quotes can be used to create strings.\nExample  Program strings; Private String name; String surname; Begin name = \u0026quot;Yo\u0026quot;; surname = \u0026quot;Momma\u0026quot;; say(name + \u0026quot; \u0026quot; + surname + \u0026quot; has entered.\u0026quot;); say('User logged on: \u0026quot;' + name + \u0026quot; \u0026quot; + surname + '\u0026quot;'); Repeat frame; Until(key(_ESC)) End  Used in example: say(), key()\nNotes There are some things to be aware of with strings of the \u0026ldquo;string\u0026rdquo; data type:\n Do not manually allocate data structures with strings in them (more specifically, don\u0026rsquo;t use alloc()/calloc()/realloc() and free() on them). Do not use memmove() or memcopy() on string variables or structures/arrays containing them. PixTudio strings are integer identifiers, so using sizeof with them is pointless, as it will always return the size of an int. This is because bennu creates it\u0026rsquo;s own internal database for strings, and therefore it is simply an identifier. Internally, the string data itself is a character array delimited with a NULL character, just like an ANSI / C string. The memory for these strings is managed by bennu, thus manual memory operations on them can cause harm on bennu\u0026rsquo;s internal string managment. All local/private/public strings are automatically released (freed) when processes/functions die or exit.  However, if you want to do some manual memory managment on strings you can:\n Create a simple character array yourself.  If you want to create a string list:\n You can create a linked list of processes using their Father and Son fields to create the links. Use textfiles. Create on big string in combination with an array that contains information about substrings. Create an array of character arrays.  ","permalink":"https://divhub.github.io/pixtudio-website/docs/string/","title":""},{"contents":" Definition STRING strrev ( \u0026lt;STRING str\u0026gt; )\nReturns a reversed version of a certain string, meaning the characters are in reversed order.\nParameters STRING str - The non reversed string.\nReturns STRING : The reversed string.\nCategory:functions Category:strings Category:mod_string\n","permalink":"https://divhub.github.io/pixtudio-website/docs/strrev/","title":""},{"contents":" Definition Struct {struct name} {Members} End  Structs are datatypes able to contain variables of all datatypes.\nTo address a member of a struct, use the . operator: {structname}.{membername}. Like all datatypes, one can have a whole range of them, as displayed in the example (also see Array).\nThere are two ways to fill a struct on declaration:\n Per member Afterwards, like Arrays.  See the examples on how to do it.\nExample Structs can be handy for many aspects of programming.\nGrouping of variables This is for clarity and to avoid colliding variable names.\n Struct Fileinfo String name; String path; End  Note that the struct fileinfo is a predefined global variable.\nMaybe you want to group some other data, like settings of the screen:\n Struct Window int width = 320; int height = 200; int depth = 8; End  or (using other initializing syntax):\n Struct Window int width; int height; int depth; End = 320,200,8;  This example can also be done by defining your own type.\nMultiple identical data groups  Struct Ship[9] int x; int y; int speed; int angle; End  There are 10 Ships now. The data can be accessed like:\n Ship[0].speed++; Ship[8].angle = 0;  ","permalink":"https://divhub.github.io/pixtudio-website/docs/struct/","title":""},{"contents":" Definition A subroutine is a program segment that can be called and used by any other bit of the program. So basically, if there\u0026rsquo;s something that you want to do quite a lot in your program, then you can write a subroutine for it and then just call this subroutine every time you want to to that.\nIn PixTudio this is achieved by the use of functions and processes\n","permalink":"https://divhub.github.io/pixtudio-website/docs/subroutine/","title":""},{"contents":" Syntax INT substr ( \u0026lt;STRING str\u0026gt; , \u0026lt;INT startposition\u0026gt; , [\u0026lt;INT characters\u0026gt;] )\nDescription Returns a subsection of a certain string.\nParameters STRING str - The string of which a subsection will be returned. INT startposition - The position of the first character to be in the subsection. [INT characters] - The number of characters the subsection will hold. Negative values are special; see Notes.\nReturns STRING : The subsection.\nNotes If the number of characters is a negative value, the following applies: the start of the subsection will be startposition; the end of the subsection will be the length of the string minus the absolute value of characters.\nExample Private String str = \u0026quot;This is my string.\u0026quot;; Begin // No specified number of characters say( substr(str,2) + \u0026quot;\u0026lt;\u0026quot; ); // \u0026quot;is is my string.\u0026quot; say( substr(str,-7) + \u0026quot;\u0026lt;\u0026quot; ); // \u0026quot;string.\u0026quot; // Specified number of characters say( substr(str,5,2) + \u0026quot;\u0026lt;\u0026quot; ); // \u0026quot;is\u0026quot; // Number of characters greater than length of string say( substr(str,2,50) + \u0026quot;\u0026lt;\u0026quot; ); // \u0026quot;is my string.\u0026quot; say( substr(str,-7,50) + \u0026quot;\u0026lt;\u0026quot; ); // \u0026quot;string.\u0026quot; // Negative number of characters say( substr(str,5,-5) + \u0026quot;\u0026lt;\u0026quot; ); // \u0026quot;is my st\u0026quot; // Special case say( substr(str,0,0) + \u0026quot;\u0026lt;\u0026quot; ); // \u0026quot;\u0026quot;, but pre 0.92: \u0026quot;This is my string.\u0026quot; Repeat frame; Until(key(_ESC)) End  Used in example: say(), key()\nCategory:functions Category:strings Category:mod_string\n","permalink":"https://divhub.github.io/pixtudio-website/docs/substr/","title":""},{"contents":" Syntax Switch ( \u0026lt;value\u0026gt; ) ( Case \u0026lt;value\u0026gt; : [ \u0026lt;code\u0026gt; ] End ) [ Default: [ \u0026lt;code\u0026gt; ] End ] End\nDescription A switch is used to control the flow of a program by means of comparing a value to other values and executing the code associated with the correct value.\nswitch ( \u0026lt;value\u0026gt; ) case \u0026lt;value1\u0026gt;: // code1 end case \u0026lt;value2\u0026gt;: // code2 end default: // code3 end end  When the switch is reached it will compare value with the values in the cases, going from top to bottom. When a case matches, that code is executed and the switch is exited. This is different from the switch in C and probably more languages, because there the switch is only exited when a break is reached or when the switch ends. In Bennu there is no break; for the switch, though.\nA value in a case can also be a range: \u0026lt;lowervalue\u0026gt;..\u0026lt;uppervalue\u0026gt;. Both the lowervalue and the uppervalue are part of the range.\nYou can also specify multiple values in a case, separated by a comma: \u0026lt;value1\u0026gt;,\u0026lt;value2\u0026gt;,...\u0026lt;code\u0026gt;. These values can also be ranges.\nExample A scoretext function. Notice the default: when the points can be 0..100, that code should never be executed. However, an error can occur and blurting an error to the user is not that fancy, so this is a way of showing to the programmer there is an error, but still the user gets some message. In such cases, default can be handy. Of course that code could just as easily have been put under the switch with the same result, in this case, because every case does a return.\nFunction String scoretext( int points ) Begin Switch( points ) Case 100: return \u0026quot;Perfect!\u0026quot;; End Case 90..100: return \u0026quot;Awesomely cool, dude!\u0026quot;; End Case 80..90: return \u0026quot;You're getting the hang of it!\u0026quot;; End Case 60..80: return \u0026quot;Not too shabby, mate.\u0026quot;; End Case 50..60: return \u0026quot;Practice some more.\u0026quot;; End Case 30..50: return \u0026quot;Dude...weak.\u0026quot;; End Case 1..30: return \u0026quot;That's just awful\u0026quot;; End Case 0: return \u0026quot;No points? n00b!\u0026quot;; End Default: return \u0026quot;I dunno what you did, but...\u0026quot;; End End End  ","permalink":"https://divhub.github.io/pixtudio-website/docs/switch/","title":""},{"contents":" Description The system file is like a regular file, but it contains on the fly created graphics. These graphics are for example created by map_new(), map_clone() or write_in_map().\nThe system file can be accessed using 0 as the fileID. While this file can also be a file loaded from disc, the graphics in that file all have a graphID below 1000. Graphics created on the fly have graphID\u0026rsquo;s 1000 or above.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/system_file/","title":""},{"contents":" Definition FLOAT tan ( \u0026lt;FLOAT angle\u0026gt; )\nReturns the tangent of a certain angle.\nThis function performs a tangent calculation on a certain angle and returns a value.\nParameters FLOAT angle - Angle, in thousandths of degrees. i.e. 75000 = 75º\nReturns FLOAT : The tangent result of the specified angle.\nNotes The angle value used in this function should be in thousandths of degrees, as most angles within Bennu are.\nTo read about all aspects of trigonometry, you can visit Wikipedia\u0026rsquo;s Trigonometric function page.\nExample Const screen_width = 320; screen_height = 200; screen_border = 15; End Global float value; End Process Main() Begin // Modes set_title(\u0026quot;Tangent Graph\u0026quot;); set_mode(screen_width,screen_height); // X axis for(x=1;x\u0026lt;=8;x++) write( 0, screen_border+x*(screen_width-screen_border)/8+3, screen_height-1, 8, itoa(x*360/8 )+\u0026quot;^\u0026quot; ); end draw_line(1,screen_height-screen_border,screen_width,screen_height-screen_border); // Y axis write(0,screen_border-1,20,5,\u0026quot;1\u0026quot;); write(0,screen_border-1,screen_height/2,5,\u0026quot;0\u0026quot;); write(0,screen_border-1,screen_height-20,5,\u0026quot;-1\u0026quot;); draw_line(screen_border,1,screen_border,screen_height-1); // Draw tangent for(angle=0;angle\u0026lt;360;angle++) value=tan(angle*1000)*(screen_height/2-20); put_pixel( screen_border+angle*(screen_width-screen_border)/360, screen_height/2-value, rgb(255,255,255) ); // screen_height/2-value because the screen's origin (0,0) is topleft instead of downleft. end Repeat frame; Until(key(_ESC)) End  Used in example: set_title(), set_mode(), write(), draw_line(), tan(), put_pixel(), key()\nThis will result in something like:\nCategory:functions Category:math Category:mod_math\n","permalink":"https://divhub.github.io/pixtudio-website/docs/tan/","title":""},{"contents":"Templates:  namespace=Template mode=userformat listseparators = ,\\n* %TITLE%,, \n","permalink":"https://divhub.github.io/pixtudio-website/docs/templates/","title":""},{"contents":" category:general category:texts\nDefinition A text is a text written on screen with texts functions, like write() or write_int(). A text is addressed using the associated TextID.\nThere are two kinds of texts:\n Static text is any text written with write(); it is static, because the content of the text cannot be changed after writing, but the text can be moved and deleted. Dynamic text is any text written with write_xxx() functions; it is dynamic because the content of the text always reflects the current value of the variable specified. Of course moving and deleting is also possible.  Writing texts There are multiple ways to write texts: the write() function, write_xxx() functions and the write_in_map() function. With the first two, some the global variable text_z is important and with all three of them, the following are important:\n The functions set_text_color() and get_text_color() The font The alignment The global variable text_flags  Also the function move_text() can be handy, as it moves a previously written text to a different location.\nExample Program texts; Const maxtexts = 10; Private int textid[maxtexts-1]; string str; float flt; Begin // Set FPS set_fps(60,0); // Init text settings: text_z = 0; text_flags = 0; set_text_color(rgb(255,255,255)); // Write some texts textid[0] = write(0,0,0,0,\u0026quot;FPS:\u0026quot;); textid[1] = write_int(0,30,0,0,\u0026amp;fps); textid[2] = write_string(0,160,95,1,\u0026amp;str); textid[3] = write_float(0,160,105,0,\u0026amp;flt); // Show z workings set_text_color(rgb(50,150,150)); textid[4] = write(0,20,20,0,\u0026quot;Underlying text\u0026quot;); text_z = -1; set_text_color(rgb(255,255,255)); textid[5] = write(0,22,22,0,\u0026quot;On top text\u0026quot;); // Update the texts until ESC is pressed Repeat // Notice the texts get updated as the values of str and flt changes. // The same goes for the value of fps. str = \u0026quot;This program is running for \u0026quot; + time()/100 + \u0026quot; seconds.\u0026quot;; flt = (float)time()/100; frame; Until(key(_esc)); // Delete the texts (this section would be good for OnExit) for(x=0; x\u0026lt;maxtexts; x++) if(textid[x]!=0) delete_text(textid[x]); end end End  Used in example: set_fps(), set_text_color(), write(), write_int(), write_string(), write_float(), key(), delete_text(), text_z, text_flags, fps\n","permalink":"https://divhub.github.io/pixtudio-website/docs/text/","title":""},{"contents":" category:predefined category:libtext\nUp to Global Variables\nDefinition INT text_flags = 0\nText_flags is a global variable. When a dynamic text is created (write(), etc), its flags value will equal the value of text_flags at the moment of creation. The default value is 0.\nSee also  text_z TextID  Category:variables Category:global variables\n","permalink":"https://divhub.github.io/pixtudio-website/docs/text_flags/","title":""},{"contents":" Definition INT text_height ( \u0026lt;INT fontID\u0026gt; , \u0026lt;STRING text\u0026gt; )\nCalculates the height in pixels of the specified text in the specified font.\nParameters INT FontID - FontID of the font for which the height of the text will be the calculated. STRING text - The text of which the height will be calculated.\nReturns INT : The height in pixels of the text in the font.\n0 - Invalid or no text; invalid font. \u0026gt;0 - The height in pixels of the text in the font.\nSee also  text_width()  Category:functions Category:texts Category:mod_text\n","permalink":"https://divhub.github.io/pixtudio-website/docs/text_height/","title":""},{"contents":" Definition INT text_width ( \u0026lt;INT fontID\u0026gt; , \u0026lt;STRING text\u0026gt; )\nCalculates the width in pixels of the specified text in the specified font.\nParameters INT FontID - FontID of the font for which the width of the text will be the calculated. STRING text - The text of which the width will be calculated.\nReturns INT : The width in pixels of the text in the font.\n0 - Invalid or no text; invalid font. \u0026gt;0 - The width in pixels of the text in the font.\nSee also  text_height()  Category:functions Category:texts Category:mod_text\n","permalink":"https://divhub.github.io/pixtudio-website/docs/text_width/","title":""},{"contents":" category:predefined category:libtext\nUp to Global Variables\nDefinition INT text_z = -256\nText_z is a global variable. When a dynamic text is created (write(), etc), its z value will equal the value of text_z at the moment of creation. The default value is -256.\nSee also  z text_flags TextID  Category:variables Category:global variables\n","permalink":"https://divhub.github.io/pixtudio-website/docs/text_z/","title":""},{"contents":" category:general category:texts\nDefinition TextID\nTextID is an identifier associated with a certain text. It is returned by various text functions, like write(), write_int(), write_string(), write_float() and move_text().\nWhen a dynamic text is created, it has the color last set by set_text_color(). By default this is white (rgb(255,255,255)). Its Z value is equal to text_z at the moment of creation, which is -256 by default.\nTo move the dynamic text associated with a TextID, use move_text(). To delete the text, use delete_text(). There can be a total of 512 dynamic texts on screen simultaneously.\nSee also  Text Text functions  ","permalink":"https://divhub.github.io/pixtudio-website/docs/textid/","title":""},{"contents":" Syntax INT time ( )\nDescription Returns the current time, in seconds from January 1st, 1970.\nThis function is mostly useful for the function ftime(), to display time and date in a particular format. It is also useful in rand_seed(), to have \u0026lsquo;more randomness\u0026rsquo;.\nReturns INT : The current time, in seconds from January 1st, 1970.\nExample import \u0026quot;mod_time\u0026quot; import \u0026quot;mod_timer\u0026quot; import \u0026quot;mod_text\u0026quot; import \u0026quot;mod_key\u0026quot; Process Main(); Private String timestring; // The string holding the formatted time Begin write_string(0,0,0,0,\u0026amp;timestring); // Display the timestring timer = 100; // Make it so it updates the timestring immediately Repeat if(timer\u0026gt;100) // Update the timestring every 1 second timer = 0; timestring = ftime(\u0026quot;%d-%m-%Y %H:%M:%S\u0026quot;,time()); end frame; Until(key(_esc)) End  Used in example: write_string(), ftime(), key(), timer\nCategory:functions Category:time Category:mod_time\n","permalink":"https://divhub.github.io/pixtudio-website/docs/time/","title":""},{"contents":" category:variables category:predefined category:global variables category:time category:mod_timers\nUp to Global Variables\nDefinition INT[9] timer\nTimer is a global variable, holding ten integers. Each frame a certain value is added to all of them. This value is the difference in time between the start of the last frame and the current frame, in 1\u0026frasl;100 seconds.\nSo when all the timers are never altered, their values will be 1234 when the program has been running for about 12.34 seconds.\nExamples Display how long the program has been running import \u0026quot;mod_timers\u0026quot; import \u0026quot;mod_key\u0026quot; import \u0026quot;mod_text\u0026quot; Process Main() Begin write_int(0,0,100,0,\u0026amp;timer[0]); Repeat frame; Until(key(_ESC)) End  Used in example: write_int(), key(), timer\nThis can be done more accurately with the use of frame_time, which is in milliseconds.\nLet a process wait for a certain time by calling this function Function int wait(int t) Begin t += timer[0]; While(timer[0]\u0026lt;t) frame; End return t-timer[0]; End  This can be done without a timer too, as is displayed here.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/timer/","title":""},{"contents":" Up to Modules\nDescription Description for TinyXML module. Work in progress\nHow to use Category:modules Category:3rd party Category:TinyXML\n","permalink":"https://divhub.github.io/pixtudio-website/docs/tinyxml.dll/","title":""},{"contents":" Fixing existing pages Lot of things to do, but luckily they are pretty easy.\nThings to be done:\n Every reference to \u0026ldquo;Fenix\u0026rdquo; needs to be adjusted and altered to \u0026ldquo;Bennu\u0026rdquo;. Code must be adjusted to import modules. Function, locals, globals, constants, etc in modules need to have their module navbox at the bottom of the page, like:  {{Moduledocbox | module = Mod_math }}   The old style using a chapter Definition needs to be separated in Syntax and Description. Here\u0026rsquo;s an example  Adding content Don\u0026rsquo;t know where to start? Checkout the most wanted page.\nThe DPL part of the site will be done by the administrators of the wiki, so don\u0026rsquo;t worry about that. Just copy an existing page and use it as a template.\nList of functions known to not be completely documented Below you can find a list of undocumented/partially documented BennuGD features as reported by forum user Kloppix. Comments in Spanish will soon be translated into English and all of the following should be checked.\nMod_cd DONE\n*Globals\n STRUCT cdinfo\nMod_dir DONE\n*Functions:\n STRING DIRREAD(INTEGER)\nMod_draw DONE\n*Functions:\n INT PUT_PIXEL(INTEGER, INTEGER, INTEGER)\n INT GET_PIXEL(INTEGER, INTEGER)\nMod_effects DONE\n*Constants::\n INT GSCALE_RGB = 0\n INT GSCALE_R = 1\n INT GSCALE_G = 2\n INT GSCALE_B = 3\n INT GSCALE_RG = 4\n INT GSCALE_RB = 5\n INT GSCALE_GB = 6\n INT GSCALE_OFF = -1\n Functions:   INT FILTER(INTEGER, INTEGER, POINTER)\nMod_file DONE\n*Functions:\n UNDEFINED FREWIND(INTEGER)\n INT FILE_EXISTS(STRING)\n INT FREMOVE(STRING)\n INT FMOVE(STRING, STRING)\nMod_flic DONE\n*Functions:\n INT START_FLI(STRING, INTEGER, INTEGER)\n INT END_FLI()\n INT FRAME_FLI()\n INT RESET_FLI()\n INT FLI_START(STRING, INTEGER, INTEGER)\n INT FLI_START(STRING, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER)\n INT FLI_END(INTEGER)\n INT FLI_FRAME(INTEGER)\n INT FLI_RESET(INTEGER)\n INT FLI_PARAMS(INTEGER, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER)\n INT FLI_MOVE(INTEGER, INTEGER, INTEGER)\n INT FLI_ANGLE(INTEGER, INTEGER)\n INT FLI_SIZE(INTEGER, INTEGER)\n INT FLI_FLAGS(INTEGER, INTEGER)\n INT FLI_Z(INTEGER, INTEGER)\n INT FLI_GETINFO(INTEGER, POINTER, POINTER, POINTER, POINTER, POINTER, POINTER, POINTER, POINTER, POINTER)\nMod_joy\n Functions:   INT JOY_GETPOSITION(INTEGER)\n INT JOY_GETPOSITION(INTEGER, INTEGER)\n INT JOY_GETACCEL(POINTER, POINTER, POINTER)\n INT JOY_GETACCEL(INTEGER, POINTER, POINTER, POINTER)\n INT NUMBER_JOY()\n INT SELECT_JOY(INTEGER)\n INT GET_JOY_BUTTON(INTEGER)\n INT GET_JOY_BUTTON(INTEGER, INTEGER)\n Según entendí, en la Wiki se dice que JOY_GETBALL acepta 2 o 3 parámetros en lugar de 3 o 4. [[Joy_getball) INT JOY_GETBALL(INTEGER, POINTER, POINTER) INT JOY_GETBALL(INTEGER, INTEGER, POINTER, POINTER)  Mod_m7 DONE\n*Globals:\n STRUCT m7[9]\n Functions:   INT MODE7_START(INTEGER, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER)\n INT MODE7_START(INTEGER, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER)\n INT MODE7_STOP(INTEGER)\n INT START_MODE7(INTEGER, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER)\n INT START_MODE7(INTEGER, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER)\n INT STOP_MODE7(INTEGER)\nMod_map\n*Constants::\n INT G_Y_CENTER = 3\n INT B_CLEAR = 1\n INT CHARSET_ISO8859 = 0\n INT CHARSET_CP850 = 1\n INT NFB_VARIABLEWIDTH = 0\n INT NFB_FIXEDWIDTH = 1\n Functions:   INT MAP_NEW(INTEGER, INTEGER, INTEGER, INTEGER) #Aparece en la Wiki pero dice que sólo acepta 3 parámetros en lugar de 3 o 4 Map_new #parcialmente hecho, falta detallar flags\n INT MAP_DEL(INTEGER, INTEGER)\n POINTER MAP_BUFFER(INTEGER, INTEGER)\n INT FPG_LOAD(STRING, POINTER) # Según la WIKI acepta sólo 1 parámetro\n INT FPG_DEL(INTEGER)\n INT PAL_NEW()\n INT PAL_DEL(INTEGER)\n INT PAL_UNLOAD(INTEGER)\n INT PAL_CLONE(INTEGER)\n INT PAL_REFRESH()\n INT PAL_REFRESH(INTEGER)\n INT PAL_MAP_GETID(INTEGER, INTEGER)\n INT PAL_MAP_ASSIGN(INTEGER, INTEGER, INTEGER)\n INT PAL_MAP_REMOVE(INTEGER, INTEGER)\n INT PAL_GET(INTEGER, INTEGER, POINTER)\n INT PAL_GET(INTEGER, INTEGER, INTEGER, POINTER)\n INT PAL_SYS_SET(INTEGER)\n INT PAL_SYS_SET(POINTER)\n INT PAL_SET(INTEGER, INTEGER, POINTER)\n INT PAL_SET(INTEGER, INTEGER, INTEGER, POINTER)\n INT PAL_SAVE(STRING)\n INT PAL_SAVE(STRING, INTEGER)\n INT COLORS_SET(INTEGER, INTEGER, POINTER)\n INT COLORS_SET(INTEGER, INTEGER, INTEGER, POINTER)\n INT COLORS_GET(INTEGER, INTEGER, POINTER)\n INT COLORS_GET(INTEGER, INTEGER, INTEGER, POINTER)\n INT PALETTE_ROLL(INTEGER, INTEGER, INTEGER)\n INT PALETTE_CONVERT(INTEGER, INTEGER, POINTER)\n INT COLOR_FIND(BYTE, BYTE, BYTE)\n INT RGB(BYTE, BYTE, BYTE, INTEGER) #Según Wiki sólo acepta 3 parámetros en lugar de 3 o 4 \n INT RGBA(BYTE, BYTE, BYTE, BYTE, INTEGER) #Según Wiki sólo acepta 4 parámetros en lugar de 4 o 5 \n INT RGB_GET(INTEGER, POINTER, POINTER, POINTER, INTEGER)\n INT RGB_GET(INTEGER, POINTER, POINTER, POINTER)\n INT RGBA_GET(INTEGER, POINTER, POINTER, POINTER, POINTER, INTEGER)\n INT RGBA_GET(INTEGER, POINTER, POINTER, POINTER, POINTER)\n INT MAP_INFO_SET(INTEGER, INTEGER, INTEGER, INTEGER)\n INT MAP_INFO_GET(INTEGER, INTEGER, INTEGER)\n INT MAP_INFO(INTEGER, INTEGER, INTEGER)\n INT GRAPHIC_SET(INTEGER, INTEGER, INTEGER, INTEGER)\n INT FNT_NEW(INTEGER, INTEGER) # Según la Wiki solo acepta 1 parámetro\n INT FNT_NEW(INTEGER, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER)\n INT BDF_LOAD(STRING)\n INT PCX_LOAD(STRING)\n INT NEW_MAP(INTEGER, INTEGER, INTEGER)\n INT LOAD_MAP(STRING)\n INT UNLOAD_MAP(INTEGER, INTEGER)\n INT SAVE_MAP(INTEGER, INTEGER, STRING)\n INT NEW_PAL()\n INT LOAD_PAL(STRING)\n INT UNLOAD_PAL(INTEGER)\n INT SAVE_PAL(STRING)\n INT SAVE_PAL(STRING, INTEGER)\n INT SET_COLORS(INTEGER, INTEGER, POINTER)\n INT SET_COLORS(INTEGER, INTEGER, INTEGER, POINTER)\n INT GET_COLORS(INTEGER, INTEGER, POINTER)\n INT GET_COLORS(INTEGER, INTEGER, INTEGER, POINTER)\n INT ROLL_PALETTE(INTEGER, INTEGER, INTEGER)\n INT CONVERT_PALETTE(INTEGER, INTEGER, POINTER)\n INT FIND_COLOR(BYTE, BYTE, BYTE)\n INT GET_RGB(INTEGER, POINTER, POINTER, POINTER, INTEGER)\n INT GET_RGBA(INTEGER, POINTER, POINTER, POINTER, POINTER, INTEGER)\n INT GET_RGB(INTEGER, POINTER, POINTER, POINTER)\n INT GET_RGBA(INTEGER, POINTER, POINTER, POINTER, POINTER)\n INT NEW_FPG()\n INT LOAD_FPG(STRING)\n INT LOAD_FPG(STRING, POINTER)\n INT SAVE_FPG(INTEGER, STRING)\n INT UNLOAD_FPG(INTEGER)\n INT GET_POINT(INTEGER, INTEGER, INTEGER, POINTER, POINTER)\n INT SET_POINT(INTEGER, INTEGER, INTEGER, INTEGER, INTEGER)\n INT SET_CENTER(INTEGER, INTEGER, INTEGER, INTEGER)\n INT NEW_FNT(INTEGER)\n INT NEW_FNT(INTEGER, INTEGER)\n INT NEW_FNT(INTEGER, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER)\n INT LOAD_FNT(STRING)\n INT UNLOAD_FNT(INTEGER)\n INT SAVE_FNT(INTEGER, STRING)\n INT LOAD_BDF(STRING)\n INT GET_GLYPH(INTEGER, INTEGER) \n INT SET_GLYPH(INTEGER, INTEGER, INTEGER, INTEGER)\n INT LOAD_PNG(STRING)\n INT LOAD_PCX(STRING)\n INT SAVE_PNG(INTEGER, INTEGER, STRING)\nMOD_MATHI # En la Wiki solo hay MOD_MATH. Nada de MOD_MATHI Las funciones de los 2 módulos son las mismas pero trabajan con otro tipo de variables. No se que hacer acá.\nMod_math DONE\n*Functions:\n FLOAT ATAN2(FLOAT, FLOAT)\n INT ISINF(FLOAT)\n INT ISNAN(FLOAT)\n INT FINITE(FLOAT)\n INT NEAR_ANGLE(INTEGER, INTEGER, INTEGER)\nMod_mem DONE\n*Functions:\n POINTER MEM_CALLOC(INTEGER, INTEGER)\n POINTER MEM_ALLOC(INTEGER)\n INT MEM_FREE(POINTER)\n POINTER MEM_REALLOC(POINTER, INTEGER)\n INT MEM_CMP(POINTER, POINTER, INTEGER)\n INT MEM_SET(POINTER, BYTE, INTEGER)\n INT MEM_SETW(POINTER, WORD, INTEGER)\n INT MEM_SETI(POINTER, INTEGER, INTEGER)\n INT MEM_COPY(POINTER, POINTER, INTEGER)\n INT MEM_MOVE(POINTER, POINTER, INTEGER)\n INT MEM_AVAILABLE()\n INT MEM_TOTAL()\n POINTER CALLOC(INTEGER, INTEGER)\nMod_path DONE\n*Functions:\n INT PATH_FIND(INTEGER, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER)\n INT PATH_GETXY(POINTER, POINTER)\n INT PATH_WALL(INTEGER)\nMod_proc DONE\n*Constants::\n INT S_FORCE = 50 Internal use\n INT S_TREE = 100 Internal use\n INT S_KILL_TREE = 100\n INT ALL_PROCESS = 0 Internal use\nLocals: Internal use\n STRUCT mod_proc_reserved\n Functions:   INT GET_STATUS(INTEGER)\nMod_regex DONE\n*Globals:\n STRING regex_reg[15];\n Functions:   INT REGEX(STRING, STRING)\n STRING REGEX_REPLACE(STRING, STRING, STRING)\n STRING JOIN(STRING, POINTER, INTEGER)\nMod_say DONE\n*Functions:\n UNDEFINED SAY_FAST(STRING)\nMod_screen DONE\n*Functions:\n INT DEFINE_REGION(INTEGER, INTEGER, INTEGER, INTEGER, INTEGER)\n INT OUT_REGION(INTEGER, INTEGER)\n INT PUT_SCREEN(INTEGER, INTEGER)\n INT CLEAR_SCREEN()\n INT GET_SCREEN()\nMod_scroll DONE\n*Functions:\n INT SCROLL_START(INTEGER, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER)\n INT SCROLL_START(INTEGER, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER)\n INT SCROLL_STOP(INTEGER)\n INT SCROLL_MOVE(INTEGER)\n INT START_SCROLL(INTEGER, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER)\n INT START_SCROLL(INTEGER, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER)\n INT STOP_SCROLL(INTEGER)\n INT MOVE_SCROLL(INTEGER)\nMod_sound DONE\n*Functions:\n INT SOUND_INIT()\n INT SOUND_CLOSE()\n INT STOP_SONG()\n INT STOP_WAV(INTEGER)\n INT PAUSE_WAV(INTEGER)\n INT RESUME_WAV(INTEGER)\n INT IS_PLAYING_WAV(INTEGER)\n INT FADE_MUSIC_IN(INTEGER, INTEGER, INTEGER)\n INT FADE_MUSIC_OFF(INTEGER)\n INT SET_CHANNEL_VOLUME(INTEGER, INTEGER)\n INT RESERVE_CHANNELS(INTEGER)\n INT SET_PANNING(INTEGER, INTEGER, INTEGER)\n INT SET_POSITION(INTEGER, INTEGER, INTEGER)\n INT SET_DISTANCE(INTEGER, INTEGER)\n INT REVERSE_STEREO(INTEGER, INTEGER)\n INT PLAY_WAV(INTEGER, INTEGER, INTEGER)\n INT SET_MUSIC_POSITION(FLOAT)\n # INT UNLOAD_SONG(POINTER)\n # INT UNLOAD_WAV(POINTER) \n # Las funciones de arriba aceptan INT y POINTER, pero en la wiki sólo sale lo primero. No se si es un error o es normal puesto que no entiendo mucho de pointers \nMod_string DONE\n*Functions:\n INT STRLEN(STRING)\n STRING FORMAT(INTEGER)\n STRING FORMAT(FLOAT)\n STRING FORMAT(FLOAT, INTEGER)\nMod_text DONE\n*Constants::\n INT ALL_TEXT = 0\nMod_timers DONE\n*Globals:\n timer[9];\nMod_video DONE\n*Functions:\n INT SET_MODE(INTEGER) # Segun la wiki acepta 2,3 o 4 parámetros. pero no dice que también 1 sólo (O eso entendí)\n*Module Dependency:\n libgrbase\n libvideo\n librender\nMod_wm DONE\n*Functions:\n INT SET_WINDOW_POS(INTEGER, INTEGER)\n","permalink":"https://divhub.github.io/pixtudio-website/docs/todo/","title":""},{"contents":" Definition STRING trim ( \u0026lt;STRING str\u0026gt; )\nReturns a copy of str without leading or ending whitespace (spaces, tabs, linefeeds, carriage returns).\nParameters STRING str - The string to trim.\nReturns STRING: trimmed string\nExample import \u0026quot;mod_string\u0026quot; import \u0026quot;mod_say\u0026quot; Const _ABC_ = \u0026quot; ABC \u0026quot;; End Process Main() Private string ABC; Begin ABC = trim(_ABC_); say('_ABC_ = \u0026quot;' + _ABC_ + '\u0026quot;'); say('ABC = \u0026quot;' + ABC + '\u0026quot;'); End  Used in example: say(), trim()\nResult:\n_ABC_ = \u0026quot; ABC \u0026quot; ABC = \u0026quot;ABC\u0026quot;  Category:functions Category:strings Category:mod_string\n","permalink":"https://divhub.github.io/pixtudio-website/docs/trim/","title":""},{"contents":"Up to TTF.DLL\nChangelog of TTF.DLL.\nCategory:changelog Category:ttfdll Category:dll\n","permalink":"https://divhub.github.io/pixtudio-website/docs/ttf_changelog/","title":""},{"contents":"Up to Index\nList of Tutorials\nTutorials about Bennu categorized. They range from beginner to advanced users.\nNot many on here as of yet, add if you please!\n category=tutorialcategories mode=userformat listseparators = ,\\n* %TITLE%,, redirects = include \n","permalink":"https://divhub.github.io/pixtudio-website/docs/tutorialcategories/","title":""},{"contents":"Up to Index\nTutorial Categories\nList of tutorials about Bennu. They range from beginner to advanced users.\nNot many on here as of yet - Wiki users add if you please!\n category=tutorials mode=userformat listseparators = ,\\n* %TITLE%,, redirects = include noresultsheader = No tutorials here yet. resultsfooter = \\n%PAGES% tutorials \n","permalink":"https://divhub.github.io/pixtudio-website/docs/tutorials/","title":""},{"contents":" Datatype declaration Definition Type {name} {variables} End  Creates a new datatype. It\u0026rsquo;s handled as if it were a struct, so the declared variables are members of the struct.\nWhile it\u0026rsquo;s a convention to use a _ as first character in the name of a datatype, it\u0026rsquo;s not mandatory.\nWhen used as an argument in a function or process, the parameter is not a copy, but the variable itself, as shown in the first example, and any change made to the parameter is also changed in the argument. It\u0026rsquo;s more elegant to use a pointer though, as it also displayed.\nExample A file with name and path. Note that the assignment myFile2 = myFile; makes a copy of myFile and throws it into myFile2, which is normal. But when it\u0026rsquo;s used as an argument in a function, the parameter is not a copy but the _file itself.\n Type _file String path; String name; End Process Main() Private _file myFile; _file myFile2; Begin myFile.path = \u0026quot;C:\\\u0026quot;; myFile.name = \u0026quot;autoexec.bat\u0026quot;; say(\u0026quot;1: \u0026quot; + myFile.path + myFile.name); myFile2 = myFile; myFile2.name = \u0026quot;config\u0026quot;; say(\u0026quot;1: \u0026quot; + myFile.path + myFile.name); say(\u0026quot;2: \u0026quot; + myFile2.path + myFile2.name); setName(myFile,\u0026quot;pagefile\u0026quot;); say(\u0026quot;1: \u0026quot; + myFile.path + myFile.name); setName2(\u0026amp;myFile2,\u0026quot;pagefile\u0026quot;); say(\u0026quot;2: \u0026quot; + myFile2.path + myFile2.name); Repeat frame; Until(key(_ESC)) End Function setName(_file f, string name) Begin f.name = name; End Function setName2(_file* f, string name) Begin f.name = name; // this is actually (*f).name = name, but . can be used like this End  Used in example: say(), key(), Pointer\nA point with x and y.\n // Declare the type _point Type _point float x; float y; End // Declare the function distance(), because the function returns a datatype // other than int, so it needs to be declared before usage. Declare float distance(_point a,_point b) End Process Main() Private _point p1,p2; Begin p1.x = 15.3; p1.y = 34.9; p2.x = 165.4; p2.y = 137.2; write(0,0,0,0,\u0026quot;Distance: \u0026quot; + distance(p1,p2)); drw_line(p1,p2); Repeat frame; Until(key(_ESC)) End Function float distance(_point a, _point b) Begin return sqrt( (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y) ); End Function int drw_line(_point a, _point b) Begin return draw_line( a.x , a.y , b.x , b.y ); End  Used in example: write(), key(), sqrt(), draw_line()\nProcessType Definition Type {processname}  Acquires the processTypeID of a processType or function. This can be useful for example with get_id() and signal().\nExample  Program example; Private proc proc_id; //int could be used too Begin // Start 3 proc's proc(); proc(); proc(); // Display all alive proc's y = 0; while( (proc_id=get_id(type proc)) ) write(0,0,(y++)*10,0,\u0026quot;proc: \u0026quot; + proc_id); end // Wait for key ESC Repeat frame; Until(key(_ESC)) End Process proc() Begin Loop frame; End End  Used in example: get_id(), write(), key()\n","permalink":"https://divhub.github.io/pixtudio-website/docs/type/","title":""},{"contents":" Definition STRING ucase ( \u0026lt;STRING str\u0026gt; )\nReturns a string identical to a certain string, with the exception that all lowercase characters are replaced by their uppercase counterparts.\nParameters STRING str - The string in \u0026ldquo;normal\u0026rdquo;-form.\nReturns STRING : The string in \u0026ldquo;uppercase\u0026rdquo;-form.\nCategory:functions Category:strings Category:mod_string\n","permalink":"https://divhub.github.io/pixtudio-website/docs/ucase/","title":""},{"contents":" Definition INT unload_song ( \u0026lt;INT SongID\u0026gt; )\nFrees the memory occupied by the song file, previously loaded with load_song().\nParameters INT SongID - The SongID of the song to unload.\nReturns INT : Error.\n-1 - Error: sound inactive; invalid songID. 0 - No error.\nNotes Instead of an INT a POINTER may also be used in the SongID argument.\nCategory:functions Category:sound Category:mod_sound\n","permalink":"https://divhub.github.io/pixtudio-website/docs/unload_song/","title":""},{"contents":" Definition INT unload_wav ( \u0026lt;INT WaveID\u0026gt; )\nFrees the memory occupied by the wave file, previously loaded with load_wav().\nParameters INT WaveID - The WaveID of the sound to unload.\nReturns INT : Error.\n-1 - Error: sound inactive; invalid waveID. 0 - No error.\nNotes Instead of an INT a POINTER may also be used in the WaveID argument.\nCategory:functions Category:sound Category:mod_sound\n","permalink":"https://divhub.github.io/pixtudio-website/docs/unload_wav/","title":""},{"contents":" A value can be in a container, like a variable or constant. It can also be returned by a process or function.\nSee Also  Constant Variable  ","permalink":"https://divhub.github.io/pixtudio-website/docs/value/","title":""},{"contents":" A variable is a container containing a value. This value can vary, hence the name variable, as opposed to a constant of which the value cannot be changed. A variable can be of any datatype and can contain a value according to its datatype. For example, an integer has whole numbers between -2\\^31 and +2\\^31-1 (e.g. 23) , a float has a floating point number (e.g. 2.674) and a string has a series of characters (e.g. \u0026ldquo;Hello World!\u0026rdquo;).\nThere is a number of predefined variables, like local variables and global variables. These variables are predefined, which means they exist without the programmer making them. They can contain useful information or perform an action when changed.\nA function or process can accept values when called. The value it\u0026rsquo;s called with is called an argument and the variable or value inside the function or process is called a parameter.\nSee Also  A list of predefined variables Constant  Category:General\n","permalink":"https://divhub.github.io/pixtudio-website/docs/variable/","title":""},{"contents":" :category:variables\nDefinition VariableType VariableName\nVariableName is for variable variabilities.\nNotes Don\u0026rsquo;t set it to -1 or your pc will explode.\nExample VariableName = 100;  ","permalink":"https://divhub.github.io/pixtudio-website/docs/variable_example/","title":""},{"contents":" Up to Index\nList of Variables\nPredefined variable categories  category=predefinedvariablecategories mode=userformat listseparators = ,\\n* %TITLE%,, redirects = include \n","permalink":"https://divhub.github.io/pixtudio-website/docs/variablecategories/","title":""},{"contents":"Up to Index\nVariable Categories\nList of all predefined variables.\nGlobal variables  category=global variables mode=userformat listseparators = ,\\n* %TITLE%,, redirects = include replaceintitle = /\\\\? /,_ \nLocal variables  category=local variables mode=userformat listseparators = ,\\n* %TITLE%,, redirects = include replaceintitle = /\\\\? /,_ \n","permalink":"https://divhub.github.io/pixtudio-website/docs/variables/","title":""},{"contents":" Definition VARSPACE\nA varspace is a datatype of any datatype. When a function, like sort() or fread(), has a parameter of type varspace, it means it needs a variable of any type.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/varspace/","title":""},{"contents":" Definition VOID\nPixTudio doesn\u0026rsquo;t have voids as such. But when we look at for example the function free(), we see that you can pass it a void pointer. This means, that you can pass it a pointer of whatever type you want; an int pointer, word pointer or even a pointer pointer. So in this case, void means \u0026ldquo;any\u0026rdquo;.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/void/","title":""},{"contents":" Definition WaveID\nA WaveID is an identifier associated with a certain wave-sound loaded by load_wav(). The identifier can be used in various other functions, like unload_wav() to unload the wave-sound.\nCategory:general\n","permalink":"https://divhub.github.io/pixtudio-website/docs/waveid/","title":""},{"contents":"PixTudio is an Open Source 2D game engine and scripting language that originated as a fork of BennuGD. The project puts an emphasis on mobile gaming but it perfectly suitable for 2D game creation for the desktop, too. The scripting language is easy to understand and makes use of co-routines, called processes.\nThe game engine is, also, highly portable and should compile directly in Windows, Linux, OS X, Android \u0026amp; iOS but past versions of the code where compiled for multiple console systems (including Nintendo\u0026rsquo;s Wii). It should also work with varying grades of effort in other Unices, Haiku or even newer console systems, given that an SDL2 port exists for the platform in question.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/what_is_pixtudio/","title":""},{"contents":" category:variables category:predefined category:global variables category:libwm\nUp to Global Variables\nDefinition INT window_status\nwindow_status is a predefined global variable, holding whether or not the Bennu window is visible. For example the window is not visible when it is minimized.\nValue - Description false - The Bennu window is not visible. true - The Bennu window is visible.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/window_status/","title":""},{"contents":" Definition INT write ( \u0026lt;INT fontID\u0026gt; , \u0026lt;INT x\u0026gt; , \u0026lt;INT y\u0026gt; , [\u0026lt;INT z\u0026gt;] , \u0026lt;INT alignment\u0026gt; , \u0026lt;STRING text\u0026gt;)\nPuts a dynamic text with a certain font on certain coordinates on the screen with a certain alignment.\nParameters INT fontID - The FontID of the font to be used for the text. INT x - The X coordinate of the text. INT y - The Y coordinate of the text. INT z - The depthplane of the text (optional, introduced in version rc282). INT alignment - The type of alignment. STRING text - The text to be used.\nReturns INT : TextID\n-1 - Error. The text could not be obtained or was empty. \u0026gt;=0 - The TextID of the text.\nNotes There is a limit of 511 texts to simultaneously exist on the screen. The program will crash with an error when this number is reached.\nThe text depth can be changed by adjusting the global variable text_z.\nTo write variables to the screen, rather use write_int(), write_string(), write_float() or write_var() than this command.\nTo write text on a map you can use the command write_in_map().\nIf you write texts with a font and you change any symbol of this font after, all written texts will be updated using the new changed symbols.\nExample Program texts; Const maxtexts = 10; Private int textid[maxtexts-1]; string str; float flt; Begin // Set FPS set_fps(60,0); // Write some texts textid[0] = write(0,0,0,0,\u0026quot;FPS:\u0026quot;); textid[1] = write_int(0,30,0,0,\u0026amp;fps); textid[2] = write_string(0,160,95,1,\u0026amp;str); textid[3] = write_float(0,160,105,0,\u0026amp;flt); // Update the texts until ESC is pressed Repeat // Notice the texts get updated as the values of str and flt changes. // The same goes for the value of fps. str = \u0026quot;This program is running for \u0026quot; + timer/100 + \u0026quot; seconds.\u0026quot;; flt = (float)timer/100; frame; Until(key(_esc)); // Delete the texts for(x=0; x\u0026lt;maxtexts; x++) if(textid[x]!=0) delete_text(textid[x]); end end End  Used in example: set_fps(), write_int(), write_string(), write_float(), key(), delete_text(), array, fps, TextID\nThis will result in something like:\nCategory:functions Category:texts Category:mod_text\n","permalink":"https://divhub.github.io/pixtudio-website/docs/write/","title":""},{"contents":" Definition INT write_float ( \u0026lt;INT fontID\u0026gt; , \u0026lt;INT x\u0026gt; , \u0026lt;INT y\u0026gt; , [\u0026lt;INT z\u0026gt;] , \u0026lt;INT alignment\u0026gt; , \u0026lt;FLOAT POINTER var\u0026gt; )\nWrites a floating point variable to the screen, which will be automatically updated when the value of the variable changes. The floating point variable will remain on the screen until deleted with delete_text().\nParameters INT fontID - The FontID of the font to be used for the text. INT x - The X coordinate of the text. INT y - The Y coordinate of the text. INT z - The depthplane of the text (optional, introduced in version rc282). INT alignment - The type of alignment. FLOAT POINTER var - A pointer to a floating point variable.\nReturns INT : TextID\n-1 - Error. \u0026gt;=0 - The TextID of the text.\nNotes There is a limit of 511 texts to simultaneously exist on the screen. The program will crash with an error when this number is reached.\nThe text depth can be changed by adjusting the global variable text_z.\nInstead of write_float(), write_var() can be used for the same purpose, which is a more general function that allows you to write variables of any type to the screen.\nErrors Too many texts onscreen - There are too many texts on the screen.\nExample Program test; Private float my_float=3.14159265; Begin write_float(0,320/2,200/2,4,\u0026amp;my_float); Repeat Frame; Until(key(_ESC)) End  This will result in something like:\nCategory:functions Category:texts Category:mod_text\n","permalink":"https://divhub.github.io/pixtudio-website/docs/write_float/","title":""},{"contents":" Definition INT write_in_map ( \u0026lt;INT fontID\u0026gt; , \u0026lt;STRING text\u0026gt; , \u0026lt;INT alignment\u0026gt; )\nCreates a new graphic in memory with the given text on it (without borders around the text) and puts it in the system file.\nParameters INT fontID - The FontID of the font to be used for the text. STRING text - The text to be used. INT alignment - The type of alignment.\nReturns INT : GraphID\n0 - Error. The text could not be obtained or was empty. !0 - The GraphID of the graphic of the generated graphic in the system file.\nNotes This function creates a graphic containing the specified font, with a width and height determined by the physical size of the text; the graphic\u0026rsquo;s size will fit the text exactly to the pixel. The graphic will be stored in memory with FileID 0 (using the system file), and can be obtained at any time by calling its GraphID. The graphic can also be unloaded from memory by using unload_map().\nThe centre of the graph (control point 0) is given according to the given alignment. This gives added functionality of being able to place the graph like texts, yet also using flags, alpha, rotation, collision(), etc.\nProcesses can adopt the graphic containing the text, or it can be displayed with some maps functions, creating a very handy function.\nErrors Invalid font - The specified font does not exist or is invalid.\nExample Program example; Begin Set_text_color(rgb(222,195,140)); graph=write_in_map(0,\u0026quot;Game programming is awesome!\u0026quot;,4); repeat x=mouse.x; y=mouse.y; frame; until(key(_esc)) End  Used in example: set_text_color(), rgb(), key(), x, y, mouse\nThis will result in something like:\nCategory:functions Category:texts Category:mod_text\n","permalink":"https://divhub.github.io/pixtudio-website/docs/write_in_map/","title":""},{"contents":" Definition INT write_int ( \u0026lt;INT fontID\u0026gt; , \u0026lt;INT x\u0026gt; , \u0026lt;INT y\u0026gt; , [\u0026lt;INT z\u0026gt;] , \u0026lt;INT alignment\u0026gt; , \u0026lt;INT POINTER var\u0026gt; )\nWrites an integer to the screen, which will be automatically updated when the value of the integer changes. The integer will remain on the screen until deleted with delete_text().\nParameters INT fontID - The FontID of the font to be used for the text. INT x - The X coordinate of the text. INT y - The Y coordinate of the text. INT z - The depthplane of the text (optional, introduced in version rc282). INT alignment - The type of alignment. INT POINTER var - A pointer to an integer.\nReturns INT : TextID\n-1 - Error. \u0026gt;=0 - The TextID of the text.\nNotes There is a limit of 511 texts to simultaneously exist on the screen. The program will crash with an error when this number is reached.\nThe text depth can be changed by adjusting the global variable text_z.\nInstead of write_int(), write_var() can be used for the same purpose, which is a more general function that allows you to write variables of any type to the screen.\nErrors Too many texts onscreen - There are too many texts on the screen.\nExample Program test; Private my_integer=0; Begin write_int(0,320/2,200/2,4,my_integer); Repeat my_integer=rand(1,1000); frame; Until(key(_ESC)) End  Used in example: rand(), key()\nThis will result in something like:\nCategory:functions Category:texts Category:mod_text\n","permalink":"https://divhub.github.io/pixtudio-website/docs/write_int/","title":""},{"contents":" Syntax INT write_string ( \u0026lt;INT fontID\u0026gt; , \u0026lt;INT x\u0026gt; , \u0026lt;INT y\u0026gt; , \u0026lt;INT alignment\u0026gt; , \u0026lt;STRING POINTER var\u0026gt; )\nDescription Writes a string to the screen, which will be automatically updated when the value of the string changes. The string will remain on the screen until deleted with delete_text().\nParameters INT fontID - The FontID of the font to be used for the text. INT x - The X coordinate of the text. INT y - The Y coordinate of the text. INT alignment - The type of alignment. STRING POINTER var - A pointer to a string.\nReturns INT : TextID\n-1 - Error. The text could not be obtained or was empty. \u0026gt;=0 - The TextID of the text.\nNotes There is a limit of 511 texts to simultaneously exist on the screen. The program will crash with an error when this number is reached.\nThe text depth can be changed by adjusting the global variable text_z.\nInstead of write_string(), write_var() can be used for the same purpose, which is a more general function that allows you to write variables of any type to the screen.\nErrors Too many texts onscreen - There are too many texts on the screen.\nExample import \u0026quot;mod_text\u0026quot; import \u0026quot;mod_key\u0026quot; Global string my_string=\u0026quot;Bennu Game Development\u0026quot;; End Process Main() Begin write_string(0,320/2,200/2,4,\u0026amp;my_string); Repeat frame; Until(key(_ESC)) End  Used in example: write_string(), key()\nThis will result in something like:\nCategory:functions Category:texts Category:mod_text\n","permalink":"https://divhub.github.io/pixtudio-website/docs/write_string/","title":""},{"contents":" Syntax INT write_var ( \u0026lt;INT fontID\u0026gt; , \u0026lt;INT x\u0026gt; , \u0026lt;INT y\u0026gt; , [\u0026lt;INT z\u0026gt;] , \u0026lt;INT alignment\u0026gt; , \u0026lt;VARSPACE var\u0026gt; )\nDescription Writes a variable of any kind to the screen, which will be automatically updated when the value of the variable changes. The variable will remain on the screen until deleted with delete_text().\nParameters INT fontID - The FontID of the font to be used for the text. INT x - The X coordinate of the text. INT y - The Y coordinate of the text. INT z - The depthplane of the text (optional, introduced in version rc282). INT alignment - The type of alignment. VARSPACE var - The name of any variable.\nReturns INT : TextID\n-1 - Error. \u0026gt;=0 - The TextID of the text.\nNotes Please note that for the varspace var parameter no pointer should be filled out, while write_int()/write_string()/write_float() do require a pointer.\nThere is a limit of 511 texts to simultaneously exist on the screen. The program will crash with an error when this number is reached.\nThe text depth can be changed by adjusting the global variable text_z.\nInstead of write_var(), write_int() could be used to write an int to the screen, write_string() for a string, write_float() for a float.\nErrors Too many texts onscreen - There are too many texts on the screen.\nExample import \u0026quot;mod_text\u0026quot; import \u0026quot;mod_key\u0026quot; Global my_integer=0; string my_string=\u0026quot;Bennu Game Development\u0026quot;; End Process Main() Begin write_var(0,0,0,0,my_string); write_var(0,320/2,200/2,4,my_integer); Repeat my_integer=rand(1,1000); frame; Until(key(_ESC)) End  Used in example: write_var(), rand(), key()\nThis will result in something like:\nCategory:functions Category:texts Category:mod_text\n","permalink":"https://divhub.github.io/pixtudio-website/docs/write_var/","title":""},{"contents":"  variables](category:local_variables \u0026ldquo;wikilink\u0026rdquo;) category:librender This is about the local variable. Did you mean the scan code _X?\n  ). Did you mean the scan code _X?*\nUp to Local Variables\nDefinition INT x = 0\nX is a predefined local variable that defines the vertical position of the process graph in the screen.\nSee also  y z  ","permalink":"https://divhub.github.io/pixtudio-website/docs/x/","title":""},{"contents":" Definition INT xadvance ( \u0026lt;INT angle\u0026gt; , \u0026lt;INT distance\u0026gt; )\nMoves a process a certain distance in a certain direction.\nParameters INT angle - The angle in which to move the process, in thousandths of a degree. INT distance - The distance to move the process, in pixels.\nReturns INT : Successrate\ntrue - Success. false - Error.\nExample Program example; Global myproc; Begin myproc=proc(); Loop frame; End End Process proc(); Begin x=100; y=100; Loop xadvance(90000,10); //moves the process vertically (90 degrees) 10 pixels frame; End End  Category:functions Category:processinteraction Category:mod_grproc\n","permalink":"https://divhub.github.io/pixtudio-website/docs/xadvance/","title":""},{"contents":" category:variables category:predefined category:local variables category:libscroll category:librender\nUp to Local Variables\nDefinition The predefined local variable xgraph is assigned to each process. It is the so called \u0026ldquo;extended\u0026rdquo; graphic, and it allows graphics to be displayed that are controlled by the nearest process Angle. When the xgraph is defined, the normal variable Graph is ignored, and the graphic used for display is determined by the angle.\nSo when the angle changes, a different graphic is selected from a table (defined as an Array). The standard value of xgraph is 0, so normally it isn\u0026rsquo;t used unless it is explicitly specified. Xgraps are usefull in combination with Mode7, to create graphics with perspectives. This mechanism is similair to how Wolfenstein3D, Doom and Duke Nukem 3D render their sprites. So it\u0026rsquo;s not true 3d, but just a bunch of sprites wich perspective depends on the viewing angle.\nHow to use it First, you\u0026rsquo;ll have to make sprites for all intended perspective\u0026rsquo;s. To more angle\u0026rsquo;s you wish, the more perspectives you\u0026rsquo;ll need.\nSecond, you must place the graphics in order of their angle, in clockwise fashion.\nThird, you\u0026rsquo;ll have to make a table with the graphic codes.\nGLOBAL perspective_table[]=4,10,11,12,13; // the length doesn't matter, but the more perspectives you wish, // the more graphics you need to have.  Fourth, you\u0026rsquo;ll have to assing the table offset to the xgraph.\nxgraph=\u0026amp;perspective_table; // xgraph get's the offset adress of the array.  The Offset operator is get\u0026rsquo;s the adress of the data, this is related to pointers.\nRemarks When xgraph is defined, it has to be set to 0 in order to deactivate it.\nWhen a graphic code in the table has a negative number, this graphic will be mirrored horizontally.\n","permalink":"https://divhub.github.io/pixtudio-website/docs/xgraph/","title":""},{"contents":" Definition INT xput ( \u0026lt;INT fileID\u0026gt; , \u0026lt;INT GraphID\u0026gt; , \u0026lt;INT x\u0026gt; , \u0026lt;INT y\u0026gt; , \u0026lt;INT angle\u0026gt; , \u0026lt;INT size\u0026gt; , \u0026lt;INT blitflags\u0026gt; , \u0026lt;INT region\u0026gt; )\nDraws (blits) a graphic onto the background.\nIf the advanced parameters aren\u0026rsquo;t needed, put() can be used.\nParameters INT fileID - The fileID of the file that holds the graphics. INT graphID - The graphID of the graphic to draw with. INT x - Where on the background graphic\u0026rsquo;s x-axis to put the graphic. INT y - Where on the background graphic\u0026rsquo;s y-axis to put the graphic. INT angle - What angle to draw the graphic at. INT size - What size to draw the graphic at. INT blitflags - What blit flags to draw the graphic with. INT regionID - The regionID of the region in which the graphic is only allowed to be drawn.\nReturns INT : true\nNotes The x and y parameters denote where to draw the graphic, that is, where the center of the to be drawn graphic will be. Blit flags can be used to give the drawing (blitting) a special effect.\nWhen angle is 0 and size is 100, the speed is greater, because the graph doesn\u0026rsquo;t need rotating or scaling.\nErrors Unsupported color depth - The graphic\u0026rsquo;s color depth is greater than the background graphic\u0026rsquo;s.\nCategory:functions Category:screen Category:mod_screen\n","permalink":"https://divhub.github.io/pixtudio-website/docs/xput/","title":""},{"contents":"  variables](category:local_variables \u0026ldquo;wikilink\u0026rdquo;) category:librender This is about the local variable. Did you mean the scan code _Y?\n  ). Did you mean the scan code _Y?*\nUp to Local Variables\nDefinition INT y = 0\nY is a predefined local variable that defines the horizontal position of the process graph in the screen.\nSee also  x z  ","permalink":"https://divhub.github.io/pixtudio-website/docs/y/","title":""},{"contents":"  variables](category:local_variables \u0026ldquo;wikilink\u0026rdquo;) category:librender This is about the local variable. Did you mean the scan code _Z?\n  ). Did you mean the scan code _Z?*\nUp to Local Variables\nDefinition INT z = 0\nZ is a predefined local variable that defines the depth position of the process graph in the screen. This variable affects what process graph will be drawn before other one. A process with higher z will be drawn beneath a process with a lower z.\nSee also  x y  ","permalink":"https://divhub.github.io/pixtudio-website/docs/z/","title":""},{"contents":" Compiling PixTudio from source code\nFedora 24 Workstation These instructions might work in earlier versions of Fedora and in other Fedora spins, too, but have only been tested in a fully updated fresh installation of Fedora 24 Workstation 64-bit.\nOpen a terminal Install the required command line utilities. sudo dnf group install \u0026quot;Development Tools\u0026quot; sudo dnf install cmake ninja-build Install the required dependencies. sudo dnf install SDL2-devel.i686 SDL2_mixer-devel.i686 libpng-devel.i686 zlib-devel.i686 libogg-devel.i686 libvorbis-devel.i686 libtheora-devel.i686 tre.i686 tre-devel.i686 sqlite-devel.i686 libcurl-devel.i686 openal-soft-devel.i686 freetype-devel.i686 glibc-devel.i686 libjpeg-turbo-devel.i686 libwebp-devel.i686 If you're going to package Android games, install ncurses-compat-libs, too. sudo dnf install ncurses-compat-libs Clone the source code repository. git clone https://gitlab.com/josebagar/pixtudio.git If you want basic Steam integration, download the SDK from here and unzip it to the '3rdparty' dir, then rename the uncrompressed folder to \u0026quot;steamworks\u0026quot;. cd pixtudio/3rdparty unzip [DOWNLOAD_PATH]/steamworks_sdk_142.zip mv sdk steamworks Compile the source code. cd pixtudio/projects/cmake ./build.sh Release If you want to manually specify the location of a non-systemwide SDL2 installation, you can set the SDL2DIR environment variable. cd pixtudio/projects/cmake SDL2DIR=[SDL2_INSTALL_PATH] ./build.sh Release The binaries should be in bin/gnulinux32.  Ubuntu 16.04 LTS These instructions might work in earlier versions of Ubuntu and in other Ubuntu flavours, too, but have only been tested in a fresh installation of Ubuntu 16.04 Desktop (64-bit).\nOpen a terminal Install the required command line utilities. sudo apt update sudo apt install git cmake ninja-build Install the required dependencies. sudo apt install libsdl2-dev:i386 libsdl2-mixer-dev:i386 libpng12-dev:i386 zlib1g-dev:i386 libogg-dev:i386 libvorbis-dev:i386 libtheora-dev:i386 libtre-dev:i386 libsqlite3-dev:i386 libcurl4-gnutls-dev:i386 libopenal-dev:i386 libfreetype6-dev:i386 libwebp-dev:i386 libjpeg-turbo8-dev:i386 libc6-dev-i386 Clone the source code repository. git clone https://gitlab.com/josebagar/pixtudio.git If you want basic Steam integration, download the SDK from here and unzip it to the '3rdparty' dir, then rename the uncrompressed folder to \u0026quot;steamworks\u0026quot;. cd pixtudio/3rdparty unzip [DOWNLOAD_PATH]/steamworks_sdk_142.zip mv sdk steamworks Compile the source code. cd pixtudio/projects/cmake ./build.sh Release If you want to manually specify the location of a non-systemwide SDL2 installation, you can set the SDL2DIR environment variable. cd pixtudio/projects/cmake SDL2DIR=[SDL2_INSTALL_PATH] ./build.sh Release The binaries should be in bin/gnulinux32.  OS X These instructions should work in earlier versions of OS X (as long as they\u0026rsquo;re supported by Apple), but have only been tested in a fresh install of OS X El Capitan.\nOpen a Terminal and execute the following command to check for the Xcode command line tools: clang If the output reads like the following the developer tools are already installed in your computer and you can skip to the next step: clang: error: no input files Otherwise, the following message will be displayed and a dialog will be opened offering to install either Xcode or the command line tools. Both should work. xcode-select: note: no developer tools were found at '/Applications/Xcode.app', requesting install. Choose and option in the dialog to download the command line developer tools. Close that terminal. Install MacPorts. Homebrew will probably work, too, but you'll have to adapt the instructions below. Open a new terminal and install the required MacPorts dependencies. sudo port install libsdl2 +universal libsdl2_mixer +universal libpng +universal zlib +universal libogg +universal libvorbis +universal libtheora +universal libmikmod +universal tre +universal smpeg2 +universal curl +universal chipmunk +universal freetype +universal ninja cmake Clone the source code repository. git clone https://gitlab.com/josebagar/pixtudio.git If you want basic Steam integration, download the SDK from here and unzip it to the '3rdparty' dir, then rename the uncrompressed folder to \u0026quot;steamworks\u0026quot;. cd pixtudio/3rdparty unzip [DOWNLOAD_PATH]/steamworks_sdk_142.zip mv sdk steamworks Compile the source code. cd pixtudio/projects/cmake ./build.sh Release If you want to manually specify the location of a non-systemwide SDL2 installation, you can set the SDL2DIR environment variable. cd pixtudio/projects/cmake SDL2DIR=[SDL2_INSTALL_PATH] ./build.sh Release The binaries should be in bin/osx32.  Windows 10 These instructions should work in earlier versions of Windows (as long as they\u0026rsquo;re supported by Microsoft), but have only been tested in Windows 10.\nInstall MSYS2 (don't forget to update it as described in the project page). Open MinGW-w64 Win32 Shell (not MSYS2 Shell!) Install the required command line and development tools. pacman -S msys/git mingw32/mingw-w64-i686-gcc mingw32/mingw-w64-i686-pkg-config mingw32/mingw-w64-i686-cmake mingw32/mingw-w64-i686-ninja Install the required dependencies. pacman -S mingw32/mingw-w64-i686-SDL2 mingw32/mingw-w64-i686-SDL2_mixer mingw32/mingw-w64-i686-libpng mingw32/mingw-w64-i686-zlib mingw32/mingw-w64-i686-libogg mingw32/mingw-w64-i686-libvorbis mingw32/mingw-w64-i686-libtheora mingw32/mingw-w64-i686-libmodplug mingw32/mingw-w64-i686-libmikmod mingw32/mingw-w64-i686-libtre-git mingw32/mingw-w64-i686-flac mingw32/mingw-w64-i686-sqlite3 mingw32/mingw-w64-i686-curl mingw32/mingw-w64-i686-chipmunk mingw32/mingw-w64-i686-openal mingw32/mingw-w64-i686-freetype mingw32/mingw-w64-i686-libxml2 mingw32/mingw-w64-i686-libjpeg mingw32/mingw-w64-i686-libwebp Clone the source code repository. git clone https://gitlab.com/josebagar/pixtudio.git If you want basic Steam integration, download the SDK from here and unzip it to the '3rdparty' dir, then rename the uncrompressed folder to \u0026quot;steamworks\u0026quot;. cd pixtudio/3rdparty unzip [DOWNLOAD_PATH]/steamworks_sdk_142.zip mv sdk steamworks Compile the source code. cd pixtudio/projects/cmake ./build.sh Release If you want to manually specify the location of a non-systemwide SDL2 installation, you can set the SDL2DIR environment variable. cd pixtudio/projects/cmake SDL2DIR=[SDL2_INSTALL_PATH] ./build.sh Release The binaries should be in bin/win32.  Android Install both the Android SDK \u0026amp; the NDK.\nPlease note that in order to compile PixTudio for Android yourself you don\u0026rsquo;t need really need Android Studio, only its SDK parts, but you might want to install the full Android Studio if you\u0026rsquo;re planning to develop other Android apps.\nInstall the Android 4.4.2 (API 19) SDK platform and -optionally- an emulator image from the Android SDK manager.\nDownload the PixTudio source code with Git (see instructions in the native compilation section).\nEdit projects/android/local.properties and change the sdk.dir property to point to your Android SDK installation dir.\nIf you want to install your game into a real Android device, be sure to enable USB debugging during your development session and connect your device to your computer with a USB cable.\nIf you\u0026rsquo;re going to develop in an emulator image, create one and start it now.\nOpen a command line in the main PixTudio source code folder. Then do:\nGo to the Android project folder: cd projects/android If you're using the Windows cmd.exe console, compile the C source code with: ndk-build.cmd Otherwise, compile it with: ndk-build Copy your game's resources into the \u0026quot;assets\u0026quot; folder and make sure to name the main DCB file (compiled with a desktop version of PixTudio) \u0026quot;main.dcb\u0026quot;. Typically, PixTudio resource files (FPG, MAP \u0026amp; FNT files) will actually be compressed in gzip format. PixTudio for Android cannot read compressed files from within APK files, so make sure that they are uncompressed. Compile the libraries, assets \u0026amp; Java code into an APK. ant debug Or compile the libraries, assets \u0026amp; Java code into an APK and install it in an attached Android device or emulator. ant debug install  iOS Install the latest version of Xcode from Apple.\nPlease note that PixTudio for iOS is still a work in progress project.\n","permalink":"https://divhub.github.io/pixtudio-website/compile/","title":"Compiling PixTudio from source code"}]